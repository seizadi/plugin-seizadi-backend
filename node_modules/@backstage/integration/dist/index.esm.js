import parseGitUrl from 'git-url-parse';
import fetch from 'cross-fetch';
import { createAppAuth } from '@octokit/auth-app';
import { Octokit } from '@octokit/rest';
import { DateTime } from 'luxon';

function isValidHost(host) {
  const check = new URL("http://example.com");
  check.host = host;
  return check.host === host;
}
function isValidUrl(url) {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}
function basicIntegrations(integrations, getHost) {
  return {
    list() {
      return integrations;
    },
    byUrl(url) {
      try {
        const parsed = typeof url === "string" ? new URL(url) : url;
        return integrations.find((i) => getHost(i) === parsed.host);
      } catch {
        return void 0;
      }
    },
    byHost(host) {
      return integrations.find((i) => getHost(i) === host);
    }
  };
}
function defaultScmResolveUrl(options) {
  const {url, base, lineNumber} = options;
  try {
    new URL(url);
    return url;
  } catch {
  }
  let updated;
  if (url.startsWith("/")) {
    const {filepath} = parseGitUrl(base);
    updated = new URL(base);
    const repoRootPath = updated.pathname.substring(0, updated.pathname.length - filepath.length).replace(/\/+$/, "");
    updated.pathname = `${repoRootPath}${url}`;
  } else {
    updated = new URL(url, base);
  }
  updated.search = new URL(base).search;
  if (lineNumber) {
    updated.hash = `L${lineNumber}`;
  }
  return updated.toString();
}

const AZURE_HOST = "dev.azure.com";
function readAzureIntegrationConfig(config) {
  var _a;
  const host = (_a = config.getOptionalString("host")) != null ? _a : AZURE_HOST;
  const token = config.getOptionalString("token");
  if (!isValidHost(host)) {
    throw new Error(`Invalid Azure integration config, '${host}' is not a valid host`);
  }
  return {host, token};
}
function readAzureIntegrationConfigs(configs) {
  const result = configs.map(readAzureIntegrationConfig);
  if (!result.some((c) => c.host === AZURE_HOST)) {
    result.push({host: AZURE_HOST});
  }
  return result;
}

const _AzureIntegration = class {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  get type() {
    return "azure";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    const {url, base} = options;
    if (isValidUrl(url)) {
      return url;
    }
    const parsed = parseGitUrl(base);
    const {organization, owner, name, filepath} = parsed;
    if (!organization || !owner || !name) {
      return new URL(url, base).toString();
    }
    const path = (filepath == null ? void 0 : filepath.replace(/^\//, "")) || "";
    const mockBaseUrl = new URL(`https://a.com/${path}`);
    const updatedPath = new URL(url, mockBaseUrl).pathname;
    const newUrl = new URL(base);
    newUrl.searchParams.set("path", updatedPath);
    if (options.lineNumber) {
      newUrl.searchParams.set("line", String(options.lineNumber));
      newUrl.searchParams.set("lineEnd", String(options.lineNumber + 1));
      newUrl.searchParams.set("lineStartColumn", "1");
      newUrl.searchParams.set("lineEndColumn", "1");
    }
    return newUrl.toString();
  }
  resolveEditUrl(url) {
    return url;
  }
};
let AzureIntegration = _AzureIntegration;
AzureIntegration.factory = ({config}) => {
  var _a;
  const configs = readAzureIntegrationConfigs((_a = config.getOptionalConfigArray("integrations.azure")) != null ? _a : []);
  return basicIntegrations(configs.map((c) => new _AzureIntegration(c)), (i) => i.config.host);
};

function getAzureFileFetchUrl(url) {
  var _a;
  try {
    const parsedUrl = new URL(url);
    const [empty, userOrOrg, project, srcKeyword, repoName] = parsedUrl.pathname.split("/");
    const path = parsedUrl.searchParams.get("path") || "";
    const ref = (_a = parsedUrl.searchParams.get("version")) == null ? void 0 : _a.substr(2);
    if (empty !== "" || userOrOrg === "" || project === "" || srcKeyword !== "_git" || repoName === "" || path === "" || ref === "") {
      throw new Error("Wrong Azure Devops URL or Invalid file path");
    }
    parsedUrl.pathname = [
      empty,
      userOrOrg,
      project,
      "_apis",
      "git",
      "repositories",
      repoName,
      "items"
    ].join("/");
    const queryParams = [`path=${path}`];
    if (ref) {
      queryParams.push(`version=${ref}`);
    }
    parsedUrl.search = queryParams.join("&");
    parsedUrl.protocol = "https";
    return parsedUrl.toString();
  } catch (e) {
    throw new Error(`Incorrect URL: ${url}, ${e}`);
  }
}
function getAzureDownloadUrl(url) {
  const {
    name: repoName,
    owner: project,
    organization,
    protocol,
    resource,
    filepath
  } = parseGitUrl(url);
  const scopePath = filepath ? `&scopePath=${encodeURIComponent(filepath)}` : "";
  return `${protocol}://${resource}/${organization}/${project}/_apis/git/repositories/${repoName}/items?recursionLevel=full&download=true&api-version=6.0${scopePath}`;
}
function getAzureCommitsUrl(url) {
  var _a;
  try {
    const parsedUrl = new URL(url);
    const [empty, userOrOrg, project, srcKeyword, repoName] = parsedUrl.pathname.split("/");
    const ref = (_a = parsedUrl.searchParams.get("version")) == null ? void 0 : _a.substr(2);
    if (!!empty || !userOrOrg || !project || srcKeyword !== "_git" || !repoName) {
      throw new Error("Wrong Azure Devops URL");
    }
    parsedUrl.pathname = [
      empty,
      userOrOrg,
      project,
      "_apis",
      "git",
      "repositories",
      repoName,
      "commits"
    ].join("/");
    const queryParams = [];
    if (ref) {
      queryParams.push(`searchCriteria.itemVersion.version=${ref}`);
    }
    parsedUrl.search = queryParams.join("&");
    parsedUrl.protocol = "https";
    return parsedUrl.toString();
  } catch (e) {
    throw new Error(`Incorrect URL: ${url}, ${e}`);
  }
}
function getAzureRequestOptions(config, additionalHeaders) {
  const headers = additionalHeaders ? {...additionalHeaders} : {};
  if (config.token) {
    const buffer = Buffer.from(`:${config.token}`, "utf8");
    headers.Authorization = `Basic ${buffer.toString("base64")}`;
  }
  return {headers};
}

const BITBUCKET_HOST = "bitbucket.org";
const BITBUCKET_API_BASE_URL = "https://api.bitbucket.org/2.0";
function readBitbucketIntegrationConfig(config) {
  var _a;
  const host = (_a = config.getOptionalString("host")) != null ? _a : BITBUCKET_HOST;
  let apiBaseUrl = config.getOptionalString("apiBaseUrl");
  const token = config.getOptionalString("token");
  const username = config.getOptionalString("username");
  const appPassword = config.getOptionalString("appPassword");
  if (!isValidHost(host)) {
    throw new Error(`Invalid Bitbucket integration config, '${host}' is not a valid host`);
  }
  if (apiBaseUrl) {
    apiBaseUrl = apiBaseUrl.replace(/\/+$/, "");
  } else if (host === BITBUCKET_HOST) {
    apiBaseUrl = BITBUCKET_API_BASE_URL;
  }
  return {
    host,
    apiBaseUrl,
    token,
    username,
    appPassword
  };
}
function readBitbucketIntegrationConfigs(configs) {
  const result = configs.map(readBitbucketIntegrationConfig);
  if (!result.some((c) => c.host === BITBUCKET_HOST)) {
    result.push({
      host: BITBUCKET_HOST,
      apiBaseUrl: BITBUCKET_API_BASE_URL
    });
  }
  return result;
}

const _BitbucketIntegration = class {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  get type() {
    return "bitbucket";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    const resolved = defaultScmResolveUrl(options);
    if (options.lineNumber) {
      const url = new URL(resolved);
      const filename = url.pathname.split("/").slice(-1)[0];
      url.hash = `${filename}-${options.lineNumber}`;
      return url.toString();
    }
    return resolved;
  }
  resolveEditUrl(url) {
    const urlData = parseGitUrl(url);
    const editUrl = new URL(url);
    editUrl.searchParams.set("mode", "edit");
    editUrl.searchParams.set("spa", "0");
    editUrl.searchParams.set("at", urlData.ref);
    return editUrl.toString();
  }
};
let BitbucketIntegration = _BitbucketIntegration;
BitbucketIntegration.factory = ({
  config
}) => {
  var _a;
  const configs = readBitbucketIntegrationConfigs((_a = config.getOptionalConfigArray("integrations.bitbucket")) != null ? _a : []);
  return basicIntegrations(configs.map((c) => new _BitbucketIntegration(c)), (i) => i.config.host);
};

async function getBitbucketDefaultBranch(url, config) {
  const {name: repoName, owner: project, resource} = parseGitUrl(url);
  const isHosted = resource === "bitbucket.org";
  let branchUrl = isHosted ? `${config.apiBaseUrl}/repositories/${project}/${repoName}` : `${config.apiBaseUrl}/projects/${project}/repos/${repoName}/default-branch`;
  let response = await fetch(branchUrl, getBitbucketRequestOptions(config));
  if (response.status === 404 && !isHosted) {
    branchUrl = `${config.apiBaseUrl}/projects/${project}/repos/${repoName}/branches/default`;
    response = await fetch(branchUrl, getBitbucketRequestOptions(config));
  }
  if (!response.ok) {
    const message = `Failed to retrieve default branch from ${branchUrl}, ${response.status} ${response.statusText}`;
    throw new Error(message);
  }
  let defaultBranch;
  if (isHosted) {
    const repoInfo = await response.json();
    defaultBranch = repoInfo.mainbranch.name;
  } else {
    const {displayId} = await response.json();
    defaultBranch = displayId;
  }
  if (!defaultBranch) {
    throw new Error(`Failed to read default branch from ${branchUrl}. Response ${response.status} ${response.json()}`);
  }
  return defaultBranch;
}
async function getBitbucketDownloadUrl(url, config) {
  const {
    name: repoName,
    owner: project,
    ref,
    protocol,
    resource,
    filepath
  } = parseGitUrl(url);
  const isHosted = resource === "bitbucket.org";
  let branch = ref;
  if (!branch) {
    branch = await getBitbucketDefaultBranch(url, config);
  }
  const path = filepath ? `&path=${encodeURIComponent(filepath)}` : "";
  const archiveUrl = isHosted ? `${protocol}://${resource}/${project}/${repoName}/get/${branch}.tar.gz` : `${config.apiBaseUrl}/projects/${project}/repos/${repoName}/archive?format=tgz&at=${branch}&prefix=${project}-${repoName}${path}`;
  return archiveUrl;
}
function getBitbucketFileFetchUrl(url, config) {
  try {
    const {owner, name, ref, filepathtype, filepath} = parseGitUrl(url);
    if (!owner || !name || filepathtype !== "browse" && filepathtype !== "raw" && filepathtype !== "src") {
      throw new Error("Invalid Bitbucket URL or file path");
    }
    const pathWithoutSlash = filepath.replace(/^\//, "");
    if (config.host === "bitbucket.org") {
      if (!ref) {
        throw new Error("Invalid Bitbucket URL or file path");
      }
      return `${config.apiBaseUrl}/repositories/${owner}/${name}/src/${ref}/${pathWithoutSlash}`;
    }
    return `${config.apiBaseUrl}/projects/${owner}/repos/${name}/raw/${pathWithoutSlash}?at=${ref}`;
  } catch (e) {
    throw new Error(`Incorrect URL: ${url}, ${e}`);
  }
}
function getBitbucketRequestOptions(config) {
  const headers = {};
  if (config.token) {
    headers.Authorization = `Bearer ${config.token}`;
  } else if (config.username && config.appPassword) {
    const buffer = Buffer.from(`${config.username}:${config.appPassword}`, "utf8");
    headers.Authorization = `Basic ${buffer.toString("base64")}`;
  }
  return {
    headers
  };
}

const GITHUB_HOST = "github.com";
const GITHUB_API_BASE_URL = "https://api.github.com";
const GITHUB_RAW_BASE_URL = "https://raw.githubusercontent.com";
function readGitHubIntegrationConfig(config) {
  var _a, _b;
  const host = (_a = config.getOptionalString("host")) != null ? _a : GITHUB_HOST;
  let apiBaseUrl = config.getOptionalString("apiBaseUrl");
  let rawBaseUrl = config.getOptionalString("rawBaseUrl");
  const token = config.getOptionalString("token");
  const apps = (_b = config.getOptionalConfigArray("apps")) == null ? void 0 : _b.map((c) => ({
    appId: c.getNumber("appId"),
    clientId: c.getString("clientId"),
    clientSecret: c.getString("clientSecret"),
    webhookSecret: c.getString("webhookSecret"),
    privateKey: c.getString("privateKey"),
    allowedInstallationOwners: c.getOptionalStringArray("allowedInstallationOwners")
  }));
  if (!isValidHost(host)) {
    throw new Error(`Invalid GitHub integration config, '${host}' is not a valid host`);
  }
  if (apiBaseUrl) {
    apiBaseUrl = apiBaseUrl.replace(/\/+$/, "");
  } else if (host === GITHUB_HOST) {
    apiBaseUrl = GITHUB_API_BASE_URL;
  }
  if (rawBaseUrl) {
    rawBaseUrl = rawBaseUrl.replace(/\/+$/, "");
  } else if (host === GITHUB_HOST) {
    rawBaseUrl = GITHUB_RAW_BASE_URL;
  }
  return {host, apiBaseUrl, rawBaseUrl, token, apps};
}
function readGitHubIntegrationConfigs(configs) {
  const result = configs.map(readGitHubIntegrationConfig);
  if (!result.some((c) => c.host === GITHUB_HOST)) {
    result.push({
      host: GITHUB_HOST,
      apiBaseUrl: GITHUB_API_BASE_URL,
      rawBaseUrl: GITHUB_RAW_BASE_URL
    });
  }
  return result;
}

function getGitHubFileFetchUrl(url, config, credentials) {
  try {
    const {owner, name, ref, filepathtype, filepath} = parseGitUrl(url);
    if (!owner || !name || !ref || filepathtype !== "blob" && filepathtype !== "raw" && filepathtype !== "tree") {
      throw new Error("Invalid GitHub URL or file path");
    }
    const pathWithoutSlash = filepath.replace(/^\//, "");
    if (chooseEndpoint(config, credentials) === "api") {
      return `${config.apiBaseUrl}/repos/${owner}/${name}/contents/${pathWithoutSlash}?ref=${ref}`;
    }
    return `${config.rawBaseUrl}/${owner}/${name}/${ref}/${pathWithoutSlash}`;
  } catch (e) {
    throw new Error(`Incorrect URL: ${url}, ${e}`);
  }
}
function getGitHubRequestOptions(config, credentials) {
  const headers = {};
  if (chooseEndpoint(config, credentials) === "api") {
    headers.Accept = "application/vnd.github.v3.raw";
  }
  if (credentials.token) {
    headers.Authorization = `token ${credentials.token}`;
  }
  return {headers};
}
function chooseEndpoint(config, credentials) {
  if (config.apiBaseUrl && (credentials.token || !config.rawBaseUrl)) {
    return "api";
  }
  return "raw";
}

class Cache {
  constructor() {
    this.tokenCache = new Map();
    this.isNotExpired = (date) => date.diff(DateTime.local(), "minutes").minutes > 50;
  }
  async getOrCreateToken(key, supplier) {
    const item = this.tokenCache.get(key);
    if (item && this.isNotExpired(item.expiresAt)) {
      return {accessToken: item.token};
    }
    const result = await supplier();
    this.tokenCache.set(key, result);
    return {accessToken: result.token};
  }
}
const HEADERS = {
  Accept: "application/vnd.github.machine-man-preview+json"
};
class GithubAppManager {
  constructor(config, baseUrl) {
    this.cache = new Cache();
    this.allowedInstallationOwners = config.allowedInstallationOwners;
    this.baseAuthConfig = {
      appId: config.appId,
      privateKey: config.privateKey
    };
    this.appClient = new Octokit({
      baseUrl,
      headers: HEADERS,
      authStrategy: createAppAuth,
      auth: this.baseAuthConfig
    });
  }
  async getInstallationCredentials(owner, repo) {
    var _a;
    const {installationId, suspended} = await this.getInstallationData(owner);
    if (this.allowedInstallationOwners) {
      if (!((_a = this.allowedInstallationOwners) == null ? void 0 : _a.includes(owner))) {
        throw new Error(`The GitHub application for ${owner} is not included in the allowed installation list (${installationId}).`);
      }
    }
    if (suspended) {
      throw new Error(`The GitHub application for ${owner} is suspended`);
    }
    const cacheKey = repo ? `${owner}/${repo}` : owner;
    return this.cache.getOrCreateToken(cacheKey, async () => {
      const result = await this.appClient.apps.createInstallationAccessToken({
        installation_id: installationId,
        headers: HEADERS
      });
      if (repo && result.data.repository_selection === "selected") {
        const installationClient = new Octokit({
          auth: result.data.token
        });
        const repos = await installationClient.apps.listReposAccessibleToInstallation();
        const hasRepo = repos.data.repositories.some((repository) => {
          return repository.name === repo;
        });
        if (!hasRepo) {
          throw new Error(`The Backstage GitHub application used in the ${owner} organization does not have access to a repository with the name ${repo}`);
        }
      }
      return {
        token: result.data.token,
        expiresAt: DateTime.fromISO(result.data.expires_at)
      };
    });
  }
  getInstallations() {
    return this.appClient.paginate(this.appClient.apps.listInstallations);
  }
  async getInstallationData(owner) {
    const allInstallations = await this.getInstallations();
    const installation = allInstallations.find((inst) => {
      var _a, _b;
      return ((_b = (_a = inst.account) == null ? void 0 : _a.login) == null ? void 0 : _b.toLowerCase()) === owner.toLowerCase();
    });
    if (installation) {
      return {
        installationId: installation.id,
        suspended: Boolean(installation.suspended_by)
      };
    }
    const notFoundError = new Error(`No app installation found for ${owner} in ${this.baseAuthConfig.appId}`);
    notFoundError.name = "NotFoundError";
    throw notFoundError;
  }
}
class GithubAppCredentialsMux {
  constructor(config) {
    var _a, _b;
    this.apps = (_b = (_a = config.apps) == null ? void 0 : _a.map((ac) => new GithubAppManager(ac, config.apiBaseUrl))) != null ? _b : [];
  }
  async getAllInstallations() {
    if (!this.apps.length) {
      return [];
    }
    const installs = await Promise.all(this.apps.map((app) => app.getInstallations()));
    return installs.flat();
  }
  async getAppToken(owner, repo) {
    if (this.apps.length === 0) {
      return void 0;
    }
    const results = await Promise.all(this.apps.map((app) => app.getInstallationCredentials(owner, repo).then((credentials) => ({credentials, error: void 0}), (error) => ({credentials: void 0, error}))));
    const result = results.find((resultItem) => resultItem.credentials);
    if (result) {
      return result.credentials.accessToken;
    }
    const errors = results.map((r) => r.error);
    const notNotFoundError = errors.find((err) => err.name !== "NotFoundError");
    if (notNotFoundError) {
      throw notNotFoundError;
    }
    return void 0;
  }
}
class GithubCredentialsProvider {
  constructor(githubAppCredentialsMux, token) {
    this.githubAppCredentialsMux = githubAppCredentialsMux;
    this.token = token;
  }
  static create(config) {
    return new GithubCredentialsProvider(new GithubAppCredentialsMux(config), config.token);
  }
  async getCredentials(opts) {
    const parsed = parseGitUrl(opts.url);
    const owner = parsed.owner || parsed.name;
    const repo = parsed.owner ? parsed.name : void 0;
    let type = "app";
    let token = await this.githubAppCredentialsMux.getAppToken(owner, repo);
    if (!token) {
      type = "token";
      token = this.token;
    }
    return {
      headers: token ? {Authorization: `Bearer ${token}`} : void 0,
      token,
      type
    };
  }
}

const _GitHubIntegration = class {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  get type() {
    return "github";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    return replaceUrlType$1(defaultScmResolveUrl(options), "tree");
  }
  resolveEditUrl(url) {
    return replaceUrlType$1(url, "edit");
  }
};
let GitHubIntegration = _GitHubIntegration;
GitHubIntegration.factory = ({config}) => {
  var _a;
  const configs = readGitHubIntegrationConfigs((_a = config.getOptionalConfigArray("integrations.github")) != null ? _a : []);
  return basicIntegrations(configs.map((c) => new _GitHubIntegration(c)), (i) => i.config.host);
};
function replaceUrlType$1(url, type) {
  return url.replace(/\/\/([^/]+)\/([^/]+)\/([^/]+)\/(blob|tree|edit)\//, (_, host, owner, repo) => {
    return `//${host}/${owner}/${repo}/${type}/`;
  });
}

const GITLAB_HOST = "gitlab.com";
const GITLAB_API_BASE_URL = "https://gitlab.com/api/v4";
function readGitLabIntegrationConfig(config) {
  const host = config.getString("host");
  let apiBaseUrl = config.getOptionalString("apiBaseUrl");
  const token = config.getOptionalString("token");
  let baseUrl = config.getOptionalString("baseUrl");
  if (apiBaseUrl) {
    apiBaseUrl = apiBaseUrl.replace(/\/+$/, "");
  } else if (host === GITLAB_HOST) {
    apiBaseUrl = GITLAB_API_BASE_URL;
  }
  if (baseUrl) {
    baseUrl = baseUrl.replace(/\/+$/, "");
  } else {
    baseUrl = `https://${host}`;
  }
  if (host.includes(":")) {
    throw new Error(`Invalid GitLab integration config, host '${host}' should just be the host name (e.g. "github.com"), not a URL`);
  } else if (!isValidHost(host)) {
    throw new Error(`Invalid GitLab integration config, '${host}' is not a valid host`);
  } else if (!apiBaseUrl || !isValidUrl(apiBaseUrl)) {
    throw new Error(`Invalid GitLab integration config, '${apiBaseUrl}' is not a valid apiBaseUrl`);
  } else if (!isValidUrl(baseUrl)) {
    throw new Error(`Invalid GitLab integration config, '${baseUrl}' is not a valid baseUrl`);
  }
  return {host, token, apiBaseUrl, baseUrl};
}
function readGitLabIntegrationConfigs(configs) {
  const result = configs.map(readGitLabIntegrationConfig);
  if (!result.some((c) => c.host === GITLAB_HOST)) {
    result.push({
      host: GITLAB_HOST,
      apiBaseUrl: GITLAB_API_BASE_URL,
      baseUrl: `https://${GITLAB_HOST}`
    });
  }
  return result;
}

async function getGitLabFileFetchUrl(url, config) {
  if (url.includes("/-/blob/")) {
    const projectID = await getProjectId(url, config);
    return buildProjectUrl(url, projectID).toString();
  }
  return buildRawUrl(url).toString();
}
function getGitLabRequestOptions(config) {
  const {token = ""} = config;
  return {
    headers: {
      "PRIVATE-TOKEN": token
    }
  };
}
function buildRawUrl(target) {
  try {
    const url = new URL(target);
    const [empty, userOrOrg, repoName, blobKeyword, ...restOfPath] = url.pathname.split("/");
    if (empty !== "" || userOrOrg === "" || repoName === "" || blobKeyword !== "blob" || !restOfPath.join("/").match(/\.yaml$/)) {
      throw new Error("Wrong GitLab URL");
    }
    url.pathname = [empty, userOrOrg, repoName, "raw", ...restOfPath].join("/");
    return url;
  } catch (e) {
    throw new Error(`Incorrect url: ${target}, ${e}`);
  }
}
function buildProjectUrl(target, projectID) {
  try {
    const url = new URL(target);
    const branchAndFilePath = url.pathname.split("/-/blob/")[1];
    const [branch, ...filePath] = branchAndFilePath.split("/");
    url.pathname = [
      "/api/v4/projects",
      projectID,
      "repository/files",
      encodeURIComponent(decodeURIComponent(filePath.join("/"))),
      "raw"
    ].join("/");
    url.search = `?ref=${branch}`;
    return url;
  } catch (e) {
    throw new Error(`Incorrect url: ${target}, ${e}`);
  }
}
async function getProjectId(target, config) {
  const url = new URL(target);
  if (!url.pathname.includes("/-/blob/")) {
    throw new Error("Please provide full path to yaml file from GitLab");
  }
  try {
    const repo = url.pathname.split("/-/blob/")[0];
    const repoIDLookup = new URL(`${url.protocol + url.hostname}/api/v4/projects/${encodeURIComponent(repo.replace(/^\//, ""))}`);
    const response = await fetch(repoIDLookup.toString(), getGitLabRequestOptions(config));
    const data = await response.json();
    if (!response.ok) {
      throw new Error(`GitLab Error '${data.error}', ${data.error_description}`);
    }
    return Number(data.id);
  } catch (e) {
    throw new Error(`Could not get GitLab project ID for: ${target}, ${e}`);
  }
}

const _GitLabIntegration = class {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  get type() {
    return "gitlab";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    return defaultScmResolveUrl(options);
  }
  resolveEditUrl(url) {
    return replaceUrlType(url, "edit");
  }
};
let GitLabIntegration = _GitLabIntegration;
GitLabIntegration.factory = ({config}) => {
  var _a;
  const configs = readGitLabIntegrationConfigs((_a = config.getOptionalConfigArray("integrations.gitlab")) != null ? _a : []);
  return basicIntegrations(configs.map((c) => new _GitLabIntegration(c)), (i) => i.config.host);
};
function replaceUrlType(url, type) {
  return url.replace(/\/\-\/(blob|tree|edit)\//, `/-/${type}/`);
}

function readGoogleGcsIntegrationConfig(config) {
  if (!config) {
    return {};
  }
  if (!config.has("clientEmail") && !config.has("privateKey")) {
    return {};
  }
  const privateKey = config.getString("privateKey").split("\\n").join("\n");
  const clientEmail = config.getString("clientEmail");
  return {clientEmail, privateKey};
}

const AMAZON_AWS_HOST = "amazonaws.com";
function readAwsS3IntegrationConfig(config) {
  var _a;
  const host = (_a = config.getOptionalString("host")) != null ? _a : AMAZON_AWS_HOST;
  const accessKeyId = config.getOptionalString("accessKeyId");
  const secretAccessKey = config.getOptionalString("secretAccessKey");
  const roleArn = config.getOptionalString("roleArn");
  if (!isValidHost(host)) {
    throw new Error(`Invalid awsS3 integration config, '${host}' is not a valid host`);
  }
  return {host, accessKeyId, secretAccessKey, roleArn};
}
function readAwsS3IntegrationConfigs(configs) {
  const result = configs.map(readAwsS3IntegrationConfig);
  if (!result.some((c) => c.host === AMAZON_AWS_HOST)) {
    result.push({
      host: AMAZON_AWS_HOST
    });
  }
  return result;
}

const _AwsS3Integration = class {
  constructor(integrationConfig) {
    this.integrationConfig = integrationConfig;
  }
  get type() {
    return "awsS3";
  }
  get title() {
    return this.integrationConfig.host;
  }
  get config() {
    return this.integrationConfig;
  }
  resolveUrl(options) {
    const resolved = defaultScmResolveUrl(options);
    return resolved;
  }
  resolveEditUrl(url) {
    return url;
  }
};
let AwsS3Integration = _AwsS3Integration;
AwsS3Integration.factory = ({config}) => {
  var _a;
  const configs = readAwsS3IntegrationConfigs((_a = config.getOptionalConfigArray("integrations.awsS3")) != null ? _a : []);
  return basicIntegrations(configs.map((c) => new _AwsS3Integration(c)), (i) => i.config.host);
};

class ScmIntegrations {
  static fromConfig(config) {
    return new ScmIntegrations({
      awsS3: AwsS3Integration.factory({config}),
      azure: AzureIntegration.factory({config}),
      bitbucket: BitbucketIntegration.factory({config}),
      github: GitHubIntegration.factory({config}),
      gitlab: GitLabIntegration.factory({config})
    });
  }
  constructor(integrationsByType) {
    this.byType = integrationsByType;
  }
  get awsS3() {
    return this.byType.awsS3;
  }
  get azure() {
    return this.byType.azure;
  }
  get bitbucket() {
    return this.byType.bitbucket;
  }
  get github() {
    return this.byType.github;
  }
  get gitlab() {
    return this.byType.gitlab;
  }
  list() {
    return Object.values(this.byType).flatMap((i) => i.list());
  }
  byUrl(url) {
    return Object.values(this.byType).map((i) => i.byUrl(url)).find(Boolean);
  }
  byHost(host) {
    return Object.values(this.byType).map((i) => i.byHost(host)).find(Boolean);
  }
  resolveUrl(options) {
    const integration = this.byUrl(options.base);
    if (!integration) {
      return defaultScmResolveUrl(options);
    }
    return integration.resolveUrl(options);
  }
  resolveEditUrl(url) {
    const integration = this.byUrl(url);
    if (!integration) {
      return url;
    }
    return integration.resolveEditUrl(url);
  }
}

export { AwsS3Integration, AzureIntegration, BitbucketIntegration, GitHubIntegration, GitLabIntegration, GithubAppCredentialsMux, GithubCredentialsProvider, ScmIntegrations, defaultScmResolveUrl, getAzureCommitsUrl, getAzureDownloadUrl, getAzureFileFetchUrl, getAzureRequestOptions, getBitbucketDefaultBranch, getBitbucketDownloadUrl, getBitbucketFileFetchUrl, getBitbucketRequestOptions, getGitHubFileFetchUrl, getGitHubRequestOptions, getGitLabFileFetchUrl, getGitLabRequestOptions, readAwsS3IntegrationConfig, readAwsS3IntegrationConfigs, readAzureIntegrationConfig, readAzureIntegrationConfigs, readBitbucketIntegrationConfig, readBitbucketIntegrationConfigs, readGitHubIntegrationConfig, readGitHubIntegrationConfigs, readGitLabIntegrationConfig, readGitLabIntegrationConfigs, readGoogleGcsIntegrationConfig, replaceUrlType$1 as replaceGitHubUrlType };
//# sourceMappingURL=index.esm.js.map
