/// <reference types="react" />
import React$1, { ComponentType, ReactNode, ReactElement } from 'react';
import { BackstageTheme } from '@backstage/theme';
import { Config } from '@backstage/config';
import { SvgIconProps } from '@material-ui/core';

declare type ApiRef<T> = {
    id: string;
    T: T;
};
declare type AnyApiRef = ApiRef<unknown>;
declare type ApiRefType<T> = T extends ApiRef<infer U> ? U : never;
declare type TypesToApiRefs<T> = {
    [key in keyof T]: ApiRef<T[key]>;
};
declare type ApiRefsToTypes<T extends {
    [key in string]: ApiRef<unknown>;
}> = {
    [key in keyof T]: ApiRefType<T[key]>;
};
declare type ApiHolder = {
    get<T>(api: ApiRef<T>): T | undefined;
};
declare type ApiFactory<Api, Impl extends Api, Deps extends {
    [name in string]: unknown;
}> = {
    api: ApiRef<Api>;
    deps: TypesToApiRefs<Deps>;
    factory(deps: Deps): Impl;
};
declare type AnyApiFactory = ApiFactory<unknown, unknown, {
    [key in string]: unknown;
}>;

declare function useApiHolder(): ApiHolder;
declare function useApi<T>(apiRef: ApiRef<T>): T;
declare function withApis<T>(apis: TypesToApiRefs<T>): <P extends T>(WrappedComponent: React$1.ComponentType<P>) => {
    (props: React$1.PropsWithChildren<Omit<P, keyof T>>): JSX.Element;
    displayName: string;
};

declare type ApiRefConfig = {
    id: string;
    /**
     * @deprecated Will be removed in the future
     */
    description?: string;
};
declare function createApiRef<T>(config: ApiRefConfig): ApiRef<T>;

/**
 * Used to infer types for a standalone ApiFactory that isn't immediately passed
 * to another function.
 * This function doesn't actually do anything, it's only used to infer types.
 */
declare function createApiFactory<Api, Impl extends Api, Deps extends {
    [name in string]: unknown;
}>(factory: ApiFactory<Api, Impl, Deps>): ApiFactory<Api, Impl, Deps>;
declare function createApiFactory<Api, Impl extends Api>(api: ApiRef<Api>, instance: Impl): ApiFactory<Api, Impl, {}>;

/**
 * This file contains non-react related core types used throughout Backstage.
 */
/**
 * Observer interface for consuming an Observer, see TC39.
 */
declare type Observer<T> = {
    next?(value: T): void;
    error?(error: Error): void;
    complete?(): void;
};
/**
 * Subscription returned when subscribing to an Observable, see TC39.
 */
declare type Subscription = {
    /**
     * Cancels the subscription
     */
    unsubscribe(): void;
    /**
     * Value indicating whether the subscription is closed.
     */
    readonly closed: boolean;
};
declare global {
    interface SymbolConstructor {
        readonly observable: symbol;
    }
}
/**
 * Observable sequence of values and errors, see TC39.
 *
 * https://github.com/tc39/proposal-observable
 *
 * This is used as a common return type for observable values and can be created
 * using many different observable implementations, such as zen-observable or RxJS 5.
 */
declare type Observable<T> = {
    [Symbol.observable](): Observable<T>;
    /**
     * Subscribes to this observable to start receiving new values.
     */
    subscribe(observer: Observer<T>): Subscription;
    subscribe(onNext?: (value: T) => void, onError?: (error: Error) => void, onComplete?: () => void): Subscription;
};

/**
 * This file contains declarations for common interfaces of auth-related APIs.
 * The declarations should be used to signal which type of authentication and
 * authorization methods each separate auth provider supports.
 *
 * For example, a Google OAuth provider that supports OAuth 2 and OpenID Connect,
 * would be declared as follows:
 *
 * const googleAuthApiRef = createApiRef<OAuthApi & OpenIDConnectApi>({ ... })
 */
/**
 * An array of scopes, or a scope string formatted according to the
 * auth provider, which is typically a space separated list.
 *
 * See the documentation for each auth provider for the list of scopes
 * supported by each provider.
 */
declare type OAuthScope = string | string[];
declare type AuthRequestOptions = {
    /**
     * If this is set to true, the user will not be prompted to log in,
     * and an empty response will be returned if there is no existing session.
     *
     * This can be used to perform a check whether the user is logged in, or if you don't
     * want to force a user to be logged in, but provide functionality if they already are.
     *
     * @default false
     */
    optional?: boolean;
    /**
     * If this is set to true, the request will bypass the regular oauth login modal
     * and open the login popup directly.
     *
     * The method must be called synchronously from a user action for this to work in all browsers.
     *
     * @default false
     */
    instantPopup?: boolean;
};
/**
 * This API provides access to OAuth 2 credentials. It lets you request access tokens,
 * which can be used to act on behalf of the user when talking to APIs.
 */
declare type OAuthApi = {
    /**
     * Requests an OAuth 2 Access Token, optionally with a set of scopes. The access token allows
     * you to make requests on behalf of the user, and the copes may grant you broader access, depending
     * on the auth provider.
     *
     * Each auth provider has separate handling of scope, so you need to look at the documentation
     * for each one to know what scope you need to request.
     *
     * This method is cheap and should be called each time an access token is used. Do not for example
     * store the access token in React component state, as that could cause the token to expire. Instead
     * fetch a new access token for each request.
     *
     * Be sure to include all required scopes when requesting an access token. When testing your implementation
     * it is best to log out the Backstage session and then visit your plugin page directly, as
     * you might already have some required scopes in your existing session. Not requesting the correct
     * scopes can lead to 403 or other authorization errors, which can be tricky to debug.
     *
     * If the user has not yet granted access to the provider and the set of requested scopes, the user
     * will be prompted to log in. The returned promise will not resolve until the user has
     * successfully logged in. The returned promise can be rejected, but only if the user rejects the login request.
     */
    getAccessToken(scope?: OAuthScope, options?: AuthRequestOptions): Promise<string>;
};
/**
 * This API provides access to OpenID Connect credentials. It lets you request ID tokens,
 * which can be passed to backend services to prove the user's identity.
 */
declare type OpenIdConnectApi = {
    /**
     * Requests an OpenID Connect ID Token.
     *
     * This method is cheap and should be called each time an ID token is used. Do not for example
     * store the id token in React component state, as that could cause the token to expire. Instead
     * fetch a new id token for each request.
     *
     * If the user has not yet logged in to Google inside Backstage, the user will be prompted
     * to log in. The returned promise will not resolve until the user has successfully logged in.
     * The returned promise can be rejected, but only if the user rejects the login request.
     */
    getIdToken(options?: AuthRequestOptions): Promise<string>;
};
/**
 * This API provides access to profile information of the user from an auth provider.
 */
declare type ProfileInfoApi = {
    /**
     * Get profile information for the user as supplied by this auth provider.
     *
     * If the optional flag is not set, a session is guaranteed to be returned, while if
     * the optional flag is set, the session may be undefined. See @AuthRequestOptions for more details.
     */
    getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
};
/**
 * This API provides access to the user's identity within Backstage.
 *
 * An auth provider that implements this interface can be used to sign-in to backstage. It is
 * not intended to be used directly from a plugin, but instead serves as a connection between
 * this authentication method and the app's @IdentityApi
 */
declare type BackstageIdentityApi = {
    /**
     * Get the user's identity within Backstage. This should normally not be called directly,
     * use the @IdentityApi instead.
     *
     * If the optional flag is not set, a session is guaranteed to be returned, while if
     * the optional flag is set, the session may be undefined. See @AuthRequestOptions for more details.
     */
    getBackstageIdentity(options?: AuthRequestOptions): Promise<BackstageIdentity | undefined>;
};
declare type BackstageIdentity = {
    /**
     * The backstage user ID.
     */
    id: string;
    /**
     * @deprecated This is deprecated, use `token` instead.
     */
    idToken: string;
    /**
     * The token used to authenticate the user within Backstage.
     */
    token: string;
};
/**
 * Profile information of the user.
 */
declare type ProfileInfo = {
    /**
     * Email ID.
     */
    email?: string;
    /**
     * Display name that can be presented to the user.
     */
    displayName?: string;
    /**
     * URL to an avatar image of the user.
     */
    picture?: string;
};
/**
 * Session state values passed to subscribers of the SessionApi.
 */
declare enum SessionState {
    SignedIn = "SignedIn",
    SignedOut = "SignedOut"
}
/**
 * The SessionApi provides basic controls for any auth provider that is tied to a persistent session.
 */
declare type SessionApi = {
    /**
     * Sign in with a minimum set of permissions.
     */
    signIn(): Promise<void>;
    /**
     * Sign out from the current session. This will reload the page.
     */
    signOut(): Promise<void>;
    /**
     * Observe the current state of the auth session. Emits the current state on subscription.
     */
    sessionState$(): Observable<SessionState>;
};
/**
 * Provides authentication towards Google APIs and identities.
 *
 * See https://developers.google.com/identity/protocols/googlescopes for a full list of supported scopes.
 *
 * Note that the ID token payload is only guaranteed to contain the user's numerical Google ID,
 * email and expiration information. Do not rely on any other fields, as they might not be present.
 */
declare const googleAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication towards GitHub APIs.
 *
 * See https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/
 * for a full list of supported scopes.
 */
declare const githubAuthApiRef: ApiRef<OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication towards Okta APIs.
 *
 * See https://developer.okta.com/docs/guides/implement-oauth-for-okta/scopes/
 * for a full list of supported scopes.
 */
declare const oktaAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication towards GitLab APIs.
 *
 * See https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html#limiting-scopes-of-a-personal-access-token
 * for a full list of supported scopes.
 */
declare const gitlabAuthApiRef: ApiRef<OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication towards Auth0 APIs.
 *
 * See https://auth0.com/docs/scopes/current/oidc-scopes
 * for a full list of supported scopes.
 */
declare const auth0AuthApiRef: ApiRef<OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication towards Microsoft APIs and identities.
 *
 * For more info and a full list of supported scopes, see:
 * - https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent
 * - https://docs.microsoft.com/en-us/graph/permissions-reference
 */
declare const microsoftAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication for custom identity providers.
 */
declare const oauth2ApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication for custom OpenID Connect identity providers.
 */
declare const oidcAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;
/**
 * Provides authentication for saml based identity providers
 */
declare const samlAuthApiRef: ApiRef<ProfileInfoApi & BackstageIdentityApi & SessionApi>;
declare const oneloginAuthApiRef: ApiRef<OAuthApi & OpenIdConnectApi & ProfileInfoApi & BackstageIdentityApi & SessionApi>;

declare type AlertMessage = {
    message: string;
    severity?: 'success' | 'info' | 'warning' | 'error';
};
/**
 * The alert API is used to report alerts to the app, and display them to the user.
 */
declare type AlertApi = {
    /**
     * Post an alert for handling by the application.
     */
    post(alert: AlertMessage): void;
    /**
     * Observe alerts posted by other parts of the application.
     */
    alert$(): Observable<AlertMessage>;
};
declare const alertApiRef: ApiRef<AlertApi>;

/**
 * Describes a theme provided by the app.
 */
declare type AppTheme = {
    /**
     * ID used to remember theme selections.
     */
    id: string;
    /**
     * Title of the theme
     */
    title: string;
    /**
     * Theme variant
     */
    variant: 'light' | 'dark';
    /**
     * The specialized MaterialUI theme instance.
     */
    theme: BackstageTheme;
    /**
     * An Icon for the theme mode setting.
     */
    icon?: React.ReactElement;
};
/**
 * The AppThemeApi gives access to the current app theme, and allows switching
 * to other options that have been registered as a part of the App.
 */
declare type AppThemeApi = {
    /**
     * Get a list of available themes.
     */
    getInstalledThemes(): AppTheme[];
    /**
     * Observe the currently selected theme. A value of undefined means no specific theme has been selected.
     */
    activeThemeId$(): Observable<string | undefined>;
    /**
     * Get the current theme ID. Returns undefined if no specific theme is selected.
     */
    getActiveThemeId(): string | undefined;
    /**
     * Set a specific theme to use in the app, overriding the default theme selection.
     *
     * Clear the selection by passing in undefined.
     */
    setActiveThemeId(themeId?: string): void;
};
declare const appThemeApiRef: ApiRef<AppThemeApi>;

/**
 * The Config API is used to provide a mechanism to access the
 * runtime configuration of the system.
 */
declare type ConfigApi = Config;
declare const configApiRef: ApiRef<ConfigApi>;

/**
 * The discovery API is used to provide a mechanism for plugins to
 * discover the endpoint to use to talk to their backend counterpart.
 *
 * The purpose of the discovery API is to allow for many different deployment
 * setups and routing methods through a central configuration, instead
 * of letting each individual plugin manage that configuration.
 *
 * Implementations of the discovery API can be a simple as a URL pattern
 * using the pluginId, but could also have overrides for individual plugins,
 * or query a separate discovery service.
 */
declare type DiscoveryApi = {
    /**
     * Returns the HTTP base backend URL for a given plugin, without a trailing slash.
     *
     * This method must always be called just before making a request, as opposed to
     * fetching the URL when constructing an API client. That is to ensure that more
     * flexible routing patterns can be supported.
     *
     * For example, asking for the URL for `auth` may return something
     * like `https://backstage.example.com/api/auth`
     */
    getBaseUrl(pluginId: string): Promise<string>;
};
declare const discoveryApiRef: ApiRef<DiscoveryApi>;

/**
 * Mirrors the JavaScript Error class, for the purpose of
 * providing documentation and optional fields.
 */
declare type Error$1 = {
    name: string;
    message: string;
    stack?: string;
};
/**
 * Provides additional information about an error that was posted to the application.
 */
declare type ErrorContext = {
    hidden?: boolean;
};
/**
 * The error API is used to report errors to the app, and display them to the user.
 *
 * Plugins can use this API as a method of displaying errors to the user, but also
 * to report errors for collection by error reporting services.
 *
 * If an error can be displayed inline, e.g. as feedback in a form, that should be
 * preferred over relying on this API to display the error. The main use of this API
 * for displaying errors should be for asynchronous errors, such as a failing background process.
 *
 * Even if an error is displayed inline, it should still be reported through this API
 * if it would be useful to collect or log it for debugging purposes, but with
 * the hidden flag set. For example, an error arising from form field validation
 * should probably not be reported, while a failed REST call would be useful to report.
 */
declare type ErrorApi = {
    /**
     * Post an error for handling by the application.
     */
    post(error: Error$1, context?: ErrorContext): void;
    /**
     * Observe errors posted by other parts of the application.
     */
    error$(): Observable<{
        error: Error$1;
        context?: ErrorContext;
    }>;
};
declare const errorApiRef: ApiRef<ErrorApi>;

/**
 * The feature flags API is used to toggle functionality to users across plugins and Backstage.
 *
 * Plugins can use this API to register feature flags that they have available
 * for users to enable/disable, and this API will centralize the current user's
 * state of which feature flags they would like to enable.
 *
 * This is ideal for Backstage plugins, as well as your own App, to trial incomplete
 * or unstable upcoming features. Although there will be a common interface for users
 * to enable and disable feature flags, this API acts as another way to enable/disable.
 */
declare type FeatureFlag = {
    name: string;
    pluginId: string;
};
declare enum FeatureFlagState {
    None = 0,
    Active = 1
}
/**
 * Options to use when saving feature flags.
 */
declare type FeatureFlagsSaveOptions = {
    /**
     * The new feature flag states to save.
     */
    states: Record<string, FeatureFlagState>;
    /**
     * Whether the saves states should be merged into the existing ones, or replace them.
     *
     * Defaults to false.
     */
    merge?: boolean;
};
declare type UserFlags = {};
interface FeatureFlagsApi {
    /**
     * Registers a new feature flag. Once a feature flag has been registered it
     * can be toggled by users, and read back to enable or disable features.
     */
    registerFlag(flag: FeatureFlag): void;
    /**
     * Get a list of all registered flags.
     */
    getRegisteredFlags(): FeatureFlag[];
    /**
     * Whether the feature flag with the given name is currently activated for the user.
     */
    isActive(name: string): boolean;
    /**
     * Save the user's choice of feature flag states.
     */
    save(options: FeatureFlagsSaveOptions): void;
}
declare const featureFlagsApiRef: ApiRef<FeatureFlagsApi>;

/**
 * The Identity API used to identify and get information about the signed in user.
 */
declare type IdentityApi = {
    /**
     * The ID of the signed in user. This ID is not meant to be presented to the user, but used
     * as an opaque string to pass on to backends or use in frontend logic.
     *
     * TODO: The intention of the user ID is to be able to tie the user to an identity
     *       that is known by the catalog and/or identity backend. It should for example
     *       be possible to fetch all owned components using this ID.
     */
    getUserId(): string;
    /**
     * The profile of the signed in user.
     */
    getProfile(): ProfileInfo;
    /**
     * An OpenID Connect ID Token which proves the identity of the signed in user.
     *
     * The ID token will be undefined if the signed in user does not have a verified
     * identity, such as a demo user or mocked user for e2e tests.
     */
    getIdToken(): Promise<string | undefined>;
    /**
     * Sign out the current user
     */
    signOut(): Promise<void>;
};
declare const identityApiRef: ApiRef<IdentityApi>;

/**
 * IconComponent is the common icon type used throughout Backstage when
 * working with and rendering generic icons, including the app system icons.
 *
 * The type is based on SvgIcon from MUI, but both do not what the plugin-api
 * package to have a dependency on MUI, nor do we want the props to be as broad
 * as the SvgIconProps interface.
 *
 * If you have the need to forward additional props from SvgIconProps, you can
 * open an issue or submit a PR to the main Backstage repo. When doing so please
 * also describe your use-case and reasoning of the addition.
 */
declare type IconComponent = ComponentType<{
    fontSize?: 'default' | 'small' | 'large';
}>;
/**
 * This exists for backwards compatibility with the old core package.
 * It's used in some parts of this package in order to smooth out the
 * migration, but it is not exported.
 */
declare type OldIconComponent = ComponentType<SvgIconProps>;

/**
 * Information about the auth provider that we're requesting a login towards.
 *
 * This should be shown to the user so that they can be informed about what login is being requested
 * before a popup is shown.
 */
declare type AuthProvider = {
    /**
     * Title for the auth provider, for example "GitHub"
     */
    title: string;
    /**
     * Icon for the auth provider.
     */
    icon: IconComponent;
};
/**
 * Describes how to handle auth requests. Both how to show them to the user, and what to do when
 * the user accesses the auth request.
 */
declare type AuthRequesterOptions<AuthResponse> = {
    /**
     * Information about the auth provider, which will be forwarded to auth requests.
     */
    provider: AuthProvider;
    /**
     * Implementation of the auth flow, which will be called synchronously when
     * trigger() is called on an auth requests.
     */
    onAuthRequest(scopes: Set<string>): Promise<AuthResponse>;
};
/**
 * Function used to trigger new auth requests for a set of scopes.
 *
 * The returned promise will resolve to the same value returned by the onAuthRequest in the
 * AuthRequesterOptions. Or rejected, if the request is rejected.
 *
 * This function can be called multiple times before the promise resolves. All calls
 * will be merged into one request, and the scopes forwarded to the onAuthRequest will be the
 * union of all requested scopes.
 */
declare type AuthRequester<AuthResponse> = (scopes: Set<string>) => Promise<AuthResponse>;
/**
 * An pending auth request for a single auth provider. The request will remain in this pending
 * state until either reject() or trigger() is called.
 *
 * Any new requests for the same provider are merged into the existing pending request, meaning
 * there will only ever be a single pending request for a given provider.
 */
declare type PendingAuthRequest = {
    /**
     * Information about the auth provider, as given in the AuthRequesterOptions
     */
    provider: AuthProvider;
    /**
     * Rejects the request, causing all pending AuthRequester calls to fail with "RejectedError".
     */
    reject: () => void;
    /**
     * Trigger the auth request to continue the auth flow, by for example showing a popup.
     *
     * Synchronously calls onAuthRequest with all scope currently in the request.
     */
    trigger(): Promise<void>;
};
/**
 * Provides helpers for implemented OAuth login flows within Backstage.
 */
declare type OAuthRequestApi = {
    /**
     * A utility for showing login popups or similar things, and merging together multiple requests for
     * different scopes into one request that includes all scopes.
     *
     * The passed in options provide information about the login provider, and how to handle auth requests.
     *
     * The returned AuthRequester function is used to request login with new scopes. These requests
     * are merged together and forwarded to the auth handler, as soon as a consumer of auth requests
     * triggers an auth flow.
     *
     * See AuthRequesterOptions, AuthRequester, and handleAuthRequests for more info.
     */
    createAuthRequester<AuthResponse>(options: AuthRequesterOptions<AuthResponse>): AuthRequester<AuthResponse>;
    /**
     * Observers pending auth requests. The returned observable will emit all
     * current active auth request, at most one for each created auth requester.
     *
     * Each request has its own info about the login provider, forwarded from the auth requester options.
     *
     * Depending on user interaction, the request should either be rejected, or used to trigger the auth handler.
     * If the request is rejected, all pending AuthRequester calls will fail with a "RejectedError".
     * If a auth is triggered, and the auth handler resolves successfully, then all currently pending
     * AuthRequester calls will resolve to the value returned by the onAuthRequest call.
     */
    authRequest$(): Observable<PendingAuthRequest[]>;
};
declare const oauthRequestApiRef: ApiRef<OAuthRequestApi>;

declare type StorageValueChange<T = any> = {
    key: string;
    newValue?: T;
};
interface StorageApi {
    /**
     * Create a bucket to store data in.
     * @param {String} name Namespace for the storage to be stored under,
     *                      will inherit previous namespaces too
     */
    forBucket(name: string): StorageApi;
    /**
     * Get the current value for persistent data, use observe$ to be notified of updates.
     *
     * @param {String} key Unique key associated with the data.
     * @return {Object} data The data that should is stored.
     */
    get<T>(key: string): T | undefined;
    /**
     * Remove persistent data.
     *
     * @param {String} key Unique key associated with the data.
     */
    remove(key: string): Promise<void>;
    /**
     * Save persistent data, and emit messages to anyone that is using observe$ for this key
     *
     * @param {String} key Unique key associated with the data.
     */
    set(key: string, data: any): Promise<void>;
    /**
     * Observe changes on a particular key in the bucket
     * @param {String} key Unique key associated with the data
     */
    observe$<T>(key: string): Observable<StorageValueChange<T>>;
}
declare const storageApiRef: ApiRef<StorageApi>;

declare type AnyParams = {
    [param in string]: string;
} | undefined;
declare type ParamKeys<Params extends AnyParams> = keyof Params extends never ? [] : (keyof Params)[];
declare type OptionalParams<Params extends {
    [param in string]: string;
}> = Params[keyof Params] extends never ? undefined : Params;
declare type RouteFunc<Params extends AnyParams> = (...[params]: Params extends undefined ? readonly [] : readonly [Params]) => string;
declare const routeRefType: unique symbol;
declare type RouteRef<Params extends AnyParams = any> = {
    readonly [routeRefType]: 'absolute';
    params: ParamKeys<Params>;
    /** @deprecated paths are no longer accessed directly from RouteRefs, use useRouteRef instead */
    path: string;
    /** @deprecated icons are no longer accessed via RouteRefs */
    icon?: OldIconComponent;
    /** @deprecated titles are no longer accessed via RouteRefs */
    title?: string;
};
declare type SubRouteRef<Params extends AnyParams = any> = {
    readonly [routeRefType]: 'sub';
    parent: RouteRef;
    path: string;
    params: ParamKeys<Params>;
};
declare type ExternalRouteRef<Params extends AnyParams = any, Optional extends boolean = any> = {
    readonly [routeRefType]: 'external';
    params: ParamKeys<Params>;
    optional?: Optional;
};

declare function createRouteRef<Params extends {
    [param in ParamKey]: string;
}, ParamKey extends string = never>(config: {
    /** The id of the route ref, used to identify it when printed */
    id?: string;
    /** A list of parameter names that the path that this route ref is bound to must contain */
    params?: ParamKey[];
    /** @deprecated Route refs no longer decide their own path */
    path?: string;
    /** @deprecated Route refs no longer decide their own icon */
    icon?: OldIconComponent;
    /** @deprecated Route refs no longer decide their own title */
    title?: string;
}): RouteRef<OptionalParams<Params>>;

declare type ParamPart<S extends string> = S extends `:${infer Param}` ? Param : never;
declare type ParamNames<S extends string> = S extends `${infer Part}/${infer Rest}` ? ParamPart<Part> | ParamNames<Rest> : ParamPart<S>;
declare type PathParams<S extends string> = {
    [name in ParamNames<S>]: string;
};
/**
 * Merges a param object type with with an optional params type into a params object
 */
declare type MergeParams<P1 extends {
    [param in string]: string;
}, P2 extends AnyParams> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);
/**
 * Creates a SubRouteRef type given the desired parameters and parent route parameters.
 * The parameters types are merged together while ensuring that there is no overlap between the two.
 */
declare type MakeSubRouteRef<Params extends {
    [param in string]: string;
}, ParentParams extends AnyParams> = keyof Params & keyof ParentParams extends never ? SubRouteRef<OptionalParams<MergeParams<Params, ParentParams>>> : never;
declare function createSubRouteRef<Path extends string, ParentParams extends AnyParams = never>(config: {
    id: string;
    path: Path;
    parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

declare function createExternalRouteRef<Params extends {
    [param in ParamKey]: string;
}, Optional extends boolean = false, ParamKey extends string = never>(options: {
    /**
     * An identifier for this route, used to identify it in error messages
     */
    id: string;
    /**
     * The parameters that will be provided to the external route reference.
     */
    params?: ParamKey[];
    /**
     * Whether or not this route is optional, defaults to false.
     *
     * Optional external routes are not required to be bound in the app, and
     * if they aren't, `useRouteRef` will return `undefined`.
     */
    optional?: Optional;
}): ExternalRouteRef<OptionalParams<Params>, Optional>;

declare function useRouteRef<Optional extends boolean, Params extends AnyParams>(routeRef: ExternalRouteRef<Params, Optional>): Optional extends true ? RouteFunc<Params> | undefined : RouteFunc<Params>;
declare function useRouteRef<Params extends AnyParams>(routeRef: RouteRef<Params> | SubRouteRef<Params>): RouteFunc<Params>;

declare function useRouteRefParams<Params extends AnyParams>(_routeRef: RouteRef<Params> | SubRouteRef<Params>): Params;

declare type RouteOptions = {
    exact?: boolean;
};
declare type RoutePath = string;
declare type FeatureFlagOutput = {
    type: 'feature-flag';
    name: string;
};
declare type PluginOutput = FeatureFlagOutput;
declare type Extension<T> = {
    expose(plugin: BackstagePlugin<any, any>): T;
};
declare type AnyRoutes = {
    [name: string]: RouteRef | SubRouteRef;
};
declare type AnyExternalRoutes = {
    [name: string]: ExternalRouteRef;
};
declare type BackstagePlugin<Routes extends AnyRoutes = {}, ExternalRoutes extends AnyExternalRoutes = {}> = {
    getId(): string;
    output(): PluginOutput[];
    getApis(): Iterable<AnyApiFactory>;
    provide<T>(extension: Extension<T>): T;
    routes: Routes;
    externalRoutes: ExternalRoutes;
};
declare type PluginConfig<Routes extends AnyRoutes, ExternalRoutes extends AnyExternalRoutes> = {
    id: string;
    apis?: Iterable<AnyApiFactory>;
    register?(hooks: PluginHooks): void;
    routes?: Routes;
    externalRoutes?: ExternalRoutes;
};
declare type PluginHooks = {
    featureFlags: FeatureFlagsHooks;
};
declare type FeatureFlagsHooks = {
    register(name: string): void;
};

declare type BootErrorPageProps = {
    step: 'load-config' | 'load-chunk';
    error: Error;
};
declare type SignInResult = {
    /**
     * User ID that will be returned by the IdentityApi
     */
    userId: string;
    profile: ProfileInfo;
    /**
     * Function used to retrieve an ID token for the signed in user.
     */
    getIdToken?: () => Promise<string>;
    /**
     * Sign out handler that will be called if the user requests to sign out.
     */
    signOut?: () => Promise<void>;
};
declare type SignInPageProps = {
    /**
     * Set the sign-in result for the app. This should only be called once.
     */
    onResult(result: SignInResult): void;
};
declare type ErrorBoundaryFallbackProps = {
    plugin?: BackstagePlugin;
    error: Error;
    resetError: () => void;
};
declare type AppComponents = {
    NotFoundErrorPage: ComponentType<{}>;
    BootErrorPage: ComponentType<BootErrorPageProps>;
    Progress: ComponentType<{}>;
    Router: ComponentType<{}>;
    ErrorBoundaryFallback: ComponentType<ErrorBoundaryFallbackProps>;
    /**
     * An optional sign-in page that will be rendered instead of the AppRouter at startup.
     *
     * If a sign-in page is set, it will always be shown before the app, and it is up
     * to the sign-in page to handle e.g. saving of login methods for subsequent visits.
     *
     * The sign-in page will be displayed until it has passed up a result to the parent,
     * and which point the AppRouter and all of its children will be rendered instead.
     */
    SignInPage?: ComponentType<SignInPageProps>;
};
declare type AppContext = {
    /**
     * Get a list of all plugins that are installed in the app.
     */
    getPlugins(): BackstagePlugin<any, any>[];
    /**
     * Get a common or custom icon for this app.
     */
    getSystemIcon(key: string): IconComponent | undefined;
    /**
     * Get the components registered for various purposes in the app.
     */
    getComponents(): AppComponents;
};

declare const useApp: () => AppContext;

declare function attachComponentData<P>(component: ComponentType<P>, type: string, data: unknown): void;
declare function getComponentData<T>(node: ReactNode, type: string): T | undefined;

declare type ComponentLoader<T> = {
    lazy: () => Promise<T>;
} | {
    sync: T;
};
declare function createRoutableExtension<T extends (props: any) => JSX.Element | null>(options: {
    component: () => Promise<T>;
    mountPoint: RouteRef;
}): Extension<T>;
declare function createComponentExtension<T extends (props: any) => JSX.Element | null>(options: {
    component: ComponentLoader<T>;
}): Extension<T>;
declare function createReactExtension<T extends (props: any) => JSX.Element | null>(options: {
    component: ComponentLoader<T>;
    data?: Record<string, unknown>;
}): Extension<T>;

/**
 * A querying interface tailored to traversing a set of selected React elements
 * and extracting data.
 *
 * Methods prefixed with `selectBy` are used to narrow the set of selected elements.
 *
 * Methods prefixed with `find` return concrete data using a deep traversal of the set.
 *
 * Methods prefixed with `get` return concrete data using a shallow traversal of the set.
 */
interface ElementCollection {
    /**
     * Narrows the set of selected components by doing a deep traversal and
     * only including those that have defined component data for the given `key`.
     *
     * Whether an element in the tree has component data set for the given key
     * is determined by whether `getComponentData` returns undefined.
     *
     * The traversal does not continue deeper past elements that match the criteria,
     * and it also includes the root children in the selection, meaning that if the,
     * of all the currently selected elements contain data for the given key, this
     * method is a no-op.
     *
     * If `withStrictError` is set, the resulting selection must be a full match, meaning
     * there may be no elements that were excluded in the selection. If the selection
     * is not a clean match, an error will be throw with `withStrictError` as the message.
     */
    selectByComponentData(query: {
        key: string;
        withStrictError?: string;
    }): ElementCollection;
    /**
     * Finds all elements using the same criteria as `selectByComponentData`, but
     * returns the actual component data of each of those elements instead.
     */
    findComponentData<T>(query: {
        key: string;
    }): T[];
    /**
     * Returns all of the elements currently selected by this collection.
     */
    getElements<Props extends {
        [name: string]: unknown;
    }>(): Array<ReactElement<Props>>;
}
/**
 * useElementFilter is a utility that helps you narrow down and retrieve data
 * from a React element tree, typically operating on the `children` property
 * passed in to a component. A common use-case is to construct declarative APIs
 * where a React component defines its behavior based on its children, such as
 * the relationship between `Routes` and `Route` in `react-router`.
 *
 * The purpose of this hook is similar to `React.Children.map`, and it expands upon
 * it to also handle traversal of fragments and Backstage specific things like the
 * `FeatureFlagged` component.
 *
 * The return value of the hook is computed by the provided filter function, but
 * with added memoization based on the input `node`. If further memoization
 * dependencies are used in the filter function, they should be added to the
 * third `dependencies` argument, just like `useMemo`, `useEffect`, etc.
 */
declare function useElementFilter<T>(node: ReactNode, filterFn: (arg: ElementCollection) => T, dependencies?: any[]): T;

declare function createPlugin<Routes extends AnyRoutes = {}, ExternalRoutes extends AnyExternalRoutes = {}>(config: PluginConfig<Routes, ExternalRoutes>): BackstagePlugin<Routes, ExternalRoutes>;

export { AlertApi, AlertMessage, AnyApiFactory, AnyApiRef, ApiFactory, ApiHolder, ApiRef, ApiRefType, ApiRefsToTypes, AppComponents, AppContext, AppTheme, AppThemeApi, AuthProvider, AuthRequestOptions, AuthRequester, AuthRequesterOptions, BackstageIdentity, BackstageIdentityApi, BackstagePlugin, BootErrorPageProps, ConfigApi, DiscoveryApi, ElementCollection, ErrorApi, ErrorBoundaryFallbackProps, ErrorContext, Extension, ExternalRouteRef, FeatureFlag, FeatureFlagOutput, FeatureFlagState, FeatureFlagsApi, FeatureFlagsHooks, FeatureFlagsSaveOptions, IconComponent, IdentityApi, OAuthApi, OAuthRequestApi, OAuthScope, Observable, Observer, OpenIdConnectApi, PendingAuthRequest, PluginConfig, PluginHooks, PluginOutput, ProfileInfo, ProfileInfoApi, RouteOptions, RoutePath, RouteRef, SessionApi, SessionState, SignInPageProps, SignInResult, StorageApi, StorageValueChange, SubRouteRef, Subscription, TypesToApiRefs, UserFlags, alertApiRef, appThemeApiRef, attachComponentData, auth0AuthApiRef, configApiRef, createApiFactory, createApiRef, createComponentExtension, createExternalRouteRef, createPlugin, createReactExtension, createRoutableExtension, createRouteRef, createSubRouteRef, discoveryApiRef, errorApiRef, featureFlagsApiRef, getComponentData, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, microsoftAuthApiRef, oauth2ApiRef, oauthRequestApiRef, oidcAuthApiRef, oktaAuthApiRef, oneloginAuthApiRef, samlAuthApiRef, storageApiRef, useApi, useApiHolder, useApp, useElementFilter, useRouteRef, useRouteRefParams, withApis };
