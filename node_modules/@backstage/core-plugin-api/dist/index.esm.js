import React, { useContext, useMemo, lazy, Suspense, Children, isValidElement, Fragment } from 'react';
import { useLocation, useParams } from 'react-router-dom';

function getGlobalObject() {
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  return Function("return this")();
}
const globalObject = getGlobalObject();
const makeKey = (id) => `__@backstage/${id}__`;
function getGlobalSingleton(id) {
  const key = makeKey(id);
  if (!(key in globalObject)) {
    throw new Error(`Global ${id} is not set`);
  }
  return globalObject[key];
}
function getOrCreateGlobalSingleton(id, supplier) {
  const key = makeKey(id);
  let value = globalObject[key];
  if (value) {
    return value;
  }
  value = supplier();
  globalObject[key] = value;
  return value;
}

function useVersionedContext(key) {
  const versionedValue = useContext(getGlobalSingleton(key));
  if (!versionedValue) {
    throw new Error(`No provider available for ${key} context`);
  }
  return versionedValue;
}

function useApiHolder() {
  const versionedHolder = useVersionedContext("api-context");
  const apiHolder = versionedHolder.atVersion(1);
  if (!apiHolder) {
    throw new Error("ApiContext v1 not available");
  }
  return apiHolder;
}
function useApi(apiRef) {
  const apiHolder = useApiHolder();
  const api = apiHolder.get(apiRef);
  if (!api) {
    throw new Error(`No implementation available for ${apiRef}`);
  }
  return api;
}
function withApis(apis) {
  return function withApisWrapper(WrappedComponent) {
    const Hoc = (props) => {
      const apiHolder = useApiHolder();
      const impls = {};
      for (const key in apis) {
        if (apis.hasOwnProperty(key)) {
          const ref = apis[key];
          const api = apiHolder.get(ref);
          if (!api) {
            throw new Error(`No implementation available for ${ref}`);
          }
          impls[key] = api;
        }
      }
      return /* @__PURE__ */ React.createElement(WrappedComponent, {
        ...props,
        ...impls
      });
    };
    const displayName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    Hoc.displayName = `withApis(${displayName})`;
    return Hoc;
  };
}

class ApiRefImpl {
  constructor(config) {
    this.config = config;
    const valid = config.id.split(".").flatMap((part) => part.split("-")).every((part) => part.match(/^[a-z][a-z0-9]*$/));
    if (!valid) {
      throw new Error(`API id must only contain period separated lowercase alphanum tokens with dashes, got '${config.id}'`);
    }
  }
  get id() {
    return this.config.id;
  }
  get description() {
    console.warn("Deprecated use of ApiRef.description");
    return this.config.description;
  }
  get T() {
    throw new Error(`tried to read ApiRef.T of ${this}`);
  }
  toString() {
    return `apiRef{${this.config.id}}`;
  }
}
function createApiRef(config) {
  return new ApiRefImpl(config);
}

function createApiFactory(factory, instance) {
  if ("id" in factory) {
    return {
      api: factory,
      deps: {},
      factory: () => instance
    };
  }
  return factory;
}

var SessionState;
(function(SessionState2) {
  SessionState2["SignedIn"] = "SignedIn";
  SessionState2["SignedOut"] = "SignedOut";
})(SessionState || (SessionState = {}));
const googleAuthApiRef = createApiRef({
  id: "core.auth.google"
});
const githubAuthApiRef = createApiRef({
  id: "core.auth.github"
});
const oktaAuthApiRef = createApiRef({
  id: "core.auth.okta"
});
const gitlabAuthApiRef = createApiRef({
  id: "core.auth.gitlab"
});
const auth0AuthApiRef = createApiRef({
  id: "core.auth.auth0"
});
const microsoftAuthApiRef = createApiRef({
  id: "core.auth.microsoft"
});
const oauth2ApiRef = createApiRef({
  id: "core.auth.oauth2"
});
const oidcAuthApiRef = createApiRef({
  id: "core.auth.oidc"
});
const samlAuthApiRef = createApiRef({
  id: "core.auth.saml"
});
const oneloginAuthApiRef = createApiRef({
  id: "core.auth.onelogin"
});

const alertApiRef = createApiRef({
  id: "core.alert"
});

const appThemeApiRef = createApiRef({
  id: "core.apptheme"
});

const configApiRef = createApiRef({
  id: "core.config"
});

const discoveryApiRef = createApiRef({
  id: "core.discovery"
});

const errorApiRef = createApiRef({
  id: "core.error"
});

var FeatureFlagState;
(function(FeatureFlagState2) {
  FeatureFlagState2[FeatureFlagState2["None"] = 0] = "None";
  FeatureFlagState2[FeatureFlagState2["Active"] = 1] = "Active";
})(FeatureFlagState || (FeatureFlagState = {}));
const featureFlagsApiRef = createApiRef({
  id: "core.featureflags"
});

const identityApiRef = createApiRef({
  id: "core.identity"
});

const oauthRequestApiRef = createApiRef({
  id: "core.oauthrequest"
});

const storageApiRef = createApiRef({
  id: "core.storage"
});

const useApp = () => {
  const versionedContext = useVersionedContext("app-context");
  const appContext = versionedContext.atVersion(1);
  if (!appContext) {
    throw new Error("AppContext v1 not available");
  }
  return appContext;
};

const globalStore = getOrCreateGlobalSingleton("component-data-store", () => new WeakMap());
function attachComponentData(component, type, data) {
  let container = globalStore.get(component);
  if (!container) {
    container = {map: new Map()};
    globalStore.set(component, container);
  }
  if (container.map.has(type)) {
    const name = component.displayName || component.name;
    throw new Error(`Attempted to attach duplicate data "${type}" to component "${name}"`);
  }
  container.map.set(type, data);
}
function getComponentData(node, type) {
  if (!node) {
    return void 0;
  }
  const component = node.type;
  if (!component) {
    return void 0;
  }
  const container = globalStore.get(component);
  if (!container) {
    return void 0;
  }
  return container.map.get(type);
}

const routeRefType = getOrCreateGlobalSingleton("route-ref-type", () => Symbol("route-ref-type"));

var _a$2;
class RouteRefImpl {
  constructor(id, params, config) {
    this.id = id;
    this.params = params;
    this.config = config;
    this[_a$2] = "absolute";
  }
  get icon() {
    return this.config.icon;
  }
  get path() {
    var _a2;
    return (_a2 = this.config.path) != null ? _a2 : "";
  }
  get title() {
    var _a2;
    return (_a2 = this.config.title) != null ? _a2 : this.id;
  }
  toString() {
    return `routeRef{type=absolute,id=${this.id}}`;
  }
}
_a$2 = routeRefType;
function createRouteRef(config) {
  var _a2;
  const id = config.id || config.title;
  if (!id) {
    throw new Error("RouteRef must be provided a non-empty id");
  }
  return new RouteRefImpl(id, (_a2 = config.params) != null ? _a2 : [], config);
}

var _a$1;
const PARAM_PATTERN = /^\w+$/;
class SubRouteRefImpl {
  constructor(id, path, parent, params) {
    this.id = id;
    this.path = path;
    this.parent = parent;
    this.params = params;
    this[_a$1] = "sub";
  }
  toString() {
    return `routeRef{type=sub,id=${this.id}}`;
  }
}
_a$1 = routeRefType;
function createSubRouteRef(config) {
  const {id, path, parent} = config;
  const pathParams = path.split("/").filter((p) => p.startsWith(":")).map((p) => p.substring(1));
  const params = [...parent.params, ...pathParams];
  if (parent.params.some((p) => pathParams.includes(p))) {
    throw new Error("SubRouteRef may not have params that overlap with its parent");
  }
  if (!path.startsWith("/")) {
    throw new Error(`SubRouteRef path must start with '/', got '${path}'`);
  }
  if (path.endsWith("/")) {
    throw new Error(`SubRouteRef path must not end with '/', got '${path}'`);
  }
  for (const param of pathParams) {
    if (!PARAM_PATTERN.test(param)) {
      throw new Error(`SubRouteRef path has invalid param, got '${param}'`);
    }
  }
  const subRouteRef = new SubRouteRefImpl(id, path, parent, params);
  return subRouteRef;
}

var _a;
class ExternalRouteRefImpl {
  constructor(id, params, optional) {
    this.id = id;
    this.params = params;
    this.optional = optional;
    this[_a] = "external";
  }
  toString() {
    return `routeRef{type=external,id=${this.id}}`;
  }
}
_a = routeRefType;
function createExternalRouteRef(options) {
  var _a2;
  return new ExternalRouteRefImpl(options.id, (_a2 = options.params) != null ? _a2 : [], Boolean(options.optional));
}

function useRouteRef(routeRef) {
  const sourceLocation = useLocation();
  const versionedContext = useVersionedContext("routing-context");
  const resolver = versionedContext.atVersion(1);
  const routeFunc = useMemo(() => resolver && resolver.resolve(routeRef, sourceLocation), [resolver, routeRef, sourceLocation]);
  if (!versionedContext) {
    throw new Error("useRouteRef used outside of routing context");
  }
  if (!resolver) {
    throw new Error("RoutingContext v1 not available");
  }
  const isOptional = "optional" in routeRef && routeRef.optional;
  if (!routeFunc && !isOptional) {
    throw new Error(`No path for ${routeRef}`);
  }
  return routeFunc;
}

function useRouteRefParams(_routeRef) {
  return useParams();
}

class PluginErrorBoundary extends React.Component {
  constructor() {
    super(...arguments);
    this.state = {error: void 0};
    this.handleErrorReset = () => {
      this.setState({error: void 0});
    };
  }
  static getDerivedStateFromError(error) {
    return {error};
  }
  render() {
    const {error} = this.state;
    const {app, plugin} = this.props;
    const {ErrorBoundaryFallback} = app.getComponents();
    if (error) {
      return /* @__PURE__ */ React.createElement(ErrorBoundaryFallback, {
        error,
        resetError: this.handleErrorReset,
        plugin
      });
    }
    return this.props.children;
  }
}

function createRoutableExtension(options) {
  const {component, mountPoint} = options;
  return createReactExtension({
    component: {
      lazy: () => component().then((InnerComponent) => {
        const RoutableExtensionWrapper = (props) => {
          try {
            useRouteRef(mountPoint);
          } catch (error) {
            if (error == null ? void 0 : error.message.startsWith("No path for ")) {
              throw new Error(`Routable extension component with mount point ${mountPoint} was not discovered in the app element tree. Routable extension components may not be rendered by other components and must be directly available as an element within the App provider component.`);
            }
            throw error;
          }
          return /* @__PURE__ */ React.createElement(InnerComponent, {
            ...props
          });
        };
        const componentName = InnerComponent.displayName || InnerComponent.name || "LazyComponent";
        RoutableExtensionWrapper.displayName = `RoutableExtension(${componentName})`;
        return RoutableExtensionWrapper;
      }, (error) => {
        const RoutableExtensionWrapper = (_) => {
          const app = useApp();
          const {BootErrorPage} = app.getComponents();
          return /* @__PURE__ */ React.createElement(BootErrorPage, {
            step: "load-chunk",
            error
          });
        };
        return RoutableExtensionWrapper;
      })
    },
    data: {
      "core.mountPoint": mountPoint
    }
  });
}
function createComponentExtension(options) {
  const {component} = options;
  return createReactExtension({component});
}
function createReactExtension(options) {
  const {data = {}} = options;
  let Component;
  if ("lazy" in options.component) {
    const lazyLoader = options.component.lazy;
    Component = lazy(() => lazyLoader().then((component) => ({default: component})));
  } else {
    Component = options.component.sync;
  }
  const componentName = Component.displayName || Component.name || "Component";
  return {
    expose(plugin) {
      const Result = (props) => {
        const app = useApp();
        const {Progress} = app.getComponents();
        return /* @__PURE__ */ React.createElement(Suspense, {
          fallback: /* @__PURE__ */ React.createElement(Progress, null)
        }, /* @__PURE__ */ React.createElement(PluginErrorBoundary, {
          app,
          plugin
        }, /* @__PURE__ */ React.createElement(Component, {
          ...props
        })));
      };
      attachComponentData(Result, "core.plugin", plugin);
      for (const [key, value] of Object.entries(data)) {
        attachComponentData(Result, key, value);
      }
      Result.displayName = `Extension(${componentName})`;
      return Result;
    }
  };
}

function selectChildren(rootNode, featureFlagsApi, selector, strictError) {
  return Children.toArray(rootNode).flatMap((node) => {
    if (!isValidElement(node)) {
      return [];
    }
    if (node.type === Fragment) {
      return selectChildren(node.props.children, featureFlagsApi, selector, strictError);
    }
    if (getComponentData(node, "core.featureFlagged")) {
      const props = node.props;
      const isEnabled = "with" in props ? featureFlagsApi.isActive(props.with) : !featureFlagsApi.isActive(props.without);
      if (isEnabled) {
        return selectChildren(node.props.children, featureFlagsApi, selector, strictError);
      }
      return [];
    }
    if (selector === void 0 || selector(node)) {
      return [node];
    }
    if (strictError) {
      throw new Error(strictError);
    }
    return selectChildren(node.props.children, featureFlagsApi, selector, strictError);
  });
}
class Collection {
  constructor(node, featureFlagsApi) {
    this.node = node;
    this.featureFlagsApi = featureFlagsApi;
  }
  selectByComponentData(query) {
    const selection = selectChildren(this.node, this.featureFlagsApi, (node) => getComponentData(node, query.key) !== void 0, query.withStrictError);
    return new Collection(selection, this.featureFlagsApi);
  }
  findComponentData(query) {
    const selection = selectChildren(this.node, this.featureFlagsApi, (node) => getComponentData(node, query.key) !== void 0);
    return selection.map((node) => getComponentData(node, query.key)).filter((data) => data !== void 0);
  }
  getElements() {
    return selectChildren(this.node, this.featureFlagsApi);
  }
}
function useElementFilter(node, filterFn, dependencies = []) {
  const featureFlagsApi = useApi(featureFlagsApiRef);
  const elements = new Collection(node, featureFlagsApi);
  return useMemo(() => filterFn(elements), [node, ...dependencies]);
}

class PluginImpl {
  constructor(config) {
    this.config = config;
  }
  getId() {
    return this.config.id;
  }
  getApis() {
    var _a;
    return (_a = this.config.apis) != null ? _a : [];
  }
  get routes() {
    var _a;
    return (_a = this.config.routes) != null ? _a : {};
  }
  get externalRoutes() {
    var _a;
    return (_a = this.config.externalRoutes) != null ? _a : {};
  }
  output() {
    if (this.storedOutput) {
      return this.storedOutput;
    }
    if (!this.config.register) {
      return [];
    }
    const outputs = new Array();
    this.config.register({
      featureFlags: {
        register(name) {
          outputs.push({type: "feature-flag", name});
        }
      }
    });
    this.storedOutput = outputs;
    return this.storedOutput;
  }
  provide(extension) {
    return extension.expose(this);
  }
  toString() {
    return `plugin{${this.config.id}}`;
  }
}
function createPlugin(config) {
  return new PluginImpl(config);
}

export { FeatureFlagState, SessionState, alertApiRef, appThemeApiRef, attachComponentData, auth0AuthApiRef, configApiRef, createApiFactory, createApiRef, createComponentExtension, createExternalRouteRef, createPlugin, createReactExtension, createRoutableExtension, createRouteRef, createSubRouteRef, discoveryApiRef, errorApiRef, featureFlagsApiRef, getComponentData, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, microsoftAuthApiRef, oauth2ApiRef, oauthRequestApiRef, oidcAuthApiRef, oktaAuthApiRef, oneloginAuthApiRef, samlAuthApiRef, storageApiRef, useApi, useApiHolder, useApp, useElementFilter, useRouteRef, useRouteRefParams, withApis };
//# sourceMappingURL=index.esm.js.map
