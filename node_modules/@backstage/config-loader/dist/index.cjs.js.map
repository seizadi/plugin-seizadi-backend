{"version":3,"file":"index.cjs.js","sources":["../src/lib/env.ts","../src/lib/transform/utils.ts","../src/lib/transform/apply.ts","../src/lib/transform/include.ts","../src/lib/transform/substitution.ts","../src/lib/schema/types.ts","../src/lib/schema/compile.ts","../src/lib/schema/collect.ts","../src/lib/schema/filtering.ts","../src/lib/schema/load.ts","../src/loader.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig, JsonObject } from '@backstage/config';\n\nconst ENV_PREFIX = 'APP_CONFIG_';\n\n// Update the same pattern in config package if this is changed\nconst CONFIG_KEY_PART_PATTERN = /^[a-z][a-z0-9]*(?:[-_][a-z][a-z0-9]*)*$/i;\n\n/**\n * Read runtime configuration from the environment.\n *\n * Only environment variables prefixed with APP_CONFIG_ will be considered.\n *\n * For each variable, the prefix will be removed, and rest of the key will\n * be split by '_'. Each part will then be used as keys to build up a nested\n * config object structure. The treatment of the entire environment variable\n * is case-sensitive.\n *\n * The value of the variable should be JSON serialized, as it will be parsed\n * and the type will be kept intact. For example \"true\" and true are treated\n * differently, as well as \"42\" and 42.\n *\n * For example, to set the config app.title to \"My Title\", use the following:\n *\n * APP_CONFIG_app_title='\"My Title\"'\n */\nexport function readEnvConfig(env: {\n  [name: string]: string | undefined;\n}): AppConfig[] {\n  let data: JsonObject | undefined = undefined;\n\n  for (const [name, value] of Object.entries(env)) {\n    if (!value) {\n      continue;\n    }\n    if (name.startsWith(ENV_PREFIX)) {\n      const key = name.replace(ENV_PREFIX, '');\n      const keyParts = key.split('_');\n\n      let obj = (data = data ?? {});\n      for (const [index, part] of keyParts.entries()) {\n        if (!CONFIG_KEY_PART_PATTERN.test(part)) {\n          throw new TypeError(`Invalid env config key '${key}'`);\n        }\n        if (index < keyParts.length - 1) {\n          obj = (obj[part] = obj[part] ?? {}) as JsonObject;\n          if (typeof obj !== 'object' || Array.isArray(obj)) {\n            const subKey = keyParts.slice(0, index + 1).join('_');\n            throw new TypeError(\n              `Could not nest config for key '${key}' under existing value '${subKey}'`,\n            );\n          }\n        } else {\n          if (part in obj) {\n            throw new TypeError(\n              `Refusing to override existing config at key '${key}'`,\n            );\n          }\n          try {\n            const [, parsedValue] = safeJsonParse(value);\n            if (parsedValue === null) {\n              throw new Error('value may not be null');\n            }\n            obj[part] = parsedValue;\n          } catch (error) {\n            throw new TypeError(\n              `Failed to parse JSON-serialized config value for key '${key}', ${error}`,\n            );\n          }\n        }\n      }\n    }\n  }\n\n  return data ? [{ data, context: 'env' }] : [];\n}\n\nfunction safeJsonParse(str: string): [Error | null, any] {\n  try {\n    return [null, JSON.parse(str)];\n  } catch (err) {\n    return [err, str];\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonValue, JsonObject } from '@backstage/config';\n\nexport function isObject(obj: JsonValue | undefined): obj is JsonObject {\n  if (typeof obj !== 'object') {\n    return false;\n  } else if (Array.isArray(obj)) {\n    return false;\n  }\n  return obj !== null;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonObject, JsonValue } from '@backstage/config';\nimport { TransformFunc } from './types';\nimport { isObject } from './utils';\n\n/**\n * Applies a set of transforms to raw configuration data.\n */\nexport async function applyConfigTransforms(\n  initialDir: string,\n  input: JsonValue,\n  transforms: TransformFunc[],\n): Promise<JsonObject> {\n  async function transform(\n    inputObj: JsonValue,\n    path: string,\n    baseDir: string,\n  ): Promise<JsonValue | undefined> {\n    let obj = inputObj;\n    let dir = baseDir;\n\n    for (const tf of transforms) {\n      try {\n        const result = await tf(inputObj, baseDir);\n        if (result.applied) {\n          if (result.value === undefined) {\n            return undefined;\n          }\n          obj = result.value;\n          dir = result.newBaseDir ?? dir;\n          break;\n        }\n      } catch (error) {\n        throw new Error(`error at ${path}, ${error.message}`);\n      }\n    }\n\n    if (typeof obj !== 'object') {\n      return obj;\n    } else if (obj === null) {\n      return undefined;\n    } else if (Array.isArray(obj)) {\n      const arr = new Array<JsonValue>();\n\n      for (const [index, value] of obj.entries()) {\n        const out = await transform(value, `${path}[${index}]`, dir);\n        if (out !== undefined) {\n          arr.push(out);\n        }\n      }\n\n      return arr;\n    }\n\n    const out: JsonObject = {};\n\n    for (const [key, value] of Object.entries(obj)) {\n      // undefined covers optional fields\n      if (value !== undefined) {\n        const result = await transform(value, `${path}.${key}`, dir);\n        if (result !== undefined) {\n          out[key] = result;\n        }\n      }\n    }\n\n    return out;\n  }\n\n  const finalData = await transform(input, '', initialDir);\n  if (!isObject(finalData)) {\n    throw new TypeError('expected object at config root');\n  }\n  return finalData;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport yaml from 'yaml';\nimport { extname, dirname, resolve as resolvePath } from 'path';\nimport { JsonObject, JsonValue } from '@backstage/config';\nimport { isObject } from './utils';\nimport { TransformFunc, EnvFunc, ReadFileFunc } from './types';\n\n// Parsers for each type of included file\nconst includeFileParser: {\n  [ext in string]: (content: string) => Promise<JsonObject>;\n} = {\n  '.json': async content => JSON.parse(content),\n  '.yaml': async content => yaml.parse(content),\n  '.yml': async content => yaml.parse(content),\n};\n\n/**\n * Transforms a include description into the actual included value.\n */\nexport function createIncludeTransform(\n  env: EnvFunc,\n  readFile: ReadFileFunc,\n  substitute: TransformFunc,\n): TransformFunc {\n  return async (input: JsonValue, baseDir: string) => {\n    if (!isObject(input)) {\n      return { applied: false };\n    }\n    // Check if there's any key that starts with a '$', in that case we treat\n    // this entire object as an include description.\n    const [includeKey] = Object.keys(input).filter(key => key.startsWith('$'));\n    if (includeKey) {\n      if (Object.keys(input).length !== 1) {\n        throw new Error(\n          `include key ${includeKey} should not have adjacent keys`,\n        );\n      }\n    } else {\n      return { applied: false };\n    }\n\n    const rawIncludedValue = input[includeKey];\n    if (typeof rawIncludedValue !== 'string') {\n      throw new Error(`${includeKey} include value is not a string`);\n    }\n\n    const substituteResults = await substitute(rawIncludedValue, baseDir);\n    const includeValue = substituteResults.applied\n      ? substituteResults.value\n      : rawIncludedValue;\n\n    // The second string check is needed for Typescript to know this is a string.\n    if (includeValue === undefined || typeof includeValue !== 'string') {\n      throw new Error(`${includeKey} substitution value was undefined`);\n    }\n\n    switch (includeKey) {\n      case '$file':\n        try {\n          const value = await readFile(resolvePath(baseDir, includeValue));\n          return { applied: true, value };\n        } catch (error) {\n          throw new Error(`failed to read file ${includeValue}, ${error}`);\n        }\n      case '$env':\n        try {\n          return { applied: true, value: await env(includeValue) };\n        } catch (error) {\n          throw new Error(`failed to read env ${includeValue}, ${error}`);\n        }\n\n      case '$include': {\n        const [filePath, dataPath] = includeValue.split(/#(.*)/);\n\n        const ext = extname(filePath);\n        const parser = includeFileParser[ext];\n        if (!parser) {\n          throw new Error(\n            `no configuration parser available for included file ${filePath}`,\n          );\n        }\n\n        const path = resolvePath(baseDir, filePath);\n        const content = await readFile(path);\n        const newBaseDir = dirname(path);\n\n        const parts = dataPath ? dataPath.split('.') : [];\n\n        let value: JsonValue | undefined;\n        try {\n          value = await parser(content);\n        } catch (error) {\n          throw new Error(\n            `failed to parse included file ${filePath}, ${error}`,\n          );\n        }\n\n        // This bit handles selecting a subtree in the included file, if a path was provided after a #\n        for (const [index, part] of parts.entries()) {\n          if (!isObject(value)) {\n            const errPath = parts.slice(0, index).join('.');\n            throw new Error(\n              `value at '${errPath}' in included file ${filePath} is not an object`,\n            );\n          }\n          value = value[part];\n        }\n\n        return {\n          applied: true,\n          value,\n          newBaseDir: newBaseDir !== baseDir ? newBaseDir : undefined,\n        };\n      }\n\n      default:\n        throw new Error(`unknown include ${includeKey}`);\n    }\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonValue } from '@backstage/config';\nimport { TransformFunc, EnvFunc } from './types';\n\n/**\n * A environment variable substitution transform that transforms e.g. 'token ${MY_TOKEN}'\n * to 'token abc' if MY_TOKEN is 'abc'. If any of the substituted variables are undefined,\n * the entire expression ends up undefined.\n */\nexport function createSubstitutionTransform(env: EnvFunc): TransformFunc {\n  return async (input: JsonValue) => {\n    if (typeof input !== 'string') {\n      return { applied: false };\n    }\n\n    const parts: (string | undefined)[] = input.split(/(\\$?\\$\\{[^{}]*\\})/);\n    for (let i = 1; i < parts.length; i += 2) {\n      const part = parts[i]!;\n      if (part.startsWith('$$')) {\n        parts[i] = part.slice(1);\n      } else {\n        parts[i] = await env(part.slice(2, -1).trim());\n      }\n    }\n\n    if (parts.some(part => part === undefined)) {\n      return { applied: true, value: undefined };\n    }\n    return { applied: true, value: parts.join('') };\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig, JsonObject } from '@backstage/config';\n\n/**\n * An sub-set of configuration schema.\n */\nexport type ConfigSchemaPackageEntry = {\n  /**\n   * The configuration schema itself.\n   */\n  value: JsonObject;\n  /**\n   * The relative path that the configuration schema was discovered at.\n   */\n  path: string;\n};\n\n/**\n * A list of all possible configuration value visibilities.\n */\nexport const CONFIG_VISIBILITIES = ['frontend', 'backend', 'secret'] as const;\n\n/**\n * A type representing the possible configuration value visibilities\n */\nexport type ConfigVisibility = typeof CONFIG_VISIBILITIES[number];\n\n/**\n * The default configuration visibility if no other values is given.\n */\nexport const DEFAULT_CONFIG_VISIBILITY: ConfigVisibility = 'backend';\n\n/**\n * An explanation of a configuration validation error.\n */\ntype ValidationError = string;\n\n/**\n * The result of validating configuration data using a schema.\n */\ntype ValidationResult = {\n  /**\n   * Errors that where emitted during validation, if any.\n   */\n  errors?: ValidationError[];\n  /**\n   * The configuration visibilities that were discovered during validation.\n   *\n   * The path in the key uses the form `/<key>/<sub-key>/<array-index>/<leaf-key>`\n   */\n  visibilityByPath: Map<string, ConfigVisibility>;\n};\n\n/**\n * A function used validate configuration data.\n */\nexport type ValidationFunc = (configs: AppConfig[]) => ValidationResult;\n\n/**\n * A function used to transform primitive configuration values.\n */\nexport type TransformFunc<T extends number | string | boolean> = (\n  value: T,\n  context: { visibility: ConfigVisibility },\n) => T | undefined;\n\n/**\n * Options used to process configuration data with a schema.\n */\ntype ConfigProcessingOptions = {\n  /**\n   * The visibilities that should be included in the output data.\n   * If omitted, the data will not be filtered by visibility.\n   */\n  visibility?: ConfigVisibility[];\n\n  /**\n   * A transform function that can be used to transform primitive configuration values\n   * during validation. The value returned from the transform function will be used\n   * instead of the original value. If the transform returns `undefined`, the value\n   * will be omitted.\n   */\n  valueTransform?: TransformFunc<any>;\n\n  /**\n   * Whether or not to include the `filteredKeys` property in the output `AppConfig`s.\n   *\n   * Default: `false`.\n   */\n  withFilteredKeys?: boolean;\n};\n\n/**\n * A loaded configuration schema that is ready to process configuration data.\n */\nexport type ConfigSchema = {\n  process(\n    appConfigs: AppConfig[],\n    options?: ConfigProcessingOptions,\n  ): AppConfig[];\n\n  serialize(): JsonObject;\n};\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Ajv from 'ajv';\nimport { JSONSchema7 as JSONSchema } from 'json-schema';\nimport mergeAllOf, { Resolvers } from 'json-schema-merge-allof';\nimport { ConfigReader } from '@backstage/config';\nimport {\n  ConfigSchemaPackageEntry,\n  ValidationFunc,\n  CONFIG_VISIBILITIES,\n  ConfigVisibility,\n} from './types';\n\n/**\n * This takes a collection of Backstage configuration schemas from various\n * sources and compiles them down into a single schema validation function.\n *\n * It also handles the implementation of the custom \"visibility\" keyword used\n * to specify the scope of different config paths.\n */\nexport function compileConfigSchemas(\n  schemas: ConfigSchemaPackageEntry[],\n): ValidationFunc {\n  // The ajv instance below is stateful and doesn't really allow for additional\n  // output during validation. We work around this by having this extra piece\n  // of state that we reset before each validation.\n  const visibilityByPath = new Map<string, ConfigVisibility>();\n\n  const ajv = new Ajv({\n    allErrors: true,\n    allowUnionTypes: true,\n    schemas: {\n      'https://backstage.io/schema/config-v1': true,\n    },\n  }).addKeyword({\n    keyword: 'visibility',\n    metaSchema: {\n      type: 'string',\n      enum: CONFIG_VISIBILITIES,\n    },\n    compile(visibility: ConfigVisibility) {\n      return (_data, context) => {\n        if (context?.dataPath === undefined) {\n          return false;\n        }\n        if (visibility && visibility !== 'backend') {\n          const normalizedPath = context.dataPath.replace(\n            /\\['?(.*?)'?\\]/g,\n            (_, segment) => `/${segment}`,\n          );\n          visibilityByPath.set(normalizedPath, visibility);\n        }\n        return true;\n      };\n    },\n  });\n\n  for (const schema of schemas) {\n    try {\n      ajv.compile(schema.value);\n    } catch (error) {\n      throw new Error(`Schema at ${schema.path} is invalid, ${error}`);\n    }\n  }\n\n  const merged = mergeConfigSchemas(schemas.map(_ => _.value));\n  const validate = ajv.compile(merged);\n\n  return configs => {\n    const config = ConfigReader.fromConfigs(configs).get();\n\n    visibilityByPath.clear();\n\n    const valid = validate(config);\n    if (!valid) {\n      const errors = validate.errors ?? [];\n      return {\n        errors: errors.map(({ dataPath, message, params }) => {\n          const paramStr = Object.entries(params)\n            .map(([name, value]) => `${name}=${value}`)\n            .join(' ');\n          return `Config ${message || ''} { ${paramStr} } at ${dataPath}`;\n        }),\n        visibilityByPath: new Map(),\n      };\n    }\n\n    return {\n      visibilityByPath: new Map(visibilityByPath),\n    };\n  };\n}\n\n/**\n * Given a list of configuration schemas from packages, merge them\n * into a single json schema.\n */\nexport function mergeConfigSchemas(schemas: JSONSchema[]): JSONSchema {\n  const merged = mergeAllOf(\n    { allOf: schemas },\n    {\n      // JSONSchema is typically subtractive, as in it always reduces the set of allowed\n      // inputs through constraints. This changes the object property merging to be additive\n      // rather than subtractive.\n      ignoreAdditionalProperties: true,\n      resolvers: {\n        // This ensures that the visibilities across different schemas are sound, and\n        // selects the most specific visibility for each path.\n        visibility(values: string[], path: string[]) {\n          const hasFrontend = values.some(_ => _ === 'frontend');\n          const hasSecret = values.some(_ => _ === 'secret');\n          if (hasFrontend && hasSecret) {\n            throw new Error(\n              `Config schema visibility is both 'frontend' and 'secret' for ${path.join(\n                '/',\n              )}`,\n            );\n          } else if (hasFrontend) {\n            return 'frontend';\n          } else if (hasSecret) {\n            return 'secret';\n          }\n\n          return 'backend';\n        },\n      } as Partial<Resolvers<JSONSchema>>,\n    },\n  );\n  return merged;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs-extra';\nimport {\n  resolve as resolvePath,\n  relative as relativePath,\n  dirname,\n  sep,\n} from 'path';\nimport { ConfigSchemaPackageEntry } from './types';\nimport { getProgramFromFiles, generateSchema } from 'typescript-json-schema';\nimport { JsonObject } from '@backstage/config';\n\ntype Item = {\n  name: string;\n  parentPath?: string;\n};\n\nconst req =\n  typeof __non_webpack_require__ === 'undefined'\n    ? require\n    : __non_webpack_require__;\n\n/**\n * This collects all known config schemas across all dependencies of the app.\n */\nexport async function collectConfigSchemas(\n  packageNames: string[],\n): Promise<ConfigSchemaPackageEntry[]> {\n  const visitedPackages = new Set<string>();\n  const schemas = Array<ConfigSchemaPackageEntry>();\n  const tsSchemaPaths = Array<string>();\n  const currentDir = await fs.realpath(process.cwd());\n\n  async function processItem({ name, parentPath }: Item) {\n    // Ensures that we only process each package once. We don't bother with\n    // loading in schemas from duplicates of different versions, as that's not\n    // supported by Backstage right now anyway. We may want to change that in\n    // the future though, if it for example becomes possible to load in two\n    // different versions of e.g. @backstage/core at once.\n    if (visitedPackages.has(name)) {\n      return;\n    }\n    visitedPackages.add(name);\n\n    let pkgPath: string;\n    try {\n      pkgPath = req.resolve(\n        `${name}/package.json`,\n        parentPath && {\n          paths: [parentPath],\n        },\n      );\n    } catch {\n      // We can somewhat safely ignore packages that don't export package.json,\n      // as they are likely not part of the Backstage ecosystem anyway.\n      return;\n    }\n\n    const pkg = await fs.readJson(pkgPath);\n    const depNames = [\n      ...Object.keys(pkg.dependencies ?? {}),\n      ...Object.keys(pkg.devDependencies ?? {}),\n      ...Object.keys(pkg.optionalDependencies ?? {}),\n      ...Object.keys(pkg.peerDependencies ?? {}),\n    ];\n\n    // TODO(Rugvip): Trying this out to avoid having to traverse the full dependency graph,\n    //               since that's pretty slow. We probably need a better way to determine when\n    //               we've left the Backstage ecosystem, but this will do for now.\n    const hasSchema = 'configSchema' in pkg;\n    const hasBackstageDep = depNames.some(_ => _.startsWith('@backstage/'));\n    if (!hasSchema && !hasBackstageDep) {\n      return;\n    }\n    if (hasSchema) {\n      if (typeof pkg.configSchema === 'string') {\n        const isJson = pkg.configSchema.endsWith('.json');\n        const isDts = pkg.configSchema.endsWith('.d.ts');\n        if (!isJson && !isDts) {\n          throw new Error(\n            `Config schema files must be .json or .d.ts, got ${pkg.configSchema}`,\n          );\n        }\n        if (isDts) {\n          tsSchemaPaths.push(\n            relativePath(\n              currentDir,\n              resolvePath(dirname(pkgPath), pkg.configSchema),\n            ),\n          );\n        } else {\n          const path = resolvePath(dirname(pkgPath), pkg.configSchema);\n          const value = await fs.readJson(path);\n          schemas.push({\n            value,\n            path: relativePath(currentDir, path),\n          });\n        }\n      } else {\n        schemas.push({\n          value: pkg.configSchema,\n          path: relativePath(currentDir, pkgPath),\n        });\n      }\n    }\n\n    await Promise.all(\n      depNames.map(depName =>\n        processItem({ name: depName, parentPath: pkgPath }),\n      ),\n    );\n  }\n\n  await Promise.all(\n    packageNames.map(name => processItem({ name, parentPath: currentDir })),\n  );\n\n  const tsSchemas = compileTsSchemas(tsSchemaPaths);\n\n  return schemas.concat(tsSchemas);\n}\n\n// This handles the support of TypeScript .d.ts config schema declarations.\n// We collect all typescript schema definition and compile them all in one go.\n// This is much faster than compiling them separately.\nfunction compileTsSchemas(paths: string[]) {\n  if (paths.length === 0) {\n    return [];\n  }\n\n  const program = getProgramFromFiles(paths, {\n    incremental: false,\n    isolatedModules: true,\n    lib: ['ES5'], // Skipping most libs speeds processing up a lot, we just need the primitive types anyway\n    noEmit: true,\n    noResolve: true,\n    skipLibCheck: true, // Skipping lib checks speeds things up\n    skipDefaultLibCheck: true,\n    strict: true,\n    typeRoots: [], // Do not include any additional types\n    types: [],\n  });\n\n  const tsSchemas = paths.map(path => {\n    let value;\n    try {\n      value = generateSchema(\n        program,\n        // All schemas should export a `Config` symbol\n        'Config',\n        // This enables usage of @visibility is doc comments\n        {\n          required: true,\n          validationKeywords: ['visibility'],\n        },\n        [path.split(sep).join('/')], // Unix paths are expected for all OSes here\n      ) as JsonObject | null;\n    } catch (error) {\n      if (error.message !== 'type Config not found') {\n        throw error;\n      }\n    }\n\n    if (!value) {\n      throw new Error(`Invalid schema in ${path}, missing Config export`);\n    }\n    return { path, value };\n  });\n\n  return tsSchemas;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonObject, JsonValue } from '@backstage/config';\nimport {\n  ConfigVisibility,\n  DEFAULT_CONFIG_VISIBILITY,\n  TransformFunc,\n} from './types';\n\n/**\n * This filters data by visibility by discovering the visibility of each\n * value, and then only keeping the ones that are specified in `includeVisibilities`.\n */\nexport function filterByVisibility(\n  data: JsonObject,\n  includeVisibilities: ConfigVisibility[],\n  visibilityByPath: Map<string, ConfigVisibility>,\n  transformFunc?: TransformFunc<number | string | boolean>,\n  withFilteredKeys?: boolean,\n): { data: JsonObject; filteredKeys?: string[] } {\n  const filteredKeys = new Array<string>();\n\n  function transform(\n    jsonVal: JsonValue,\n    visibilityPath: string, // Matches the format we get from ajv\n    filterPath: string, // Matches the format of the ConfigReader\n  ): JsonValue | undefined {\n    const visibility =\n      visibilityByPath.get(visibilityPath) ?? DEFAULT_CONFIG_VISIBILITY;\n    const isVisible = includeVisibilities.includes(visibility);\n\n    if (typeof jsonVal !== 'object') {\n      if (isVisible) {\n        if (transformFunc) {\n          return transformFunc(jsonVal, { visibility });\n        }\n        return jsonVal;\n      }\n      if (withFilteredKeys) {\n        filteredKeys.push(filterPath);\n      }\n      return undefined;\n    } else if (jsonVal === null) {\n      return undefined;\n    } else if (Array.isArray(jsonVal)) {\n      const arr = new Array<JsonValue>();\n\n      for (const [index, value] of jsonVal.entries()) {\n        const out = transform(\n          value,\n          `${visibilityPath}/${index}`,\n          `${filterPath}[${index}]`,\n        );\n        if (out !== undefined) {\n          arr.push(out);\n        }\n      }\n\n      if (arr.length > 0 || isVisible) {\n        return arr;\n      }\n      return undefined;\n    }\n\n    const outObj: JsonObject = {};\n    let hasOutput = false;\n\n    for (const [key, value] of Object.entries(jsonVal)) {\n      if (value === undefined) {\n        continue;\n      }\n      const out = transform(\n        value,\n        `${visibilityPath}/${key}`,\n        filterPath ? `${filterPath}.${key}` : key,\n      );\n      if (out !== undefined) {\n        outObj[key] = out;\n        hasOutput = true;\n      }\n    }\n\n    if (hasOutput || isVisible) {\n      return outObj;\n    }\n    return undefined;\n  }\n\n  return {\n    filteredKeys: withFilteredKeys ? filteredKeys : undefined,\n    data: (transform(data, '', '') as JsonObject) ?? {},\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppConfig, JsonObject } from '@backstage/config';\nimport { compileConfigSchemas } from './compile';\nimport { collectConfigSchemas } from './collect';\nimport { filterByVisibility } from './filtering';\nimport {\n  ConfigSchema,\n  ConfigSchemaPackageEntry,\n  CONFIG_VISIBILITIES,\n} from './types';\n\ntype Options =\n  | {\n      dependencies: string[];\n    }\n  | {\n      serialized: JsonObject;\n    };\n\n/**\n * Loads config schema for a Backstage instance.\n */\nexport async function loadConfigSchema(\n  options: Options,\n): Promise<ConfigSchema> {\n  let schemas: ConfigSchemaPackageEntry[];\n\n  if ('dependencies' in options) {\n    schemas = await collectConfigSchemas(options.dependencies);\n  } else {\n    const { serialized } = options;\n    if (serialized?.backstageConfigSchemaVersion !== 1) {\n      throw new Error(\n        'Serialized configuration schema is invalid or has an invalid version number',\n      );\n    }\n    schemas = serialized.schemas as ConfigSchemaPackageEntry[];\n  }\n\n  const validate = compileConfigSchemas(schemas);\n\n  return {\n    process(\n      configs: AppConfig[],\n      { visibility, valueTransform, withFilteredKeys } = {},\n    ): AppConfig[] {\n      const result = validate(configs);\n      if (result.errors) {\n        const error = new Error(\n          `Config validation failed, ${result.errors.join('; ')}`,\n        );\n        (error as any).messages = result.errors;\n        throw error;\n      }\n\n      let processedConfigs = configs;\n\n      if (visibility) {\n        processedConfigs = processedConfigs.map(({ data, context }) => ({\n          context,\n          ...filterByVisibility(\n            data,\n            visibility,\n            result.visibilityByPath,\n            valueTransform,\n            withFilteredKeys,\n          ),\n        }));\n      } else if (valueTransform) {\n        processedConfigs = processedConfigs.map(({ data, context }) => ({\n          context,\n          ...filterByVisibility(\n            data,\n            Array.from(CONFIG_VISIBILITIES),\n            result.visibilityByPath,\n            valueTransform,\n            withFilteredKeys,\n          ),\n        }));\n      }\n\n      return processedConfigs;\n    },\n    serialize(): JsonObject {\n      return {\n        schemas,\n        backstageConfigSchemaVersion: 1,\n      };\n    },\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs-extra';\nimport yaml from 'yaml';\nimport chokidar from 'chokidar';\nimport { resolve as resolvePath, dirname, isAbsolute, basename } from 'path';\nimport { AppConfig } from '@backstage/config';\nimport {\n  applyConfigTransforms,\n  readEnvConfig,\n  createIncludeTransform,\n  createSubstitutionTransform,\n} from './lib';\nimport { EnvFunc } from './lib/transform/types';\n\nexport type LoadConfigOptions = {\n  // The root directory of the config loading context. Used to find default configs.\n  configRoot: string;\n\n  // Absolute paths to load config files from. Configs from earlier paths have lower priority.\n  configPaths: string[];\n\n  /** @deprecated This option has been removed */\n  env?: string;\n\n  /**\n   * Custom environment variable loading function\n   *\n   * @experimental This API is not stable and may change at any point\n   */\n  experimentalEnvFunc?: EnvFunc;\n\n  /**\n   * An optional configuration that enables watching of config files.\n   */\n  watch?: {\n    /**\n     * A listener that is called when a config file is changed.\n     */\n    onChange: (configs: AppConfig[]) => void;\n\n    /**\n     * An optional signal that stops the watcher once the promise resolves.\n     */\n    stopSignal?: Promise<void>;\n  };\n};\n\nexport async function loadConfig(\n  options: LoadConfigOptions,\n): Promise<AppConfig[]> {\n  const { configRoot, experimentalEnvFunc: envFunc, watch } = options;\n  const configPaths = options.configPaths.slice();\n\n  // If no paths are provided, we default to reading\n  // `app-config.yaml` and, if it exists, `app-config.local.yaml`\n  if (configPaths.length === 0) {\n    configPaths.push(resolvePath(configRoot, 'app-config.yaml'));\n\n    const localConfig = resolvePath(configRoot, 'app-config.local.yaml');\n    if (await fs.pathExists(localConfig)) {\n      configPaths.push(localConfig);\n    }\n  }\n\n  const env = envFunc ?? (async (name: string) => process.env[name]);\n\n  const loadConfigFiles = async () => {\n    const configs = [];\n\n    for (const configPath of configPaths) {\n      if (!isAbsolute(configPath)) {\n        throw new Error(`Config load path is not absolute: '${configPath}'`);\n      }\n\n      const dir = dirname(configPath);\n      const readFile = (path: string) =>\n        fs.readFile(resolvePath(dir, path), 'utf8');\n\n      const input = yaml.parse(await readFile(configPath));\n      const substitutionTransform = createSubstitutionTransform(env);\n      const data = await applyConfigTransforms(dir, input, [\n        createIncludeTransform(env, readFile, substitutionTransform),\n        substitutionTransform,\n      ]);\n\n      configs.push({ data, context: basename(configPath) });\n    }\n\n    return configs;\n  };\n\n  let fileConfigs;\n  try {\n    fileConfigs = await loadConfigFiles();\n  } catch (error) {\n    throw new Error(\n      `Failed to read static configuration file, ${error.message}`,\n    );\n  }\n\n  const envConfigs = await readEnvConfig(process.env);\n\n  // Set up config file watching if requested by the caller\n  if (watch) {\n    let currentSerializedConfig = JSON.stringify(fileConfigs);\n\n    const watcher = chokidar.watch(configPaths, {\n      usePolling: process.env.NODE_ENV === 'test',\n    });\n    watcher.on('change', async () => {\n      try {\n        const newConfigs = await loadConfigFiles();\n        const newSerializedConfig = JSON.stringify(newConfigs);\n\n        if (currentSerializedConfig === newSerializedConfig) {\n          return;\n        }\n        currentSerializedConfig = newSerializedConfig;\n\n        watch.onChange([...newConfigs, ...envConfigs]);\n      } catch (error) {\n        console.error(`Failed to reload configuration files, ${error}`);\n      }\n    });\n\n    if (watch.stopSignal) {\n      watch.stopSignal.then(() => {\n        watcher.close();\n      });\n    }\n  }\n\n  return [...fileConfigs, ...envConfigs];\n}\n"],"names":["yaml","resolvePath","extname","path","dirname","Ajv","config","ConfigReader","mergeAllOf","fs","relativePath","getProgramFromFiles","generateSchema","sep","isAbsolute","basename","chokidar"],"mappings":"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"}