import { AppConfig, JsonObject } from '@backstage/config';
import { JSONSchema7 } from 'json-schema';

/**
 * Read runtime configuration from the environment.
 *
 * Only environment variables prefixed with APP_CONFIG_ will be considered.
 *
 * For each variable, the prefix will be removed, and rest of the key will
 * be split by '_'. Each part will then be used as keys to build up a nested
 * config object structure. The treatment of the entire environment variable
 * is case-sensitive.
 *
 * The value of the variable should be JSON serialized, as it will be parsed
 * and the type will be kept intact. For example "true" and true are treated
 * differently, as well as "42" and 42.
 *
 * For example, to set the config app.title to "My Title", use the following:
 *
 * APP_CONFIG_app_title='"My Title"'
 */
declare function readEnvConfig(env: {
    [name: string]: string | undefined;
}): AppConfig[];

declare type EnvFunc = (name: string) => Promise<string | undefined>;

/**
 * A list of all possible configuration value visibilities.
 */
declare const CONFIG_VISIBILITIES: readonly ["frontend", "backend", "secret"];
/**
 * A type representing the possible configuration value visibilities
 */
declare type ConfigVisibility = typeof CONFIG_VISIBILITIES[number];
/**
 * A function used to transform primitive configuration values.
 */
declare type TransformFunc<T extends number | string | boolean> = (value: T, context: {
    visibility: ConfigVisibility;
}) => T | undefined;
/**
 * Options used to process configuration data with a schema.
 */
declare type ConfigProcessingOptions = {
    /**
     * The visibilities that should be included in the output data.
     * If omitted, the data will not be filtered by visibility.
     */
    visibility?: ConfigVisibility[];
    /**
     * A transform function that can be used to transform primitive configuration values
     * during validation. The value returned from the transform function will be used
     * instead of the original value. If the transform returns `undefined`, the value
     * will be omitted.
     */
    valueTransform?: TransformFunc<any>;
    /**
     * Whether or not to include the `filteredKeys` property in the output `AppConfig`s.
     *
     * Default: `false`.
     */
    withFilteredKeys?: boolean;
};
/**
 * A loaded configuration schema that is ready to process configuration data.
 */
declare type ConfigSchema = {
    process(appConfigs: AppConfig[], options?: ConfigProcessingOptions): AppConfig[];
    serialize(): JsonObject;
};

/**
 * Given a list of configuration schemas from packages, merge them
 * into a single json schema.
 */
declare function mergeConfigSchemas(schemas: JSONSchema7[]): JSONSchema7;

declare type Options = {
    dependencies: string[];
} | {
    serialized: JsonObject;
};
/**
 * Loads config schema for a Backstage instance.
 */
declare function loadConfigSchema(options: Options): Promise<ConfigSchema>;

declare type LoadConfigOptions = {
    configRoot: string;
    configPaths: string[];
    /** @deprecated This option has been removed */
    env?: string;
    /**
     * Custom environment variable loading function
     *
     * @experimental This API is not stable and may change at any point
     */
    experimentalEnvFunc?: EnvFunc;
    /**
     * An optional configuration that enables watching of config files.
     */
    watch?: {
        /**
         * A listener that is called when a config file is changed.
         */
        onChange: (configs: AppConfig[]) => void;
        /**
         * An optional signal that stops the watcher once the promise resolves.
         */
        stopSignal?: Promise<void>;
    };
};
declare function loadConfig(options: LoadConfigOptions): Promise<AppConfig[]>;

export { ConfigSchema, ConfigVisibility, LoadConfigOptions, loadConfig, loadConfigSchema, mergeConfigSchemas, readEnvConfig };
