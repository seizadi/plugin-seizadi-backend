import { createRouteRef, createPlugin, createRoutableExtension, useApi, configApiRef, createApiRef, identityApiRef, SessionState, attachComponentData, featureFlagsApiRef, createApiFactory, discoveryApiRef, alertApiRef, errorApiRef, storageApiRef, oauthRequestApiRef, googleAuthApiRef, microsoftAuthApiRef, githubAuthApiRef, oktaAuthApiRef, gitlabAuthApiRef, auth0AuthApiRef, oauth2ApiRef, samlAuthApiRef, oneloginAuthApiRef, oidcAuthApiRef } from '@backstage/core-plugin-api';
import React, { createContext, useState, useEffect, useContext, useReducer, forwardRef, useCallback, useMemo } from 'react';
import pluralize from 'pluralize';
import { makeStyles, createStyles, lighten, getLuminance, darken, emphasize, Backdrop, CircularProgress, FormControl, FormControlLabel, Checkbox, Typography, Box, RadioGroup, Radio, Collapse, TextField, ThemeProvider, createTheme, Container, Button, ButtonBase, Paper, Slide, Divider, useTheme, Tooltip as Tooltip$1, Tabs, Tab, Menu, MenuItem, MenuList, Badge, ListItemIcon, ListItemText, Dialog, IconButton, FormGroup } from '@material-ui/core';
import '@material-ui/icons/AccessTime';
import '@material-ui/icons/Check';
import '@material-ui/icons/Delete';
import classnames from 'classnames';
import MoneyIcon from '@material-ui/icons/MonetizationOn';
import ActionIcon from '@material-ui/icons/Whatshot';
import Settings from '@material-ui/icons/Settings';
import AccountTree from '@material-ui/icons/AccountTree';
import Storage from '@material-ui/icons/Storage';
import Search from '@material-ui/icons/Search';
import CloudQueue from '@material-ui/icons/CloudQueue';
import School from '@material-ui/icons/School';
import ViewHeadline from '@material-ui/icons/ViewHeadline';
import { Alert } from '@material-ui/lab';
import { useNavigate, useLocation } from 'react-router-dom';
import qs from 'qs';
import * as yup from 'yup';
import { DateTime, Duration as Duration$1 } from 'luxon';
import '@material-ui/lab/Alert';
import CloseIcon from '@material-ui/icons/Close';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import ChevronLeftIcon from '@material-ui/icons/ChevronLeft';
import { Page, Header, Table, HeaderTabs, InfoCard, Lifecycle } from '@backstage/core-components';
import { ResponsiveContainer, BarChart as BarChart$1, Tooltip, CartesianGrid, XAxis, YAxis, Bar } from 'recharts';
import ChevronRightIcon from '@material-ui/icons/ChevronRight';
import LensIcon from '@material-ui/icons/Lens';
import HelpOutlineOutlinedIcon from '@material-ui/icons/HelpOutlineOutlined';
import 'react-use';
import '@material-ui/icons/AssignmentOutlined';
import '@material-ui/icons/AssignmentTurnedInOutlined';
import '@material-ui/icons/SentimentVeryDissatisfied';
import ArrowDropUp from '@material-ui/icons/ArrowDropUp';
import ArrowDropDown from '@material-ui/icons/ArrowDropDown';
import FullScreenIcon from '@material-ui/icons/Fullscreen';
import OAuth2Icon from '@material-ui/icons/AcUnit';
import '@backstage/config';
import '@backstage/theme';
import '@material-ui/icons/Brightness2';
import '@material-ui/icons/WbSunny';
import '@material-ui/icons/MenuBook';
import '@material-ui/icons/BrokenImage';
import '@material-ui/icons/Chat';
import '@material-ui/icons/Dashboard';
import '@material-ui/icons/Email';
import '@material-ui/icons/GitHub';
import '@material-ui/icons/Help';
import '@material-ui/icons/People';
import '@material-ui/icons/Person';
import '@material-ui/icons/Warning';
import '@material-ui/icons/Description';
import regression from 'regression';

const rootRouteRef = createRouteRef({
  path: "/cost-insights",
  title: "Cost Insights"
});
const projectGrowthAlertRef = createRouteRef({
  path: "/cost-insights/investigating-growth",
  title: "Investigating Growth"
});
const unlabeledDataflowAlertRef = createRouteRef({
  path: "/cost-insights/labeling-jobs",
  title: "Labeling Dataflow Jobs"
});
const costInsightsPlugin = createPlugin({
  id: "cost-insights",
  register({featureFlags}) {
    featureFlags.register("cost-insights-currencies");
  },
  routes: {
    root: rootRouteRef,
    growthAlerts: projectGrowthAlertRef,
    unlabeledDataflowAlerts: unlabeledDataflowAlertRef
  }
});
const CostInsightsPage = costInsightsPlugin.provide(createRoutableExtension({
  component: () => import('./index-02caa178.esm.js').then((m) => m.CostInsightsPage),
  mountPoint: rootRouteRef
}));
const CostInsightsProjectGrowthInstructionsPage = costInsightsPlugin.provide(createRoutableExtension({
  component: () => import('./index-acde8070.esm.js').then((m) => m.ProjectGrowthInstructionsPage),
  mountPoint: projectGrowthAlertRef
}));
const CostInsightsLabelDataflowInstructionsPage = costInsightsPlugin.provide(createRoutableExtension({
  component: () => import('./index-51852030.esm.js').then((m) => m.LabelDataflowInstructionsPage),
  mountPoint: unlabeledDataflowAlertRef
}));

var Duration;
(function(Duration2) {
  Duration2["P7D"] = "P7D";
  Duration2["P30D"] = "P30D";
  Duration2["P90D"] = "P90D";
  Duration2["P3M"] = "P3M";
})(Duration || (Duration = {}));
const DEFAULT_DATE_FORMAT = "yyyy-LL-dd";

var AlertStatus;
(function(AlertStatus2) {
  AlertStatus2["Snoozed"] = "snoozed";
  AlertStatus2["Accepted"] = "accepted";
  AlertStatus2["Dismissed"] = "dismissed";
})(AlertStatus || (AlertStatus = {}));
var AlertDismissReason;
(function(AlertDismissReason2) {
  AlertDismissReason2["Other"] = "other";
  AlertDismissReason2["Resolved"] = "resolved";
  AlertDismissReason2["Expected"] = "expected";
  AlertDismissReason2["Seasonal"] = "seasonal";
  AlertDismissReason2["Migration"] = "migration";
  AlertDismissReason2["NotApplicable"] = "not-applicable";
})(AlertDismissReason || (AlertDismissReason = {}));
const AlertDismissOptions = [
  {
    reason: AlertDismissReason.Resolved,
    label: "This action item is now resolved."
  },
  {
    reason: AlertDismissReason.Seasonal,
    label: "This is an expected increase at this time of year."
  },
  {
    reason: AlertDismissReason.Migration,
    label: "This increase is from a migration in process."
  },
  {
    reason: AlertDismissReason.Expected,
    label: "This is an expected increase due to our team\u2019s priorities."
  },
  {
    reason: AlertDismissReason.NotApplicable,
    label: "This action item doesn\u2019t make sense for my team."
  },
  {
    reason: AlertDismissReason.Other,
    label: "Other (please specify)"
  }
];
const AlertSnoozeOptions = [
  {
    duration: Duration.P7D,
    label: "1 Week"
  },
  {
    duration: Duration.P30D,
    label: "1 Month"
  },
  {
    duration: Duration.P90D,
    label: "1 Quarter"
  }
];
var DataKey;
(function(DataKey2) {
  DataKey2["Previous"] = "previous";
  DataKey2["Current"] = "current";
  DataKey2["Name"] = "name";
})(DataKey || (DataKey = {}));

const EngineerThreshold = 0.5;
var ChangeThreshold;
(function(ChangeThreshold2) {
  ChangeThreshold2[ChangeThreshold2["upper"] = 0.05] = "upper";
  ChangeThreshold2[ChangeThreshold2["lower"] = -0.05] = "lower";
})(ChangeThreshold || (ChangeThreshold = {}));
var GrowthType;
(function(GrowthType2) {
  GrowthType2[GrowthType2["Negligible"] = 0] = "Negligible";
  GrowthType2[GrowthType2["Savings"] = 1] = "Savings";
  GrowthType2[GrowthType2["Excess"] = 2] = "Excess";
})(GrowthType || (GrowthType = {}));

var CurrencyType;
(function(CurrencyType2) {
  CurrencyType2["USD"] = "USD";
  CurrencyType2["CarbonOffsetTons"] = "CARBON_OFFSET_TONS";
  CurrencyType2["Beers"] = "BEERS";
  CurrencyType2["IceCream"] = "PINTS_OF_ICE_CREAM";
})(CurrencyType || (CurrencyType = {}));

var IconType;
(function(IconType2) {
  IconType2["Compute"] = "compute";
  IconType2["Data"] = "data";
  IconType2["Database"] = "database";
  IconType2["Storage"] = "storage";
  IconType2["Search"] = "search";
  IconType2["ML"] = "ml";
})(IconType || (IconType = {}));

var DefaultNavigation;
(function(DefaultNavigation2) {
  DefaultNavigation2["CostOverviewCard"] = "cost-overview-card";
  DefaultNavigation2["AlertInsightsHeader"] = "alert-insights-header";
})(DefaultNavigation || (DefaultNavigation = {}));
const getDefaultNavigationItems = (alerts) => {
  const items = [
    {
      navigation: DefaultNavigation.CostOverviewCard,
      icon: /* @__PURE__ */ React.createElement(MoneyIcon, null),
      title: "Cost Overview"
    }
  ];
  if (alerts > 0) {
    items.push({
      navigation: DefaultNavigation.AlertInsightsHeader,
      icon: /* @__PURE__ */ React.createElement(ActionIcon, null),
      title: "Action Items"
    });
  }
  return items;
};
function getIcon(icon) {
  switch (icon) {
    case IconType.Compute:
      return /* @__PURE__ */ React.createElement(Settings, null);
    case IconType.Data:
      return /* @__PURE__ */ React.createElement(AccountTree, null);
    case IconType.Database:
      return /* @__PURE__ */ React.createElement(ViewHeadline, null);
    case IconType.Storage:
      return /* @__PURE__ */ React.createElement(Storage, null);
    case IconType.Search:
      return /* @__PURE__ */ React.createElement(Search, null);
    case IconType.ML:
      return /* @__PURE__ */ React.createElement(School, null);
    default:
      return /* @__PURE__ */ React.createElement(CloudQueue, null);
  }
}

function validateMetrics(metrics) {
  const defaults = metrics.filter((metric) => metric.default);
  if (defaults.length > 1) {
    throw new Error(`Only one default metric can be set at a time. Found ${defaults.length}`);
  }
}

function notEmpty(value) {
  return !isNull(value) && !isUndefined(value);
}
function isUndefined(value) {
  return value === void 0;
}
function isNull(value) {
  return value === null;
}
function assertNever$7(x) {
  throw new Error(`Exhaustiveness check failed: ${x}`);
}
function assertAlways(argument) {
  if (argument === void 0) {
    throw new TypeError("Expected to always find a value but received undefined");
  }
  return argument;
}
function findAlways(collection, callback) {
  return assertAlways(collection.find(callback));
}
function findAnyKey(record) {
  return Object.keys(record != null ? record : {}).find((_) => true);
}

const rateOf = (cost, duration) => {
  switch (duration) {
    case Duration.P30D:
      return cost / 12;
    case Duration.P7D:
    case Duration.P90D:
    case Duration.P3M:
      return cost / 4;
    default:
      return assertNever$7(duration);
  }
};
const defaultCurrencies = [
  {
    kind: null,
    label: "Engineers \u{1F6E0}",
    unit: "engineer"
  },
  {
    kind: CurrencyType.USD,
    label: "US Dollars \u{1F4B5}",
    unit: "dollar",
    prefix: "$",
    rate: 1
  },
  {
    kind: CurrencyType.CarbonOffsetTons,
    label: "Carbon Offset Tons \u267B\uFE0F\u2696\uFE0Fs",
    unit: "carbon offset ton",
    rate: 3.5
  },
  {
    kind: CurrencyType.Beers,
    label: "Beers \u{1F37A}",
    unit: "beer",
    rate: 4.5
  },
  {
    kind: CurrencyType.IceCream,
    label: "Pints of Ice Cream \u{1F366}",
    unit: "ice cream pint",
    rate: 5.5
  }
];

const ConfigContext = createContext(void 0);
const defaultState = {
  metrics: [],
  products: [],
  icons: [],
  engineerCost: 0,
  currencies: defaultCurrencies
};
const ConfigProvider = ({children}) => {
  const c = useApi(configApiRef);
  const [config, setConfig] = useState(defaultState);
  const [loading, setLoading] = useState(true);
  useEffect(() => {
    function getProducts() {
      const products = c.getConfig("costInsights.products");
      return products.keys().map((key) => ({
        kind: key,
        name: products.getString(`${key}.name`),
        aggregation: [0, 0]
      }));
    }
    function getMetrics() {
      const metrics = c.getOptionalConfig("costInsights.metrics");
      if (metrics) {
        return metrics.keys().map((key) => {
          var _a;
          return {
            kind: key,
            name: metrics.getString(`${key}.name`),
            default: (_a = metrics.getOptionalBoolean(`${key}.default`)) != null ? _a : false
          };
        });
      }
      return [];
    }
    function getIcons() {
      const products = c.getConfig("costInsights.products");
      const keys = products.keys();
      return keys.map((k) => ({
        kind: k,
        component: getIcon(products.getOptionalString(`${k}.icon`))
      }));
    }
    function getEngineerCost() {
      return c.getNumber("costInsights.engineerCost");
    }
    function getConfig() {
      const products = getProducts();
      const metrics = getMetrics();
      const engineerCost = getEngineerCost();
      const icons = getIcons();
      validateMetrics(metrics);
      setConfig((prevState) => ({
        ...prevState,
        metrics,
        products,
        engineerCost,
        icons
      }));
      setLoading(false);
    }
    getConfig();
  }, []);
  if (loading) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(ConfigContext.Provider, {
    value: config
  }, children);
};
function useConfig() {
  const config = useContext(ConfigContext);
  return config ? config : assertNever$6();
}
function assertNever$6() {
  throw new Error("Cannot use useConfig outside of ConfigProvider");
}

const CurrencyContext = React.createContext(void 0);
const CurrencyProvider = ({children}) => {
  const engineers = findAlways(defaultCurrencies, (c) => c.kind === null);
  const [currency, setCurrency] = useState(engineers);
  return /* @__PURE__ */ React.createElement(CurrencyContext.Provider, {
    value: {currency, setCurrency}
  }, children);
};
function useCurrency() {
  const context = useContext(CurrencyContext);
  if (!context) {
    assertNever$5();
  }
  return [context.currency, context.setCurrency];
}
function assertNever$5() {
  throw Error("Cannot use useCurrency outside of CurrencyProvider");
}

function getDefaultPageFilters(groups) {
  return {
    group: groups.length ? groups[0].id : null,
    project: null,
    duration: Duration.P90D,
    metric: null
  };
}

const schema = yup.object().shape({
  group: yup.string().nullable(),
  project: yup.string().nullable()
}).required();
const stringify = (queryParams) => qs.stringify(queryParams, {strictNullHandling: true});
const parse = (queryString) => qs.parse(queryString, {ignoreQueryPrefix: true, strictNullHandling: true});
const validate = (queryString) => {
  return schema.validate(parse(queryString), {
    stripUnknown: true,
    strict: true
  });
};
const getInitialPageState = (groups, queryParams = {}) => {
  return {
    ...getDefaultPageFilters(groups),
    ...queryParams.project ? {project: queryParams.project} : {},
    ...queryParams.group ? {group: queryParams.group} : {}
  };
};
const getInitialProductState = (config) => config.products.map((product) => ({
  productType: product.kind,
  duration: Duration.P30D
}));

const costInsightsApiRef = createApiRef({
  id: "plugin.costinsights.service",
  description: "Provides cost data and alerts for the cost-insights plugin"
});

const DEFAULT_DURATION = Duration.P30D;
function inclusiveStartDateOf(duration, inclusiveEndDate) {
  switch (duration) {
    case Duration.P7D:
    case Duration.P30D:
    case Duration.P90D:
      return DateTime.fromISO(inclusiveEndDate).minus(Duration$1.fromISO(duration).plus(Duration$1.fromISO(duration))).toFormat(DEFAULT_DATE_FORMAT);
    case Duration.P3M:
      return DateTime.fromISO(inclusiveEndDate).startOf("quarter").minus(Duration$1.fromISO(duration).plus(Duration$1.fromISO(duration))).toFormat(DEFAULT_DATE_FORMAT);
    default:
      return assertNever$7(duration);
  }
}
function exclusiveEndDateOf(duration, inclusiveEndDate) {
  switch (duration) {
    case Duration.P7D:
    case Duration.P30D:
    case Duration.P90D:
      return DateTime.fromISO(inclusiveEndDate).plus({days: 1}).toFormat(DEFAULT_DATE_FORMAT);
    case Duration.P3M:
      return DateTime.fromISO(quarterEndDate(inclusiveEndDate)).plus({days: 1}).toFormat(DEFAULT_DATE_FORMAT);
    default:
      return assertNever$7(duration);
  }
}
function inclusiveEndDateOf(duration, inclusiveEndDate) {
  return DateTime.fromISO(exclusiveEndDateOf(duration, inclusiveEndDate)).minus({days: 1}).toFormat(DEFAULT_DATE_FORMAT);
}
function intervalsOf(duration, inclusiveEndDate, repeating = 2) {
  return `R${repeating}/${duration}/${exclusiveEndDateOf(duration, inclusiveEndDate)}`;
}
function quarterEndDate(inclusiveEndDate) {
  const endDate = DateTime.fromISO(inclusiveEndDate);
  const endOfQuarter = endDate.endOf("quarter").toFormat(DEFAULT_DATE_FORMAT);
  if (endOfQuarter === inclusiveEndDate) {
    return endDate.toFormat(DEFAULT_DATE_FORMAT);
  }
  return endDate.startOf("quarter").minus({days: 1}).toFormat(DEFAULT_DATE_FORMAT);
}

var DefaultLoadingAction;
(function(DefaultLoadingAction2) {
  DefaultLoadingAction2["UserGroups"] = "user-groups";
  DefaultLoadingAction2["LastCompleteBillingDate"] = "billing-date";
  DefaultLoadingAction2["CostInsightsInitial"] = "cost-insights-initial";
  DefaultLoadingAction2["CostInsightsPage"] = "cost-insights-page";
  DefaultLoadingAction2["CostInsightsProducts"] = "cost-insights-products";
  DefaultLoadingAction2["CostInsightsAlerts"] = "cost-insights-alerts";
})(DefaultLoadingAction || (DefaultLoadingAction = {}));
const INITIAL_LOADING_ACTIONS = [
  DefaultLoadingAction.UserGroups,
  DefaultLoadingAction.CostInsightsInitial,
  DefaultLoadingAction.CostInsightsProducts
];
const getDefaultState = (loadingActions) => {
  return loadingActions.reduce((defaultState, action) => ({...defaultState, [action]: true}), {});
};
const getResetState = (loadingActions) => {
  return loadingActions.reduce((defaultState, action) => ({...defaultState, [action]: false}), {});
};
const getResetStateWithoutInitial = (loadingActions) => {
  return loadingActions.reduce((defaultState, action) => {
    const loadingActionState = INITIAL_LOADING_ACTIONS.includes(action) ? false : true;
    return {...defaultState, [action]: loadingActionState};
  }, {});
};
const settledResponseOf = (responses) => {
  return responses.map((response) => response.status === "fulfilled" ? response.value : null);
};
const initialStatesOf = (products, responses) => {
  return products.map((product, index) => ({
    entity: responses[index],
    product,
    duration: DEFAULT_DURATION
  }));
};

const costInsightsLightTheme = {
  palette: {
    blue: "#509AF5",
    lightBlue: "#9BF0E1",
    darkBlue: "#4101F5",
    magenta: "#DC148C",
    yellow: "#FFC864",
    tooltip: {
      background: "#171717",
      color: "#DDD"
    },
    navigationText: "#b5b5b5",
    alertBackground: "rgba(219, 219, 219, 0.13)",
    dataViz: [
      "#509BF5",
      "#4B917D",
      "#FF6437",
      "#F573A0",
      "#F59B23",
      "#B49BC8",
      "#C39687",
      "#A0C3D2",
      "#FFC864",
      "#BABABA"
    ]
  }
};
const costInsightsDarkTheme = {
  palette: {
    blue: "#77b8f9",
    lightBlue: "#d8f9f4",
    darkBlue: "#b595fd",
    magenta: "#ee93cd",
    yellow: "#fff2da",
    tooltip: {
      background: "#EEE",
      color: "#424242"
    },
    navigationText: "#b5b5b5",
    alertBackground: "rgba(32, 32, 32, 0.13)",
    dataViz: [
      "#8accff",
      "#7bc2ac",
      "#ff9664",
      "#ffa5d1",
      "#ffcc57",
      "#e6ccfb",
      "#f7c7b7",
      "#d2f6ff",
      "#fffb94",
      "#ececec"
    ]
  }
};
function brighten(color, coefficient = 0.2) {
  return getLuminance(color) > 0.5 ? lighten(color, coefficient) : darken(color, coefficient);
}
const useCostOverviewStyles = (theme) => ({
  axis: {
    fill: theme.palette.text.primary
  },
  container: {
    height: 450,
    width: 1200
  },
  cartesianGrid: {
    stroke: theme.palette.textVerySubtle
  },
  chart: {
    margin: {
      right: 30,
      top: 16
    }
  },
  yAxis: {
    width: 75
  }
});
const useOverviewTabsStyles = makeStyles((theme) => ({
  default: {
    padding: theme.spacing(2),
    fontWeight: theme.typography.fontWeightBold,
    color: theme.palette.text.secondary,
    textTransform: "uppercase"
  },
  selected: {
    color: theme.palette.text.primary
  }
}));
const useBarChartStyles = (theme) => ({
  axis: {
    fill: theme.palette.text.primary
  },
  barChart: {
    margin: {
      left: 16,
      right: 16
    }
  },
  cartesianGrid: {
    stroke: theme.palette.textVerySubtle
  },
  cursor: {
    fill: theme.palette.textVerySubtle,
    fillOpacity: 0.3
  },
  container: {
    height: 400,
    width: 1200
  },
  infoIcon: {
    marginLeft: 2,
    fontSize: "1.25em"
  },
  xAxis: {
    height: 50
  }
});
const useBarChartLayoutStyles = makeStyles((theme) => createStyles({
  wrapper: {
    display: "flex",
    flexDirection: "column"
  },
  legend: {
    paddingBottom: theme.spacing(2)
  }
}));
const useBarChartStepperButtonStyles = makeStyles((theme) => createStyles({
  root: {
    ...theme.typography.button,
    boxSizing: "border-box",
    transition: theme.transitions.create(["background-color", "box-shadow", "border"], {
      duration: theme.transitions.duration.short
    }),
    borderRadius: "50%",
    padding: 0,
    width: 40,
    height: 40,
    boxShadow: theme.shadows[6],
    "&:active": {
      boxShadow: theme.shadows[12]
    },
    color: theme.palette.text.primary,
    backgroundColor: lighten(theme.palette.background.default, 0.1),
    "&:hover": {
      backgroundColor: lighten(theme.palette.background.default, 0.2),
      textDecoration: "none"
    }
  }
}));
const useBarChartLabelStyles = makeStyles((theme) => createStyles({
  foreignObject: {
    textAlign: "center"
  },
  label: {
    fontWeight: theme.typography.fontWeightBold,
    display: "block",
    textDecoration: "none",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  },
  infoIcon: {
    marginLeft: 2,
    fontSize: "1.25em"
  },
  button: {
    textTransform: "none",
    fontWeight: theme.typography.fontWeightBold,
    fontSize: theme.typography.fontSize
  }
}));
const useCostInsightsStyles = makeStyles((theme) => ({
  h6Subtle: {
    ...theme.typography.h6,
    fontWeight: "normal",
    color: theme.palette.textSubtle
  }
}));
const useCostInsightsTabsStyles = makeStyles((theme) => ({
  tabs: {
    borderBottom: `1px solid ${theme.palette.textVerySubtle}`,
    backgroundColor: brighten(theme.palette.background.default),
    padding: theme.spacing(0, 4)
  },
  tab: {
    minHeight: 68,
    minWidth: 180,
    padding: theme.spacing(1, 4),
    "&:hover": {
      color: "inherit",
      backgroundColor: "inherit"
    }
  },
  indicator: {
    backgroundColor: theme.palette.navigation.indicator,
    height: 4
  },
  tabLabel: {
    display: "flex",
    alignItems: "center"
  },
  tabLabelText: {
    fontSize: theme.typography.fontSize,
    fontWeight: theme.typography.fontWeightBold
  },
  menuItem: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    minWidth: 180,
    padding: theme.spacing(2, 2)
  },
  menuItemSelected: {
    backgroundColor: lighten(theme.palette.background.default, 0.3)
  }
}));
makeStyles((theme) => createStyles({
  root: {
    paddingBottom: theme.spacing(2),
    borderRadius: "unset"
  },
  title: {
    fontSize: theme.typography.fontSize,
    fontWeight: theme.typography.fontWeightBold,
    lineHeight: 1.5
  },
  action: {
    margin: 0
  }
}));
const useCostGrowthStyles = makeStyles((theme) => createStyles({
  excess: {
    color: theme.palette.status.error
  },
  savings: {
    color: theme.palette.status.ok
  },
  indicator: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-end"
  }
}));
const useCostGrowthLegendStyles = makeStyles((theme) => ({
  h5: {
    ...theme.typography.h5,
    fontWeight: 500,
    padding: 0
  },
  marker: {
    display: "inherit",
    marginRight: theme.spacing(1)
  },
  helpIcon: {
    display: "inherit"
  },
  title: {
    ...theme.typography.overline,
    fontWeight: 500,
    lineHeight: 0,
    marginRight: theme.spacing(1),
    color: theme.palette.textSubtle
  },
  tooltip: {
    display: "block",
    padding: theme.spacing(1),
    backgroundColor: theme.palette.navigation.background
  },
  tooltipText: {
    color: theme.palette.background.default,
    fontSize: theme.typography.fontSize,
    lineHeight: 1.5
  }
}));
const useBarChartStepperStyles = makeStyles((theme) => createStyles({
  paper: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-around",
    alignItems: "center",
    background: "transparent",
    padding: 8
  },
  step: {
    backgroundColor: theme.palette.action.disabled,
    borderRadius: "50%",
    width: 9,
    height: 9,
    margin: "0 2px"
  },
  stepActive: {
    backgroundColor: theme.palette.primary.main
  },
  steps: {
    display: "flex",
    flexDirection: "row"
  },
  backButton: {
    position: "absolute",
    left: 0,
    top: "calc(50% - 60px)",
    zIndex: 100
  },
  nextButton: {
    position: "absolute",
    right: 0,
    top: "calc(50% - 60px)",
    zIndex: 100
  }
}));
const useNavigationStyles = makeStyles((theme) => createStyles({
  menuList: {
    borderRadius: theme.shape.borderRadius,
    backgroundColor: theme.palette.navigation.background,
    minWidth: 250
  },
  menuItem: {
    background: "transparent",
    border: 0,
    textTransform: "none",
    width: "100%",
    minHeight: theme.spacing(6),
    margin: theme.spacing(0.5, 2, 0.5, 0)
  },
  listItemIcon: {
    minWidth: 40
  },
  navigationIcon: {
    fill: theme.palette.navigationText
  },
  title: {
    whiteSpace: "nowrap",
    lineHeight: 1,
    color: theme.palette.navigationText,
    fontWeight: theme.typography.fontWeightBold
  }
}));
const useTooltipStyles = makeStyles((theme) => createStyles({
  tooltip: {
    backgroundColor: theme.palette.tooltip.background,
    borderRadius: theme.shape.borderRadius,
    boxShadow: theme.shadows[1],
    color: theme.palette.tooltip.color,
    fontSize: theme.typography.fontSize,
    minWidth: 300
  },
  maxWidth: {
    maxWidth: 300
  },
  actions: {
    padding: theme.spacing(2)
  },
  header: {
    padding: theme.spacing(2)
  },
  content: {
    padding: theme.spacing(2)
  },
  lensIcon: {
    fontSize: `.75rem`
  },
  divider: {
    backgroundColor: emphasize(theme.palette.divider, 1)
  },
  truncate: {
    maxWidth: 200,
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis"
  },
  subtitle: {
    fontStyle: "italic"
  }
}));
const useAlertInsightsSectionStyles = makeStyles((theme) => createStyles({
  button: {
    backgroundColor: theme.palette.textVerySubtle,
    color: theme.palette.text.primary
  }
}));
const useSelectStyles = makeStyles((theme) => createStyles({
  select: {
    minWidth: 200,
    textAlign: "start",
    backgroundColor: theme.palette.background.paper
  },
  menuItem: {
    minWidth: 200,
    padding: theme.spacing(2),
    "&.compact": {
      padding: theme.spacing(1, 2)
    }
  }
}));
const useActionItemCardStyles = makeStyles((theme) => createStyles({
  card: {
    boxShadow: "none"
  },
  avatar: {
    backgroundColor: theme.palette.textVerySubtle,
    color: theme.palette.text.primary
  },
  root: {
    minHeight: 80,
    paddingBottom: theme.spacing(2),
    borderRadius: theme.shape.borderRadius
  },
  activeRoot: {
    cursor: "pointer",
    transition: theme.transitions.create("background", {
      duration: theme.transitions.duration.short
    }),
    "&:hover": {
      background: theme.palette.alertBackground
    }
  },
  action: {
    margin: 0
  },
  title: {
    fontSize: theme.typography.fontSize,
    fontWeight: theme.typography.fontWeightBold
  }
}));
const useProductInsightsCardStyles = makeStyles((theme) => createStyles({
  root: {
    padding: theme.spacing(2, 2, 2, 2.5)
  },
  action: {
    margin: 0
  }
}));
const useProductInsightsChartStyles = makeStyles((theme) => createStyles({
  indicator: {
    fontWeight: theme.typography.fontWeightBold,
    fontSize: "1.25rem"
  },
  actions: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center"
  }
}));
const useBackdropStyles = makeStyles((theme) => createStyles({
  root: {
    zIndex: theme.zIndex.modal
  }
}));
const useSubtleTypographyStyles = makeStyles((theme) => createStyles({
  root: {
    color: theme.palette.textSubtle
  }
}));
const useEntityDialogStyles = makeStyles((theme) => createStyles({
  dialogContent: {
    padding: 0
  },
  dialogTitle: {
    padding: 0
  },
  closeButton: {
    position: "absolute",
    right: theme.spacing(1),
    top: theme.spacing(1),
    color: theme.palette.grey[500],
    zIndex: 100
  },
  row: {
    fontSize: theme.typography.fontSize * 1.25
  },
  rowTotal: {
    fontWeight: theme.typography.fontWeightBold
  },
  colFirst: {
    paddingLeft: theme.spacing(2)
  },
  colLast: {
    paddingRight: theme.spacing(2)
  },
  column: {
    fontWeight: theme.typography.fontWeightBold
  },
  growth: {
    display: "flex",
    flexDirection: "row",
    alignContent: "center",
    justifyContent: "flex-end"
  }
}));
const useAlertDialogStyles = makeStyles((theme) => createStyles({
  content: {
    padding: theme.spacing(0, 5, 2, 5)
  },
  actions: {
    padding: theme.spacing(2, 5)
  },
  radio: {
    margin: theme.spacing(-0.5, 0, -0.5, 0)
  },
  icon: {
    color: theme.palette.primary.dark,
    margin: theme.spacing(2.5, 2.5, 0, 0),
    padding: 0
  }
}));
const useAlertStatusSummaryButtonStyles = makeStyles(() => ({
  icon: {
    transform: "transform 5s"
  },
  clicked: {
    transform: "rotate(180deg)"
  }
}));

const LoadingContext = createContext(void 0);
function reducer(prevState, action) {
  return {
    ...prevState,
    ...action
  };
}
const LoadingProvider = ({children}) => {
  const classes = useBackdropStyles();
  const actions = INITIAL_LOADING_ACTIONS;
  const [state, dispatch] = useReducer(reducer, getDefaultState(actions));
  const [isBackdropVisible, setBackdropVisible] = useState(false);
  useEffect(() => {
    function displayLoadingBackdrop() {
      setBackdropVisible(!state[DefaultLoadingAction.CostInsightsInitial] && Object.values(state).some((l) => l));
    }
    displayLoadingBackdrop();
  }, [state, setBackdropVisible]);
  return /* @__PURE__ */ React.createElement(LoadingContext.Provider, {
    value: {state, actions, dispatch}
  }, children, /* @__PURE__ */ React.createElement(Backdrop, {
    open: isBackdropVisible,
    classes
  }, /* @__PURE__ */ React.createElement(CircularProgress, null)));
};
function useLoading(mapLoadingToProps) {
  const context = useContext(LoadingContext);
  if (!context) {
    assertNever$4();
  }
  return mapLoadingToProps({
    state: context.state,
    actions: context.actions,
    dispatch: context.dispatch
  });
}
function assertNever$4() {
  throw Error("useLoading cannot be used outside of LoadingProvider");
}

const mapLoadingToProps$2 = ({
  dispatch
}) => ({
  dispatchLoadingGroups: (isLoading) => dispatch({[DefaultLoadingAction.UserGroups]: isLoading})
});
const GroupsContext = React.createContext(void 0);
const GroupsProvider = ({children}) => {
  const userId = useApi(identityApiRef).getUserId();
  const client = useApi(costInsightsApiRef);
  const [error, setError] = useState(null);
  const {dispatchLoadingGroups} = useLoading(mapLoadingToProps$2);
  const [groups, setGroups] = useState(null);
  useEffect(() => {
    dispatchLoadingGroups(true);
    async function getUserGroups() {
      try {
        const g = await client.getUserGroups(userId);
        setGroups(g);
      } catch (e) {
        setError(e);
      } finally {
        dispatchLoadingGroups(false);
      }
    }
    getUserGroups();
  }, [userId, client]);
  if (error) {
    return /* @__PURE__ */ React.createElement(Alert, {
      severity: "error"
    }, error.message);
  }
  if (!groups)
    return null;
  return /* @__PURE__ */ React.createElement(GroupsContext.Provider, {
    value: {groups}
  }, children);
};
function useGroups() {
  const context = useContext(GroupsContext);
  return context ? context.groups : assertNever$3();
}
function assertNever$3() {
  throw Error("Cannot use useGroups outside of GroupsProvider");
}

const FilterContext = React.createContext(void 0);
const FilterProvider = ({children}) => {
  const config = useConfig();
  const navigate = useNavigate();
  const location = useLocation();
  const groups = useGroups();
  const [error, setError] = useState(null);
  const [pageFilters, setPageFilters] = useState(null);
  const [productFilters, setProductFilters] = useState(null);
  useEffect(() => {
    async function setPageFiltersFromLocation() {
      var _a, _b;
      try {
        const queryParams = await validate(location.search);
        const defaultMetric = (_b = (_a = config.metrics.find((m) => m.default)) == null ? void 0 : _a.kind) != null ? _b : null;
        const initialPageState = getInitialPageState(groups, queryParams);
        const initialProductState = getInitialProductState(config);
        setProductFilters(initialProductState);
        setPageFilters({...initialPageState, metric: defaultMetric});
      } catch (e) {
        setError(e);
      }
    }
    setPageFiltersFromLocation();
  }, [groups]);
  useEffect(() => {
    function setLocationFromPageFilters(filters) {
      const queryString = stringify({
        group: filters.group,
        ...filters.project ? {project: filters.project} : {}
      });
      navigate({...location, search: `?${queryString}`});
    }
    if (pageFilters) {
      setLocationFromPageFilters(pageFilters);
    }
  }, [pageFilters]);
  if (error) {
    return /* @__PURE__ */ React.createElement(Alert, {
      severity: "error"
    }, error.message);
  }
  if (!pageFilters || !productFilters) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(FilterContext.Provider, {
    value: {pageFilters, productFilters, setPageFilters, setProductFilters}
  }, children);
};
function useFilters(mapFiltersToProps) {
  const context = useContext(FilterContext);
  return context ? mapFiltersToProps(context) : assertNever$2();
}
function assertNever$2() {
  throw Error("Cannot use useFilters outside of FilterProvider");
}

const ScrollContext = React.createContext(void 0);
const ScrollProvider = ({children}) => {
  const [scroll, setScroll] = useState(null);
  return /* @__PURE__ */ React.createElement(ScrollContext.Provider, {
    value: {scroll, setScroll}
  }, children);
};
var ScrollType;
(function(ScrollType2) {
  ScrollType2["AlertSummary"] = "alert-status-summary";
})(ScrollType || (ScrollType = {}));
function useScroll() {
  const context = useContext(ScrollContext);
  if (!context) {
    assertNever$1();
  }
  return [context.scroll, context.setScroll];
}
function assertNever$1() {
  throw new Error(`Cannot use useScroll outside ScrollProvider`);
}

const mapLoadingToProps$1 = ({
  dispatch
}) => ({
  dispatchLoadingBillingDate: (isLoading) => dispatch({[DefaultLoadingAction.LastCompleteBillingDate]: isLoading})
});
const BillingDateContext = React.createContext(void 0);
const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
const dateFormatSchema = yup.string().matches(dateRegex, {
  message: "Unsupported billing date format: ${value}. Date should be in YYYY-MM-DD format.",
  excludeEmptyString: true
});
const BillingDateProvider = ({children}) => {
  const client = useApi(costInsightsApiRef);
  const [error, setError] = useState(null);
  const {dispatchLoadingBillingDate} = useLoading(mapLoadingToProps$1);
  const [lastCompleteBillingDate, setLastCompeteBillingDate] = useState(null);
  useEffect(() => {
    dispatchLoadingBillingDate(true);
    async function getLastCompleteBillingDate() {
      try {
        const d = await client.getLastCompleteBillingDate();
        const validDate = await dateFormatSchema.validate(d);
        if (validDate)
          setLastCompeteBillingDate(validDate);
      } catch (e) {
        setError(e);
      } finally {
        dispatchLoadingBillingDate(false);
      }
    }
    getLastCompleteBillingDate();
  }, [client]);
  if (error) {
    return /* @__PURE__ */ React.createElement(Alert, {
      severity: "error"
    }, error.message);
  }
  if (!lastCompleteBillingDate)
    return null;
  return /* @__PURE__ */ React.createElement(BillingDateContext.Provider, {
    value: {
      lastCompleteBillingDate
    }
  }, children);
};
function useLastCompleteBillingDate() {
  const context = useContext(BillingDateContext);
  return context ? context.lastCompleteBillingDate : assertNever();
}
function assertNever() {
  throw Error("Cannot use useLastCompleteBillingDate outside of BillingDateProvider");
}

const AlertAcceptForm = forwardRef(({onSubmit, disableSubmit}, ref) => {
  const [checked, setChecked] = useState(false);
  const onFormSubmit = (e) => {
    e.preventDefault();
    onSubmit(null);
  };
  const onChecked = (_, isChecked) => {
    setChecked(isChecked);
    disableSubmit(!isChecked);
  };
  return /* @__PURE__ */ React.createElement("form", {
    ref,
    onSubmit: onFormSubmit
  }, /* @__PURE__ */ React.createElement(FormControl, {
    component: "fieldset",
    fullWidth: true
  }, /* @__PURE__ */ React.createElement(FormControlLabel, {
    label: "My team can commit to making this change soon, or has already.",
    value: checked,
    control: /* @__PURE__ */ React.createElement(Checkbox, {
      color: "primary",
      checked,
      onChange: onChecked
    })
  })));
});

const AlertSnoozeForm = forwardRef(({onSubmit, disableSubmit}, ref) => {
  const classes = useAlertDialogStyles();
  const [duration, setDuration] = useState(Duration.P7D);
  useEffect(() => disableSubmit(false), [disableSubmit]);
  const onFormSubmit = (e) => {
    e.preventDefault();
    if (duration) {
      const repeatInterval = 1;
      const today = DateTime.now().toFormat(DEFAULT_DATE_FORMAT);
      onSubmit({
        intervals: intervalsOf(duration, today, repeatInterval)
      });
    }
  };
  const onSnoozeDurationChange = (_, value) => {
    setDuration(value);
  };
  return /* @__PURE__ */ React.createElement("form", {
    ref,
    onSubmit: onFormSubmit
  }, /* @__PURE__ */ React.createElement(FormControl, {
    component: "fieldset",
    fullWidth: true
  }, /* @__PURE__ */ React.createElement(Typography, {
    color: "textPrimary"
  }, /* @__PURE__ */ React.createElement("b", null, "For how long?")), /* @__PURE__ */ React.createElement(Box, {
    mb: 1
  }, /* @__PURE__ */ React.createElement(RadioGroup, {
    name: "snooze-alert-options",
    value: duration,
    onChange: onSnoozeDurationChange
  }, AlertSnoozeOptions.map((option) => /* @__PURE__ */ React.createElement(FormControlLabel, {
    key: `snooze-alert-option-${option.duration}`,
    label: option.label,
    value: option.duration,
    control: /* @__PURE__ */ React.createElement(Radio, {
      className: classes.radio
    })
  }))))));
});

const AlertDismissForm = forwardRef(({onSubmit, disableSubmit}, ref) => {
  const classes = useAlertDialogStyles();
  const [other, setOther] = useState(null);
  const [feedback, setFeedback] = useState(null);
  const [reason, setReason] = useState(AlertDismissReason.Resolved);
  const onFormSubmit = (e) => {
    e.preventDefault();
    if (reason) {
      onSubmit({
        other,
        reason,
        feedback
      });
    }
  };
  const onReasonChange = (_, value) => {
    if (other) {
      setOther(null);
    }
    setReason(value);
  };
  const onOtherChange = (e) => {
    return e.target.value ? setOther(e.target.value) : setOther(null);
  };
  const onFeedbackChange = (e) => {
    return e.target.value ? setFeedback(e.target.value) : setFeedback(null);
  };
  useEffect(() => {
    function validateDismissForm() {
      if (reason === AlertDismissReason.Other) {
        if (other) {
          disableSubmit(false);
        } else {
          disableSubmit(true);
        }
      } else if (reason) {
        disableSubmit(false);
      } else {
        disableSubmit(true);
      }
    }
    validateDismissForm();
  }, [reason, other, disableSubmit]);
  return /* @__PURE__ */ React.createElement("form", {
    ref,
    onSubmit: onFormSubmit
  }, /* @__PURE__ */ React.createElement(FormControl, {
    component: "fieldset",
    fullWidth: true
  }, /* @__PURE__ */ React.createElement(Typography, {
    color: "textPrimary"
  }, /* @__PURE__ */ React.createElement("b", null, "Reason for dismissing?")), /* @__PURE__ */ React.createElement(Box, {
    mb: 1
  }, /* @__PURE__ */ React.createElement(RadioGroup, {
    name: "dismiss-alert-reasons",
    value: reason,
    onChange: onReasonChange
  }, AlertDismissOptions.map((option) => /* @__PURE__ */ React.createElement(FormControlLabel, {
    key: `dismiss-alert-option-${option.reason}`,
    label: option.label,
    value: option.reason,
    control: /* @__PURE__ */ React.createElement(Radio, {
      className: classes.radio
    })
  }))), /* @__PURE__ */ React.createElement(Collapse, {
    in: reason === AlertDismissReason.Other
  }, /* @__PURE__ */ React.createElement(Box, {
    ml: 4
  }, /* @__PURE__ */ React.createElement(TextField, {
    id: "dismiss-alert-option-other",
    variant: "outlined",
    multiline: true,
    fullWidth: true,
    rows: 4,
    value: other != null ? other : "",
    onChange: onOtherChange
  })))), /* @__PURE__ */ React.createElement(Typography, {
    gutterBottom: true
  }, /* @__PURE__ */ React.createElement("b", null, "Any other feedback you can provide?")), /* @__PURE__ */ React.createElement(TextField, {
    id: "dismiss-alert-feedback",
    variant: "outlined",
    multiline: true,
    rows: 4,
    fullWidth: true,
    value: feedback != null ? feedback : "",
    onChange: onFeedbackChange
  })));
});

const createAlertHandler = (status) => (alert) => alert.status === status;
const isAlertActive = (alert) => !hasProperty(alert, "status");
const isAlertSnoozed = createAlertHandler(AlertStatus.Snoozed);
const isAlertAccepted = createAlertHandler(AlertStatus.Accepted);
const isAlertDismissed = createAlertHandler(AlertStatus.Dismissed);
const createStatusHandler = (status) => (s) => s === status;
const isStatusSnoozed = createStatusHandler(AlertStatus.Snoozed);
const isStatusAccepted = createStatusHandler(AlertStatus.Accepted);
const isStatusDismissed = createStatusHandler(AlertStatus.Dismissed);
const createAlertEventHandler = (onEvent) => (alert) => hasProperty(alert, onEvent);
const isSnoozeEnabled = createAlertEventHandler("onSnoozed");
const isAcceptEnabled = createAlertEventHandler("onAccepted");
const isDismissEnabled = createAlertEventHandler("onDismissed");
const createFormEnabledHandler = (Form) => (alert) => {
  if (!alert)
    return false;
  if (alert[Form] === null)
    return false;
  switch (Form) {
    case "SnoozeForm":
      return isSnoozeEnabled(alert);
    case "AcceptForm":
      return isAcceptEnabled(alert);
    case "DismissForm":
      return isDismissEnabled(alert);
    default:
      return false;
  }
};
const isSnoozeFormEnabled = createFormEnabledHandler("SnoozeForm");
const isAcceptFormEnabled = createFormEnabledHandler("AcceptForm");
const isDismissFormEnabled = createFormEnabledHandler("DismissForm");
function formOf(alert, status) {
  var _a, _b, _c;
  switch (status) {
    case AlertStatus.Snoozed: {
      const SnoozeForm = (_a = alert == null ? void 0 : alert.SnoozeForm) != null ? _a : AlertSnoozeForm;
      return isSnoozeFormEnabled(alert) ? SnoozeForm : null;
    }
    case AlertStatus.Accepted: {
      const AcceptForm = (_b = alert == null ? void 0 : alert.AcceptForm) != null ? _b : AlertAcceptForm;
      return isAcceptFormEnabled(alert) ? AcceptForm : null;
    }
    case AlertStatus.Dismissed: {
      const DismissForm = (_c = alert == null ? void 0 : alert.DismissForm) != null ? _c : AlertDismissForm;
      return isDismissFormEnabled(alert) ? DismissForm : null;
    }
    default:
      return null;
  }
}
function choose$1(status, values, none) {
  switch (status) {
    case AlertStatus.Snoozed:
      return values[0];
    case AlertStatus.Accepted:
      return values[1];
    case AlertStatus.Dismissed:
      return values[2];
    default:
      return none;
  }
}
function hasProperty(alert, prop) {
  return prop in (alert != null ? alert : {});
}
const sumOfAllAlerts = (sum, alerts) => sum + alerts.length;

const CostInsightsThemeProvider = ({
  children
}) => {
  return /* @__PURE__ */ React.createElement(ThemeProvider, {
    theme: (theme) => createTheme({
      ...theme,
      palette: {
        ...theme.palette,
        ...theme.palette.type === "dark" ? costInsightsDarkTheme.palette : costInsightsLightTheme.palette
      }
    })
  }, children);
};

const useStyles$1 = makeStyles((theme) => ({
  root: {
    gridArea: "pageContent",
    padding: theme.spacing(4)
  }
}));
const AlertInstructionsLayout = ({
  title,
  children
}) => {
  const classes = useStyles$1();
  return /* @__PURE__ */ React.createElement(CostInsightsThemeProvider, null, /* @__PURE__ */ React.createElement(ConfigProvider, null, /* @__PURE__ */ React.createElement(CurrencyProvider, null, /* @__PURE__ */ React.createElement(Page, {
    themeId: "tool"
  }, /* @__PURE__ */ React.createElement(Header, {
    title: "Cost Insights",
    pageTitleOverride: title,
    type: "Tool"
  }), /* @__PURE__ */ React.createElement(Container, {
    maxWidth: "md",
    disableGutters: true,
    className: classes.root
  }, /* @__PURE__ */ React.createElement(Box, {
    mb: 3
  }, /* @__PURE__ */ React.createElement(Button, {
    variant: "outlined",
    startIcon: /* @__PURE__ */ React.createElement(ChevronLeftIcon, null),
    href: "/cost-insights"
  }, "Back to Cost Insights")), children)))));
};

const BarChartLabel = ({
  x,
  y,
  height,
  width,
  details,
  children
}) => {
  const classes = useBarChartLabelStyles();
  const translateX = width * -0.5;
  return /* @__PURE__ */ React.createElement("foreignObject", {
    className: classes.foreignObject,
    style: {transform: `translateX(${translateX}px)`},
    x,
    y,
    height,
    width
  }, /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    justifyContent: "center"
  }, /* @__PURE__ */ React.createElement(Typography, {
    className: classes.label,
    gutterBottom: true
  }, children), details));
};

const BarChartTick = ({
  x,
  y,
  height,
  width,
  payload,
  visibleTicksCount,
  details
}) => {
  const gutterWidth = 5;
  const labelWidth = width / visibleTicksCount - gutterWidth * 2;
  return /* @__PURE__ */ React.createElement(BarChartLabel, {
    x,
    y,
    height,
    width: labelWidth,
    details
  }, !payload.value ? "Unlabeled" : payload.value);
};

const BarChartStepperButton = forwardRef(({
  name,
  children,
  ...buttonBaseProps
}, ref) => {
  const classes = useBarChartStepperButtonStyles();
  return /* @__PURE__ */ React.createElement(ButtonBase, {
    ref,
    classes,
    disableRipple: true,
    "data-testid": `bar-chart-stepper-button-${name}`,
    ...buttonBaseProps
  }, children);
});

const BarChartSteps = ({
  steps,
  activeStep,
  onClick
}) => {
  const classes = useBarChartStepperStyles();
  const handleOnClick = (index) => (event) => {
    event.preventDefault();
    onClick(index);
  };
  return /* @__PURE__ */ React.createElement("div", {
    className: classes.steps
  }, [...new Array(steps)].map((_, index) => /* @__PURE__ */ React.createElement(ButtonBase, {
    key: index,
    centerRipple: true,
    onClick: handleOnClick(index)
  }, /* @__PURE__ */ React.createElement("div", {
    "data-testid": "bar-chart-step",
    className: `${classes.step} ${index === activeStep ? classes.stepActive : ""}`
  }))));
};

const BarChartStepper = ({
  steps,
  disableScroll,
  onChange
}) => {
  const classes = useBarChartStepperStyles();
  const [activeStep, setActiveStep] = useState(0);
  const diff = steps % 10;
  const stepsRemaining = steps - activeStep <= diff ? diff : steps;
  const displayedStep = activeStep % 10;
  useEffect(() => {
    onChange(activeStep);
  }, [activeStep, onChange]);
  const handleNext = () => {
    setActiveStep((prevStep) => prevStep + 1);
  };
  const handleBack = () => {
    setActiveStep((prevStep) => prevStep - 1);
  };
  const handleClick = (index) => {
    setActiveStep((prevStep) => {
      const offset = index - prevStep % 10;
      return prevStep + offset;
    });
  };
  return /* @__PURE__ */ React.createElement(Paper, {
    "data-testid": "bar-chart-stepper",
    square: true,
    elevation: 0,
    className: classes.paper
  }, /* @__PURE__ */ React.createElement(Slide, {
    direction: "right",
    in: !disableScroll && activeStep !== 0,
    mountOnEnter: true,
    unmountOnExit: true
  }, /* @__PURE__ */ React.createElement(BarChartStepperButton, {
    name: "back",
    className: classes.backButton,
    onClick: handleBack
  }, /* @__PURE__ */ React.createElement(ChevronLeftIcon, null))), /* @__PURE__ */ React.createElement(BarChartSteps, {
    steps: Math.min(10, stepsRemaining),
    activeStep: displayedStep,
    onClick: handleClick
  }), /* @__PURE__ */ React.createElement(Slide, {
    direction: "left",
    in: !disableScroll && activeStep < steps - 1,
    mountOnEnter: true,
    unmountOnExit: true
  }, /* @__PURE__ */ React.createElement(BarChartStepperButton, {
    name: "next",
    className: classes.nextButton,
    onClick: handleNext
  }, /* @__PURE__ */ React.createElement(ChevronRightIcon, null))));
};

const BarChartTooltip = ({
  title,
  content,
  subtitle,
  topRight,
  actions,
  children
}) => {
  const classes = useTooltipStyles();
  const titleClassName = classnames(classes.truncate, {
    [classes.maxWidth]: topRight === void 0
  });
  return /* @__PURE__ */ React.createElement(Box, {
    className: classes.tooltip,
    display: "flex",
    flexDirection: "column"
  }, /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "baseline",
    px: 2,
    pt: 2
  }, /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    flexDirection: "column"
  }, /* @__PURE__ */ React.createElement(Typography, {
    className: titleClassName,
    variant: "h6"
  }, title), subtitle && /* @__PURE__ */ React.createElement(Typography, {
    className: classes.subtitle,
    variant: "subtitle1"
  }, subtitle)), topRight && /* @__PURE__ */ React.createElement(Box, {
    ml: 2
  }, topRight)), content && /* @__PURE__ */ React.createElement(Box, {
    px: 2,
    pt: 2,
    className: classes.maxWidth
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "body1",
    paragraph: true
  }, content)), /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    p: 2
  }, children), actions && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Divider, {
    className: classes.divider,
    variant: "fullWidth"
  }), /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    flexDirection: "column",
    p: 2
  }, actions)));
};

const BarChartTooltipItem = ({item}) => {
  const classes = useTooltipStyles();
  return /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    minHeight: 25
  }, /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    alignContent: "center",
    marginRight: ".5em"
  }, /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    alignItems: "center",
    marginRight: ".5em"
  }, /* @__PURE__ */ React.createElement(LensIcon, {
    className: classes.lensIcon,
    style: {fill: item.fill}
  })), /* @__PURE__ */ React.createElement(Typography, null, item.label)), /* @__PURE__ */ React.createElement(Typography, {
    display: "block"
  }, item.value));
};

const costFormatter = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD"
});
const currencyFormatter = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  minimumFractionDigits: 0,
  maximumFractionDigits: 0
});
const lengthyCurrencyFormatter = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  minimumFractionDigits: 0,
  minimumSignificantDigits: 2,
  maximumSignificantDigits: 2
});
const numberFormatter = new Intl.NumberFormat("en-US", {
  minimumFractionDigits: 0,
  maximumFractionDigits: 0
});
const monthFormatter = new Intl.DateTimeFormat("en-US", {
  timeZone: "UTC",
  month: "long",
  year: "numeric"
});
const dateFormatter = new Intl.DateTimeFormat("en-US", {
  timeZone: "UTC",
  day: "numeric",
  month: "short"
});
const monthOf = (date) => {
  return monthFormatter.format(Date.parse(date));
};
const quarterOf = (date) => {
  const d = DateTime.fromISO(date).isValid ? DateTime.fromISO(date) : DateTime.fromFormat(date, "yyyy-'Q'q");
  return d.toFormat("'Q'q yyyy");
};
function formatCurrency(amount, currency) {
  const n = Math.round(amount);
  const numString = numberFormatter.format(n);
  return currency ? `${numString} ${pluralize(currency, n)}` : numString;
}
function formatChange(change) {
  if (notEmpty(change.ratio)) {
    return formatPercent(Math.abs(change.ratio));
  }
  return change.amount >= 0 ? "\u221E" : "-\u221E";
}
function formatPercent(n) {
  if (isNaN(n) || Math.abs(n) < 0.01) {
    return "0%";
  }
  if (Math.abs(n) > 10) {
    return `>1000%`;
  }
  return `${(n * 100).toFixed(0)}%`;
}
function formatLastTwoLookaheadQuarters(inclusiveEndDate) {
  const start = DateTime.fromISO(inclusiveStartDateOf(Duration.P3M, inclusiveEndDate)).toFormat("'Q'q yyyy");
  const end = DateTime.fromISO(inclusiveEndDateOf(Duration.P3M, inclusiveEndDate)).toFormat("'Q'q yyyy");
  return `${start} vs ${end}`;
}
const formatRelativePeriod = (duration, date, isEndDate) => {
  const periodStart = isEndDate ? inclusiveStartDateOf(duration, date) : date;
  const periodEnd = isEndDate ? date : inclusiveEndDateOf(duration, date);
  const days = Duration$1.fromISO(duration).days;
  if (![periodStart, periodEnd].includes(date)) {
    throw new Error(`Invalid relative date ${date} for duration ${duration}`);
  }
  return date === periodStart ? `First ${days} Days` : `Last ${days} Days`;
};
function formatPeriod(duration, date, isEndDate) {
  switch (duration) {
    case Duration.P3M:
      return quarterOf(isEndDate ? inclusiveEndDateOf(duration, date) : inclusiveStartDateOf(duration, date));
    default:
      return formatRelativePeriod(duration, date, isEndDate);
  }
}

const aggregationSort = (a, b) => a.date.localeCompare(b.date);
const resourceSort = (a, b) => b.previous + b.current - (a.previous + a.current);
function totalAggregationSort(a, b) {
  var _a, _b, _c, _d;
  const [prevA, currA] = (_b = (_a = a.entity) == null ? void 0 : _a.aggregation) != null ? _b : [0, 0];
  const [prevB, currB] = (_d = (_c = b.entity) == null ? void 0 : _c.aggregation) != null ? _d : [0, 0];
  return prevB + currB - (prevA + currA);
}

function formatGraphValue(value, format) {
  if (format === "number") {
    return value.toLocaleString();
  }
  if (value < 1) {
    return lengthyCurrencyFormatter.format(value);
  }
  return currencyFormatter.format(value);
}
const overviewGraphTickFormatter = (millis) => typeof millis === "number" ? dateFormatter.format(millis) : millis;
const tooltipItemOf = (payload) => {
  const value = typeof payload.value === "number" ? currencyFormatter.format(payload.value) : payload.value;
  const fill = payload.fill;
  switch (payload.dataKey) {
    case DataKey.Current:
    case DataKey.Previous:
      return {
        label: payload.name,
        value,
        fill
      };
    default:
      return null;
  }
};
const resourceOf = (entity) => ({
  name: entity.id,
  previous: entity.aggregation[0],
  current: entity.aggregation[1]
});
const titleOf = (label) => {
  return label ? String(label) : "Unlabeled";
};
const isInvalid = ({label, payload}) => {
  return label === void 0 || !payload || !payload.length;
};
const isLabeled = (data) => {
  return (data == null ? void 0 : data.activeLabel) && (data == null ? void 0 : data.activeLabel) !== "";
};
const isUnlabeled = (data) => {
  return (data == null ? void 0 : data.activeLabel) === "";
};

const defaultTooltip = ({
  label,
  payload = []
}) => {
  if (isInvalid({label, payload}))
    return null;
  const title = titleOf(label);
  const items = payload.map(tooltipItemOf).filter(notEmpty);
  return /* @__PURE__ */ React.createElement(BarChartTooltip, {
    title
  }, items.map((item, index) => /* @__PURE__ */ React.createElement(BarChartTooltipItem, {
    key: `${item.label}-${index}`,
    item
  })));
};
const BarChart = ({
  resources,
  responsive = true,
  displayAmount = 6,
  options = {},
  tooltip = defaultTooltip,
  onClick,
  onMouseMove
}) => {
  const theme = useTheme();
  const styles = useBarChartStyles(theme);
  const [activeChart, setActiveChart] = useState(false);
  const [stepWindow, setStepWindow] = useState(() => [0, displayAmount]);
  const data = Object.assign({
    previousFill: theme.palette.lightBlue,
    currentFill: theme.palette.darkBlue,
    previousName: "Previous",
    currentName: "Current"
  }, options);
  const [stepStart, stepEnd] = stepWindow;
  const steps = Math.ceil(resources.length / displayAmount);
  const disableStepper = resources.length <= displayAmount;
  const sortedResources = resources.sort(resourceSort).slice(stepStart, stepEnd);
  const globalResourcesMax = resources.reduce((max, r) => Math.max(max, r.current, r.previous), 0);
  const onStepChange = useCallback((activeStep) => {
    const start = activeStep * displayAmount;
    const end = start + displayAmount;
    if (end > resources.length) {
      setStepWindow([start, resources.length]);
    } else {
      setStepWindow([start, end]);
    }
  }, [setStepWindow, resources, displayAmount]);
  return /* @__PURE__ */ React.createElement(Box, {
    position: "relative",
    onMouseLeave: () => setActiveChart(false),
    onMouseEnter: () => setActiveChart(true),
    "data-testid": "bar-chart-wrapper"
  }, /* @__PURE__ */ React.createElement(ResponsiveContainer, {
    height: styles.container.height,
    width: responsive ? "100%" : styles.container.width
  }, /* @__PURE__ */ React.createElement(BarChart$1, {
    style: {cursor: onClick ? "pointer" : null},
    onClick,
    onMouseMove,
    data: sortedResources,
    margin: styles.barChart.margin,
    barSize: 45,
    "data-testid": "bar-chart"
  }, tooltip && /* @__PURE__ */ React.createElement(Tooltip, {
    filterNull: true,
    cursor: styles.cursor,
    animationDuration: 100,
    content: tooltip
  }), /* @__PURE__ */ React.createElement(CartesianGrid, {
    vertical: false,
    stroke: styles.cartesianGrid.stroke
  }), /* @__PURE__ */ React.createElement(XAxis, {
    dataKey: DataKey.Name,
    tickLine: false,
    interval: 0,
    height: styles.xAxis.height,
    tick: BarChartTick
  }), /* @__PURE__ */ React.createElement(YAxis, {
    tickFormatter: currencyFormatter.format,
    domain: [() => 0, globalResourcesMax],
    tick: styles.axis
  }), /* @__PURE__ */ React.createElement(Bar, {
    dataKey: DataKey.Previous,
    name: data.previousName,
    fill: data.previousFill,
    isAnimationActive: false
  }), /* @__PURE__ */ React.createElement(Bar, {
    dataKey: DataKey.Current,
    name: data.currentName,
    fill: data.currentFill,
    isAnimationActive: false
  }))), !disableStepper && /* @__PURE__ */ React.createElement(BarChartStepper, {
    steps,
    disableScroll: !activeChart,
    onChange: onStepChange
  }));
};

const LegendItem = ({
  title,
  tooltipText,
  markerColor,
  children
}) => {
  const classes = useCostGrowthLegendStyles();
  return /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    flexDirection: "column"
  }, /* @__PURE__ */ React.createElement(Box, {
    minHeight: 25,
    display: "flex",
    flexDirection: "row",
    alignItems: "center"
  }, markerColor && /* @__PURE__ */ React.createElement("div", {
    className: classes.marker
  }, /* @__PURE__ */ React.createElement(LensIcon, {
    style: {fontSize: "1em", fill: markerColor}
  })), /* @__PURE__ */ React.createElement(Typography, {
    className: classes.title,
    variant: "overline"
  }, title), tooltipText && /* @__PURE__ */ React.createElement(Tooltip$1, {
    classes: {tooltip: classes.tooltip},
    title: /* @__PURE__ */ React.createElement(Typography, {
      className: classes.tooltipText
    }, tooltipText),
    placement: "top-start"
  }, /* @__PURE__ */ React.createElement("span", {
    role: "img",
    "aria-label": "help",
    className: classes.helpIcon
  }, /* @__PURE__ */ React.createElement(HelpOutlineOutlinedIcon, {
    fontSize: "small"
  })))), /* @__PURE__ */ React.createElement(Box, {
    marginLeft: markerColor ? "1.5em" : 0
  }, /* @__PURE__ */ React.createElement(Typography, {
    className: classes.h5,
    variant: "h5"
  }, children)));
};

const BarChartLegend = ({
  costStart,
  costEnd,
  options = {},
  children
}) => {
  const theme = useTheme();
  const classes = useBarChartLayoutStyles();
  const data = Object.assign({
    previousName: "Previous",
    previousFill: theme.palette.lightBlue,
    currentName: "Current",
    currentFill: theme.palette.darkBlue
  }, options);
  return /* @__PURE__ */ React.createElement(Box, {
    className: classes.legend,
    display: "flex",
    flexDirection: "row"
  }, /* @__PURE__ */ React.createElement(Box, {
    marginRight: 2
  }, /* @__PURE__ */ React.createElement(LegendItem, {
    title: data.previousName,
    markerColor: options.hideMarker ? void 0 : data.previousFill
  }, currencyFormatter.format(costStart))), /* @__PURE__ */ React.createElement(Box, {
    marginRight: 2
  }, /* @__PURE__ */ React.createElement(LegendItem, {
    title: data.currentName,
    markerColor: options.hideMarker ? void 0 : data.currentFill
  }, currencyFormatter.format(costEnd))), children);
};

function growthOf(change) {
  const exceedsEngineerThreshold = Math.abs(change.amount) >= EngineerThreshold;
  if (notEmpty(change.ratio)) {
    if (exceedsEngineerThreshold && change.ratio >= ChangeThreshold.upper) {
      return GrowthType.Excess;
    }
    if (exceedsEngineerThreshold && change.ratio <= ChangeThreshold.lower) {
      return GrowthType.Savings;
    }
  } else {
    if (exceedsEngineerThreshold && change.amount > 0)
      return GrowthType.Excess;
    if (exceedsEngineerThreshold && change.amount < 0)
      return GrowthType.Savings;
  }
  return GrowthType.Negligible;
}
function getComparedChange(dailyCost, metricData, duration, lastCompleteBillingDate) {
  var _a, _b;
  const dailyCostRatio = (_a = dailyCost.change) == null ? void 0 : _a.ratio;
  const metricDataRatio = (_b = metricData.change) == null ? void 0 : _b.ratio;
  const previousPeriodTotal = getPreviousPeriodTotalCost(dailyCost.aggregation, duration, lastCompleteBillingDate);
  if (!notEmpty(dailyCostRatio) || !notEmpty(metricDataRatio)) {
    return {
      amount: previousPeriodTotal
    };
  }
  return {
    ratio: dailyCostRatio - metricDataRatio,
    amount: previousPeriodTotal * (dailyCostRatio - metricDataRatio)
  };
}
function getPreviousPeriodTotalCost(aggregation, duration, inclusiveEndDate) {
  const luxonDuration = Duration$1.fromISO(duration);
  const startDate = inclusiveStartDateOf(duration, inclusiveEndDate);
  const nextPeriodStart = DateTime.fromISO(startDate).plus(luxonDuration);
  return aggregation.reduce((acc, costByDate) => {
    return DateTime.fromISO(costByDate.date) < nextPeriodStart ? acc + costByDate.amount : acc;
  }, 0);
}
function choose([savings, excess], change) {
  var _a;
  const isSavings = ((_a = change.ratio) != null ? _a : change.amount) <= 0;
  return isSavings ? savings : excess;
}

const vowels = {
  a: "A",
  e: "E",
  i: "I",
  o: "O",
  u: "U"
};
const indefiniteArticleOf = (articles, word) => {
  const firstChar = word.charAt(0).toLowerCase();
  return firstChar in vowels ? `${articles[1]} ${word}` : `${articles[0]} ${word}`;
};

const CostGrowth = ({change, duration}) => {
  var _a, _b;
  const styles = useCostGrowthStyles();
  const {engineerCost} = useConfig();
  const [currency] = useCurrency();
  const amount = Math.abs(change.amount);
  const ratio = Math.abs((_a = change.ratio) != null ? _a : NaN);
  const rate = rateOf(engineerCost, duration);
  const engineers = amount / rate;
  const converted = amount / ((_b = currency.rate) != null ? _b : rate);
  const growth = notEmpty(change.ratio) ? growthOf({ratio: change.ratio, amount: engineers}) : null;
  const classes = classnames({
    [styles.excess]: growth === GrowthType.Excess,
    [styles.savings]: growth === GrowthType.Savings
  });
  if (engineers < EngineerThreshold) {
    return /* @__PURE__ */ React.createElement("span", {
      className: classes
    }, "Negligible");
  }
  if (currency.kind === CurrencyType.USD) {
    if (isNaN(ratio)) {
      return /* @__PURE__ */ React.createElement("span", {
        className: classes
      }, "~", currency.prefix, formatCurrency(converted));
    }
    return /* @__PURE__ */ React.createElement("span", {
      className: classes
    }, formatPercent(ratio), " or ~", currency.prefix, formatCurrency(converted));
  }
  if (amount < 1) {
    return /* @__PURE__ */ React.createElement("span", {
      className: classes
    }, "less than ", indefiniteArticleOf(["a", "an"], currency.unit));
  }
  if (isNaN(ratio)) {
    return /* @__PURE__ */ React.createElement("span", {
      className: classes
    }, "~", formatCurrency(converted, currency.unit));
  }
  return /* @__PURE__ */ React.createElement("span", {
    className: classes
  }, formatPercent(ratio), " or ~", formatCurrency(converted, currency.unit));
};

const CostGrowthIndicator = ({
  change,
  formatter,
  className,
  ...props
}) => {
  const classes = useCostGrowthStyles();
  const growth = growthOf(change);
  const classNames = classnames(classes.indicator, className, {
    [classes.excess]: growth === GrowthType.Excess,
    [classes.savings]: growth === GrowthType.Savings
  });
  return /* @__PURE__ */ React.createElement(Typography, {
    className: classNames,
    component: "span",
    ...props
  }, formatter ? formatter(change) : change.ratio, growth === GrowthType.Excess && /* @__PURE__ */ React.createElement(ArrowDropUp, {
    "aria-label": "excess"
  }), growth === GrowthType.Savings && /* @__PURE__ */ React.createElement(ArrowDropDown, {
    "aria-label": "savings"
  }));
};

const mapFiltersToProps = ({pageFilters, setPageFilters}) => ({
  ...pageFilters,
  setGroup: (group) => setPageFilters({
    ...pageFilters,
    group: group.id,
    project: null
  })
});
const mapLoadingToProps = ({actions, dispatch}) => ({
  loadingActions: actions,
  dispatchReset: (loadingActions) => dispatch(getResetStateWithoutInitial(loadingActions))
});

const CostInsightsTabs = ({groups}) => {
  const classes = useCostInsightsTabsStyles();
  const [index] = useState(0);
  const [groupMenuEl, setGroupMenuEl] = useState(null);
  const {group, setGroup} = useFilters(mapFiltersToProps);
  const {loadingActions, dispatchReset} = useLoading(mapLoadingToProps);
  const openGroupMenu = (e) => setGroupMenuEl(e.currentTarget);
  const closeGroupMenu = () => setGroupMenuEl(null);
  const updateGroupFilterAndCloseMenu = (g) => () => {
    dispatchReset(loadingActions);
    closeGroupMenu();
    setGroup(g);
  };
  const renderTabLabel = () => /* @__PURE__ */ React.createElement("div", {
    className: classes.tabLabel
  }, /* @__PURE__ */ React.createElement(Typography, {
    className: classes.tabLabelText,
    variant: "overline"
  }, `${groups.length} teams`), /* @__PURE__ */ React.createElement(ExpandMoreIcon, {
    fontSize: "small"
  }));
  const hasAtLeastTwoGroups = groups.length >= 2;
  if (!hasAtLeastTwoGroups)
    return null;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Tabs, {
    className: `cost-insights-tabs ${classes.tabs}`,
    "data-testid": "cost-insights-tabs",
    classes: {indicator: classes.indicator},
    value: index
  }, /* @__PURE__ */ React.createElement(Tab, {
    className: classes.tab,
    "data-testid": "cost-insights-groups-tab",
    key: "cost-insights-groups-tab",
    label: renderTabLabel(),
    onClick: openGroupMenu,
    component: "button"
  })), /* @__PURE__ */ React.createElement(Menu, {
    id: "group-menu",
    "data-testid": "group-menu",
    className: classes.menu,
    getContentAnchorEl: null,
    anchorEl: groupMenuEl,
    keepMounted: true,
    open: Boolean(groupMenuEl),
    onClose: closeGroupMenu,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: "left"
    },
    transformOrigin: {
      vertical: "top",
      horizontal: "left"
    }
  }, groups.map((g) => /* @__PURE__ */ React.createElement(MenuItem, {
    className: classes.menuItem,
    classes: {selected: classes.menuItemSelected},
    selected: g.id === group,
    key: g.id,
    "data-testid": g.id,
    onClick: updateGroupFilterAndCloseMenu(g)
  }, g.id))));
};

const useStyles = makeStyles((theme) => ({
  root: {
    gridArea: "pageContent"
  },
  header: {
    boxShadow: "none"
  },
  content: {
    padding: theme.spacing(4)
  }
}));
const CostInsightsLayout = ({
  groups,
  children
}) => {
  const classes = useStyles();
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: "tool"
  }, /* @__PURE__ */ React.createElement(Header, {
    style: {boxShadow: "none"},
    title: "Cost Insights",
    pageTitleOverride: "Cost Insights",
    type: "Tool"
  }), /* @__PURE__ */ React.createElement("div", {
    className: classes.root
  }, /* @__PURE__ */ React.createElement(CostInsightsTabs, {
    groups
  }), /* @__PURE__ */ React.createElement("div", {
    className: classes.content
  }, children)));
};

const NavigationMenuItem = ({navigation, icon, title}) => {
  const classes = useNavigationStyles();
  const [, setScroll] = useScroll();
  return /* @__PURE__ */ React.createElement(MenuItem, {
    button: true,
    "data-testid": `menu-item-${navigation}`,
    className: classes.menuItem,
    onClick: () => setScroll(navigation)
  }, /* @__PURE__ */ React.createElement(ListItemIcon, {
    className: classes.listItemIcon
  }, icon), /* @__PURE__ */ React.createElement(ListItemText, {
    primary: /* @__PURE__ */ React.createElement(Typography, {
      className: classes.title
    }, title)
  }));
};
const CostInsightsNavigation = React.memo(({alerts, products}) => {
  var _a;
  const classes = useNavigationStyles();
  const {icons} = useConfig();
  const [isOpen, setOpen] = useState(false);
  const defaultNavigationItems = getDefaultNavigationItems(alerts);
  const productNavigationItems = (_a = products == null ? void 0 : products.map((product) => ({
    title: product.name,
    navigation: product.kind,
    icon: findAlways(icons, (i) => i.kind === product.kind).component
  }))) != null ? _a : [];
  useEffect(function toggleProductMenuItems() {
    if (products == null ? void 0 : products.length) {
      setOpen(true);
    } else {
      setOpen(false);
    }
  }, [products]);
  return /* @__PURE__ */ React.createElement(MenuList, {
    className: classes.menuList
  }, defaultNavigationItems.map((item) => /* @__PURE__ */ React.createElement(NavigationMenuItem, {
    key: `navigation-menu-item-${item.navigation}`,
    navigation: item.navigation,
    title: item.title,
    icon: item.navigation === DefaultNavigation.AlertInsightsHeader ? /* @__PURE__ */ React.createElement(Badge, {
      badgeContent: alerts,
      color: "secondary"
    }, React.cloneElement(item.icon, {
      className: classes.navigationIcon
    })) : React.cloneElement(item.icon, {
      className: classes.navigationIcon
    })
  })), /* @__PURE__ */ React.createElement(Collapse, {
    in: isOpen,
    timeout: 850
  }, productNavigationItems.map((item) => /* @__PURE__ */ React.createElement(NavigationMenuItem, {
    key: `navigation-menu-item-${item.navigation}`,
    navigation: item.navigation,
    icon: React.cloneElement(item.icon, {
      className: classes.navigationIcon
    }),
    title: item.title
  }))));
});

function createRenderer(col, classes) {
  return function render(rowData) {
    const row = rowData;
    const rowStyles = classnames(classes.row, {
      [classes.rowTotal]: row.id === "total",
      [classes.colFirst]: col === "label",
      [classes.colLast]: col === "change"
    });
    switch (col) {
      case "previous":
      case "current":
        return /* @__PURE__ */ React.createElement(Typography, {
          className: rowStyles
        }, costFormatter.format(row[col]));
      case "change":
        return /* @__PURE__ */ React.createElement(CostGrowthIndicator, {
          className: rowStyles,
          change: row.change,
          formatter: formatChange
        });
      default:
        return /* @__PURE__ */ React.createElement(Typography, {
          className: rowStyles
        }, row.label);
    }
  };
}
function createSorter(field) {
  return function rowSort(data1, data2) {
    const a = data1;
    const b = data2;
    if (a.id === "total")
      return 1;
    if (b.id === "total")
      return 1;
    if (field === "label")
      return a.label.localeCompare(b.label);
    if (field === "change") {
      if (formatChange(a[field]) === "\u221E" || formatChange(b[field]) === "-\u221E")
        return 1;
      if (formatChange(a[field]) === "-\u221E" || formatChange(b[field]) === "\u221E")
        return -1;
      return a[field].ratio - b[field].ratio;
    }
    return b.previous + b.current - (a.previous + a.current);
  };
}
const ProductEntityTable = ({
  entityLabel,
  entity,
  options
}) => {
  const classes = useEntityDialogStyles();
  const entities = entity.entities[entityLabel];
  const data = Object.assign({
    previousName: "Previous",
    currentName: "Current"
  }, options);
  const firstColClasses = classnames(classes.column, classes.colFirst);
  const lastColClasses = classnames(classes.column, classes.colLast);
  const columns = [
    {
      field: "label",
      title: /* @__PURE__ */ React.createElement(Typography, {
        className: firstColClasses
      }, entityLabel),
      render: createRenderer("label", classes),
      customSort: createSorter("label"),
      width: "33.33%"
    },
    {
      field: "previous",
      title: /* @__PURE__ */ React.createElement(Typography, {
        className: classes.column
      }, data.previousName),
      align: "right",
      render: createRenderer("previous", classes),
      customSort: createSorter("previous")
    },
    {
      field: "current",
      title: /* @__PURE__ */ React.createElement(Typography, {
        className: classes.column
      }, data.currentName),
      align: "right",
      render: createRenderer("current", classes),
      customSort: createSorter("current")
    },
    {
      field: "change",
      title: /* @__PURE__ */ React.createElement(Typography, {
        className: lastColClasses
      }, "Change"),
      align: "right",
      render: createRenderer("change", classes),
      customSort: createSorter("change")
    }
  ];
  const rowData = entities.map((e) => ({
    id: e.id || "Unknown",
    label: e.id || "Unknown",
    previous: e.aggregation[0],
    current: e.aggregation[1],
    change: e.change
  })).concat({
    id: "total",
    label: "Total",
    previous: entity.aggregation[0],
    current: entity.aggregation[1],
    change: entity.change
  }).sort(createSorter());
  return /* @__PURE__ */ React.createElement(Table, {
    columns,
    data: rowData,
    title: entity.id || "Unlabeled",
    options: {
      paging: false,
      search: false,
      hideFilterIcons: true
    }
  });
};

const ProductEntityDialog = ({
  open,
  entity,
  options = {},
  onClose
}) => {
  const classes = useEntityDialogStyles();
  const labels = Object.keys(entity.entities);
  const [selectedLabel, setSelectedLabel] = useState(findAlways(labels, (_) => true));
  const tabs = labels.map((label, index) => ({
    id: index.toString(),
    label: `Breakdown by ${label}`
  }));
  return /* @__PURE__ */ React.createElement(Dialog, {
    open,
    onClose,
    scroll: "body",
    fullWidth: true,
    maxWidth: "lg"
  }, /* @__PURE__ */ React.createElement(IconButton, {
    className: classes.closeButton,
    onClick: onClose
  }, /* @__PURE__ */ React.createElement(CloseIcon, null)), /* @__PURE__ */ React.createElement(HeaderTabs, {
    tabs,
    onChange: (index) => setSelectedLabel(labels[index])
  }), /* @__PURE__ */ React.createElement(ProductEntityTable, {
    entityLabel: selectedLabel,
    entity,
    options
  }));
};

const ProductInsightsChart = ({
  billingDate,
  entity,
  duration
}) => {
  const classes = useProductInsightsChartStyles();
  const layoutClasses = useBarChartLayoutStyles();
  const entities = useMemo(() => {
    var _a;
    const entityLabel = assertAlways(findAnyKey(entity.entities));
    return (_a = entity.entities[entityLabel]) != null ? _a : [];
  }, [entity]);
  const [activeLabel, setActive] = useState();
  const [selectLabel, setSelected] = useState();
  const isSelected = useMemo(() => !isUndefined(selectLabel), [selectLabel]);
  const isClickable = useMemo(() => {
    var _a, _b;
    const breakdowns = Object.keys((_b = (_a = entities.find((e) => e.id === activeLabel)) == null ? void 0 : _a.entities) != null ? _b : {});
    return breakdowns.length > 0;
  }, [entities, activeLabel]);
  const costStart = entity.aggregation[0];
  const costEnd = entity.aggregation[1];
  const resources = entities.map(resourceOf);
  const options = {
    previousName: formatPeriod(duration, billingDate, false),
    currentName: formatPeriod(duration, billingDate, true)
  };
  const onMouseMove = (data) => {
    if (isLabeled(data)) {
      setActive(data.activeLabel);
    } else if (isUnlabeled(data)) {
      setActive(null);
    } else {
      setActive(void 0);
    }
  };
  const onClick = (data) => {
    if (isLabeled(data)) {
      setSelected(data.activeLabel);
    } else if (isUnlabeled(data)) {
      setSelected(null);
    } else {
      setSelected(void 0);
    }
  };
  const renderProductInsightsTooltip = ({
    label,
    payload = []
  }) => {
    if (isInvalid({label, payload}))
      return null;
    const id = label === "" ? null : label;
    const title = titleOf(label);
    const items = payload.map(tooltipItemOf).filter(notEmpty);
    const activeEntity = findAlways(entities, (e) => e.id === id);
    const breakdowns = Object.keys(activeEntity.entities);
    if (breakdowns.length) {
      const subtitle = breakdowns.map((b) => pluralize(b, activeEntity.entities[b].length, true)).join(", ");
      return /* @__PURE__ */ React.createElement(BarChartTooltip, {
        title,
        subtitle,
        topRight: !!activeEntity.change.ratio && /* @__PURE__ */ React.createElement(CostGrowthIndicator, {
          formatter: formatChange,
          change: activeEntity.change,
          className: classes.indicator
        }),
        actions: /* @__PURE__ */ React.createElement(Box, {
          className: classes.actions
        }, /* @__PURE__ */ React.createElement(FullScreenIcon, null), /* @__PURE__ */ React.createElement(Typography, null, "Click for breakdown"))
      }, items.map((item, index) => /* @__PURE__ */ React.createElement(BarChartTooltipItem, {
        key: `${item.label}-${index}`,
        item
      })));
    }
    return /* @__PURE__ */ React.createElement(BarChartTooltip, {
      title,
      topRight: !!activeEntity.change.ratio && /* @__PURE__ */ React.createElement(CostGrowthIndicator, {
        formatter: formatChange,
        change: activeEntity.change,
        className: classes.indicator
      }),
      content: id ? null : "This product has costs that are not labeled and therefore can't be attributed to a specific entity."
    }, items.map((item, index) => /* @__PURE__ */ React.createElement(BarChartTooltipItem, {
      key: `${item.label}-${index}`,
      item
    })));
  };
  const barChartProps = isClickable ? {onClick} : {};
  return /* @__PURE__ */ React.createElement(Box, {
    className: layoutClasses.wrapper
  }, /* @__PURE__ */ React.createElement(BarChartLegend, {
    costStart,
    costEnd,
    options
  }, /* @__PURE__ */ React.createElement(LegendItem, {
    title: choose(["Cost Savings", "Cost Excess"], entity.change)
  }, /* @__PURE__ */ React.createElement(CostGrowth, {
    change: entity.change,
    duration
  }))), /* @__PURE__ */ React.createElement(BarChart, {
    resources,
    tooltip: renderProductInsightsTooltip,
    onMouseMove,
    options,
    ...barChartProps
  }), isSelected && entities.length && /* @__PURE__ */ React.createElement(ProductEntityDialog, {
    open: isSelected,
    onClose: () => setSelected(void 0),
    entity: findAlways(entities, (e) => e.id === selectLabel),
    options
  }));
};

const ProjectGrowthAlertChart = ({
  alert
}) => {
  const classes = useBarChartLayoutStyles();
  const costStart = alert.aggregation[0];
  const costEnd = alert.aggregation[1];
  const resourceData = alert.products.map(resourceOf);
  const options = {
    previousName: DateTime.fromFormat(alert.periodStart, "yyyy-'Q'q").toFormat("'Q'q yyyy"),
    currentName: DateTime.fromFormat(alert.periodEnd, "yyyy-'Q'q").toFormat("'Q'q yyyy")
  };
  return /* @__PURE__ */ React.createElement(Box, {
    className: classes.wrapper
  }, /* @__PURE__ */ React.createElement(BarChartLegend, {
    costStart,
    costEnd,
    options
  }, /* @__PURE__ */ React.createElement(LegendItem, {
    title: "Cost Growth"
  }, /* @__PURE__ */ React.createElement(CostGrowth, {
    change: alert.change,
    duration: Duration.P3M
  }))), /* @__PURE__ */ React.createElement(BarChart, {
    resources: resourceData,
    options
  }));
};

const ProjectGrowthAlertCard = ({alert}) => {
  const subheader = `
    ${pluralize("product", alert.products.length, true)}${alert.products.length > 1 ? ", sorted by cost" : ""}`;
  return /* @__PURE__ */ React.createElement(InfoCard, {
    title: `Project growth for ${alert.project}`,
    subheader
  }, /* @__PURE__ */ React.createElement(ProjectGrowthAlertChart, {
    alert
  }));
};

class ProjectGrowthAlert {
  constructor(data) {
    this.data = data;
  }
  get url() {
    return "/cost-insights/investigating-growth";
  }
  get title() {
    return `Investigate cost growth in project ${this.data.project}`;
  }
  get subtitle() {
    return "Cost growth outpacing business growth is unsustainable long-term.";
  }
  get element() {
    return /* @__PURE__ */ React.createElement(ProjectGrowthAlertCard, {
      alert: this.data
    });
  }
}

const UnlabeledDataflowAlertCard = ({
  alert
}) => {
  const classes = useBarChartLayoutStyles();
  const projects = pluralize("project", alert.projects.length, true);
  const subheader = `
    Showing costs from ${projects} with unlabeled Dataflow jobs in the last 30 days.
  `;
  const options = {
    previousName: "Unlabeled Cost",
    currentName: "Labeled Cost"
  };
  const resources = alert.projects.map((project) => ({
    name: project.id,
    previous: project.unlabeledCost,
    current: project.labeledCost
  }));
  return /* @__PURE__ */ React.createElement(InfoCard, {
    title: "Label Dataflow",
    subheader
  }, /* @__PURE__ */ React.createElement(Box, {
    className: classes.wrapper
  }, /* @__PURE__ */ React.createElement(BarChartLegend, {
    costStart: alert.unlabeledCost,
    costEnd: alert.labeledCost,
    options
  }), /* @__PURE__ */ React.createElement(BarChart, {
    resources,
    options
  })));
};

class UnlabeledDataflowAlert {
  constructor(data) {
    this.data = data;
  }
  get url() {
    return "/cost-insights/labeling-jobs";
  }
  get title() {
    return "Add labels to workflows";
  }
  get subtitle() {
    return "Labels show in billing data, enabling cost insights for each workflow.";
  }
  get element() {
    return /* @__PURE__ */ React.createElement(UnlabeledDataflowAlertCard, {
      alert: this.data
    });
  }
}

const today = DateTime.now().toFormat(DEFAULT_DATE_FORMAT);
const ProjectGrowthInstructionsPage = () => {
  const alertData = {
    project: "example-project",
    periodStart: "Q1 2020",
    periodEnd: "Q2 2020",
    aggregation: [6e4, 12e4],
    change: {
      ratio: 1,
      amount: 6e4
    },
    products: [
      {
        id: "Compute Engine",
        aggregation: [58e3, 118e3]
      },
      {
        id: "Cloud Dataflow",
        aggregation: [1200, 1500]
      },
      {
        id: "Cloud Storage",
        aggregation: [800, 500]
      }
    ]
  };
  const projectGrowthAlert = new ProjectGrowthAlert(alertData);
  const product = {
    kind: "ComputeEngine",
    name: "Compute Engine"
  };
  const entity = {
    id: "example-id",
    aggregation: [2e4, 6e4],
    change: {
      ratio: 3,
      amount: 4e4
    },
    entities: {
      service: [
        {
          id: "service-one",
          aggregation: [18200, 58500],
          entities: {},
          change: {ratio: 2.21, amount: 40300}
        },
        {
          id: "service-two",
          aggregation: [1200, 1300],
          entities: {},
          change: {ratio: 0.083, amount: 100}
        },
        {
          id: "service-three",
          aggregation: [600, 200],
          entities: {},
          change: {ratio: -0.666, amount: -400}
        }
      ]
    }
  };
  return /* @__PURE__ */ React.createElement(AlertInstructionsLayout, {
    title: "Investigating Growth"
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "h1"
  }, "Investigating cloud cost growth"), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "Cost Insights shows an alert when costs for a particular billing entity, such as a GCP project, have grown at a rate faster than our alerting threshold. The responsible team should follow this guide to decide whether this warrants further investigation."), /* @__PURE__ */ React.createElement(Box, {
    mt: 4
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "h3"
  }, "Is the growth expected?"), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "The first question to ask is whether growth is expected. Perhaps a new product has been deployed, or additional regions added for reliability."), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "Many services increase cost linearly with load. Has the demand increased? This may happen as you open new markets, or run marketing offers. Costs should be compared against a business metric, such as daily users, to normalize natural increases from business growth."), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "Seasonal variance may also cause cost growth; yearly campaigns, an increase in demand during certain times of year."), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "Cloud costs will often go up before they go down, in the case of migrations. Teams moving to new infrastructure may run in both the old and new environment during the migration.")), /* @__PURE__ */ React.createElement(Box, {
    mt: 4
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "h3"
  }, "Is the growth significant?"), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "Next, evaluate whether the growth is significant. This helps avoid premature optimization, where cost in engineering time is more than would be saved from the optimization over a reasonable time frame."), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "We recommend reframing the cost growth itself in terms of engineering time. How much engineering time, for an ", /* @__PURE__ */ React.createElement("i", null, "average"), " fully-loaded engineer cost at the company, is being overspent each month? Compare this to expected engineering time for optimization to decide whether the optimization is worthwhile.")), /* @__PURE__ */ React.createElement(Box, {
    mt: 4
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "h3"
  }, "Identifying which cloud product contributed most"), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "For projects meeting the alert threshold, Cost Insights shows a cost comparison of cloud products over the examined time period:"), /* @__PURE__ */ React.createElement(Box, {
    mt: 2,
    mb: 2
  }, projectGrowthAlert.element), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "This allows you to quickly see which cloud products contributed to the growth in cloud costs.")), /* @__PURE__ */ React.createElement(Box, {
    mt: 4
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "h3"
  }, "Identifying the responsible workload"), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "After identifying the cloud product, use the corresponding product panel in Cost Insights to find a particular workload (or ", /* @__PURE__ */ React.createElement("i", null, "entity"), ") that has grown in cost:"), /* @__PURE__ */ React.createElement(Box, {
    mt: 2,
    mb: 2
  }, /* @__PURE__ */ React.createElement(InfoCard, {
    title: product.name,
    subheader: "3 entities, sorted by cost"
  }, /* @__PURE__ */ React.createElement(ProductInsightsChart, {
    billingDate: today,
    duration: Duration.P3M,
    entity
  }))), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "From here, you can dig into commit history or deployment logs to find probable causes of an unexpected spike in cost.")), /* @__PURE__ */ React.createElement(Box, {
    mt: 4
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "h3"
  }, "Optimizing the workload"), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "Workload optimization varies between cloud products, but there are a few general optimization areas to consider:"), /* @__PURE__ */ React.createElement(Typography, {
    variant: "h5"
  }, "Retention"), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "Is the workload or storage necessary? Truly idle or unused resources can be cleaned up for immediate cost savings. For storage, how long do we need the data? Many cloud products support retention policies to automatically delete data after a certain time period."), /* @__PURE__ */ React.createElement(Typography, {
    variant: "h5"
  }, "Efficiency"), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "Is the workload using cloud resources efficiently? For compute resources, do the utilization metrics look reasonable? Autoscaling infrastructure, such as Kubernetes, can run workloads more efficiently without compromising reliability."), /* @__PURE__ */ React.createElement(Typography, {
    variant: "h5"
  }, "Lifecycle"), /* @__PURE__ */ React.createElement(Typography, {
    paragraph: true
  }, "Is the workload using an optimal pricing model? Some cloud products offer better pricing for data that is accessed less frequently.")));
};

const KubernetesMigrationBarChartLegend = ({
  currentProduct,
  comparedProduct,
  change,
  startDate
}) => {
  const theme = useTheme();
  return /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    flexDirection: "row"
  }, /* @__PURE__ */ React.createElement(Box, {
    marginRight: 2
  }, /* @__PURE__ */ React.createElement(LegendItem, {
    title: monthOf(startDate),
    markerColor: theme.palette.magenta
  }, currentProduct)), /* @__PURE__ */ React.createElement(Box, {
    marginRight: 2
  }, /* @__PURE__ */ React.createElement(LegendItem, {
    title: "Estimated Cost",
    markerColor: theme.palette.yellow
  }, comparedProduct)), /* @__PURE__ */ React.createElement(LegendItem, {
    title: "Total Savings"
  }, /* @__PURE__ */ React.createElement(CostGrowth, {
    change,
    duration: Duration.P30D
  })));
};

const KubernetesMigrationBarChart = ({
  currentProduct,
  comparedProduct,
  services
}) => {
  const theme = useTheme();
  const options = {
    previousFill: theme.palette.magenta,
    currentFill: theme.palette.yellow,
    previousName: comparedProduct,
    currentName: currentProduct
  };
  const resources = services.map((service) => ({
    name: service.id,
    previous: service.aggregation[0],
    current: service.aggregation[1]
  }));
  return /* @__PURE__ */ React.createElement(BarChart, {
    resources,
    options
  });
};

const KubernetesMigrationAlertCard = ({
  data,
  title,
  subheader,
  currentProduct,
  comparedProduct
}) => {
  return /* @__PURE__ */ React.createElement(InfoCard, {
    title,
    subheader
  }, /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    flexDirection: "column"
  }, /* @__PURE__ */ React.createElement(Box, {
    paddingY: 1
  }, /* @__PURE__ */ React.createElement(KubernetesMigrationBarChartLegend, {
    startDate: data.startDate,
    change: data.change,
    currentProduct,
    comparedProduct
  })), /* @__PURE__ */ React.createElement(Box, {
    paddingY: 1
  }, /* @__PURE__ */ React.createElement(KubernetesMigrationBarChart, {
    services: data.services,
    currentProduct,
    comparedProduct
  }))));
};

const KubernetesMigrationDismissForm = forwardRef(({onSubmit, disableSubmit, alert}, ref) => {
  const [services, setServices] = useState(alert.data.services);
  const onFormSubmit = (e) => {
    e.preventDefault();
    onSubmit({services});
  };
  const onCheckboxChange = (e, checked) => {
    if (checked) {
      const service = findAlways(alert.data.services, (s) => s.id === e.target.value);
      setServices((prevServices) => prevServices.concat(service));
    } else {
      setServices((prevServices) => prevServices.filter((p) => p.id !== e.target.value));
    }
  };
  useEffect(() => {
    if (services.length) {
      disableSubmit(false);
    } else {
      disableSubmit(true);
    }
  }, [services, disableSubmit]);
  return /* @__PURE__ */ React.createElement("form", {
    ref,
    onSubmit: onFormSubmit
  }, /* @__PURE__ */ React.createElement(FormControl, {
    component: "fieldset",
    fullWidth: true
  }, /* @__PURE__ */ React.createElement(Typography, {
    color: "textPrimary"
  }, /* @__PURE__ */ React.createElement("b", null, "Or choose which services to dismiss this alert for.")), /* @__PURE__ */ React.createElement(FormGroup, null, alert.data.services.map((service, index) => /* @__PURE__ */ React.createElement(FormControlLabel, {
    key: `example-option-${index}`,
    label: service.id,
    value: service.id,
    control: /* @__PURE__ */ React.createElement(Checkbox, {
      color: "primary",
      checked: services.some((p) => p.id === service.id),
      onChange: onCheckboxChange
    })
  })))));
});

class KubernetesMigrationAlert {
  constructor(api, data) {
    this.subtitle = "Services running on Kubernetes are estimated to save 50% or more compared to Compute Engine.";
    this.AcceptForm = null;
    this.DismissForm = KubernetesMigrationDismissForm;
    this.api = api;
    this.data = data;
  }
  get title() {
    return /* @__PURE__ */ React.createElement("span", null, "Consider migrating", " ", pluralize("service", this.data.services.length, true), " to Kubernetes", " ", /* @__PURE__ */ React.createElement(Lifecycle, {
      shorthand: true
    }));
  }
  get element() {
    const subheader = `${pluralize("Service", this.data.services.length, true)}, sorted by cost`;
    return /* @__PURE__ */ React.createElement(KubernetesMigrationAlertCard, {
      data: this.data,
      title: "Migrate to Kubernetes",
      subheader,
      currentProduct: "Compute Engine",
      comparedProduct: "Kubernetes"
    });
  }
  async onDismissed(options) {
    const alerts = await this.api.getAlerts(options.group);
    return new Promise((resolve) => setTimeout(resolve, 750, [
      ...alerts.filter((a) => a.title !== this.title),
      {
        title: this.title,
        subtitle: this.subtitle,
        status: AlertStatus.Dismissed
      }
    ]));
  }
  async onSnoozed(options) {
    const alerts = await this.api.getAlerts(options.group);
    return new Promise((resolve) => setTimeout(resolve, 750, [
      ...alerts.filter((a) => a.title !== this.title),
      {
        title: this.title,
        subtitle: this.subtitle,
        status: AlertStatus.Snoozed
      }
    ]));
  }
  async onAccepted(options) {
    const alerts = await this.api.getAlerts(options.group);
    return new Promise((resolve) => setTimeout(resolve, 750, [
      ...alerts.filter((a) => a.title !== this.title),
      {
        title: this.title,
        subtitle: this.subtitle,
        status: AlertStatus.Accepted
      }
    ]));
  }
}

const createMockProduct = (callback) => {
  const defaultProduct = {
    kind: "compute-engine",
    name: "Compute Engine"
  };
  if (typeof callback === "function") {
    return callback({...defaultProduct});
  }
  return {...defaultProduct};
};
const MockProductTypes = {
  "compute-engine": "Compute Engine",
  "cloud-dataflow": "Cloud Dataflow",
  "cloud-storage": "Cloud Storage",
  "big-query": "Big Query",
  "big-table": "BigTable",
  "cloud-pub-sub": "Cloud Pub/Sub"
};
const MockProducts = Object.keys(MockProductTypes).map((productType) => createMockProduct(() => ({
  kind: productType,
  name: MockProductTypes[productType]
})));
findAlways(MockProducts, (p) => p.kind === "compute-engine");
findAlways(MockProducts, (p) => p.kind === "cloud-dataflow");
findAlways(MockProducts, (p) => p.kind === "cloud-storage");
findAlways(MockProducts, (p) => p.kind === "big-query");
findAlways(MockProducts, (p) => p.kind === "big-table");

Object.keys(MockProductTypes).map((productType) => ({duration: Duration.P30D, productType}));

const MockDefaultLoadingActions = [
  DefaultLoadingAction.UserGroups,
  DefaultLoadingAction.CostInsightsInitial,
  DefaultLoadingAction.CostInsightsPage
].concat(MockProducts.map((product) => product.kind));
getDefaultState(MockDefaultLoadingActions);

const MockBigQueryInsights = {
  id: "bigQuery",
  aggregation: [1e4, 3e4],
  change: {
    ratio: 3,
    amount: 2e4
  },
  entities: {
    dataset: [
      {
        id: "dataset-a",
        aggregation: [5e3, 1e4],
        change: {
          ratio: 1,
          amount: 5e3
        },
        entities: {}
      },
      {
        id: "dataset-b",
        aggregation: [5e3, 1e4],
        change: {
          ratio: 1,
          amount: 5e3
        },
        entities: {}
      },
      {
        id: "dataset-c",
        aggregation: [0, 1e4],
        change: {
          amount: 1e4
        },
        entities: {}
      }
    ]
  }
};
const MockCloudDataflowInsights = {
  id: "cloudDataflow",
  aggregation: [1e5, 158e3],
  change: {
    ratio: 0.58,
    amount: 58e3
  },
  entities: {
    pipeline: [
      {
        id: null,
        aggregation: [1e4, 12e3],
        change: {
          ratio: 0.2,
          amount: 2e3
        },
        entities: {
          SKU: [
            {
              id: "Mock SKU A",
              aggregation: [3e3, 4e3],
              change: {
                ratio: 0.333333,
                amount: 1e3
              },
              entities: {}
            },
            {
              id: "Mock SKU B",
              aggregation: [7e3, 8e3],
              change: {
                ratio: 0.14285714,
                amount: 1e3
              },
              entities: {}
            }
          ]
        }
      },
      {
        id: "pipeline-a",
        aggregation: [6e4, 7e4],
        change: {
          ratio: 0.16666666666666666,
          amount: 1e4
        },
        entities: {
          SKU: [
            {
              id: "Mock SKU A",
              aggregation: [2e4, 15e3],
              change: {
                ratio: -0.25,
                amount: -5e3
              },
              entities: {}
            },
            {
              id: "Mock SKU B",
              aggregation: [3e4, 35e3],
              change: {
                ratio: -0.16666666666666666,
                amount: -5e3
              },
              entities: {}
            },
            {
              id: "Mock SKU C",
              aggregation: [1e4, 2e4],
              change: {
                ratio: 1,
                amount: 1e4
              },
              entities: {}
            }
          ]
        }
      },
      {
        id: "pipeline-b",
        aggregation: [12e3, 8e3],
        change: {
          ratio: -0.33333,
          amount: -4e3
        },
        entities: {
          SKU: [
            {
              id: "Mock SKU A",
              aggregation: [4e3, 4e3],
              change: {
                ratio: 0,
                amount: 0
              },
              entities: {}
            },
            {
              id: "Mock SKU B",
              aggregation: [8e3, 4e3],
              change: {
                ratio: -0.5,
                amount: -4e3
              },
              entities: {}
            }
          ]
        }
      },
      {
        id: "pipeline-c",
        aggregation: [0, 1e4],
        change: {
          amount: 1e4
        },
        entities: {}
      }
    ]
  }
};
const MockCloudStorageInsights = {
  id: "cloudStorage",
  aggregation: [45e3, 45e3],
  change: {
    ratio: 0,
    amount: 0
  },
  entities: {
    bucket: [
      {
        id: "bucket-a",
        aggregation: [15e3, 2e4],
        change: {
          ratio: 0.333,
          amount: 5e3
        },
        entities: {
          SKU: [
            {
              id: "Mock SKU A",
              aggregation: [1e4, 11e3],
              change: {
                ratio: 0.1,
                amount: 1e3
              },
              entities: {}
            },
            {
              id: "Mock SKU B",
              aggregation: [2e3, 5e3],
              change: {
                ratio: 1.5,
                amount: 3e3
              },
              entities: {}
            },
            {
              id: "Mock SKU C",
              aggregation: [3e3, 4e3],
              change: {
                ratio: 0.3333,
                amount: 1e3
              },
              entities: {}
            }
          ]
        }
      },
      {
        id: "bucket-b",
        aggregation: [3e4, 25e3],
        change: {
          ratio: -0.16666,
          amount: -5e3
        },
        entities: {
          SKU: [
            {
              id: "Mock SKU A",
              aggregation: [12e3, 13e3],
              change: {
                ratio: 0.08333333333333333,
                amount: 1e3
              },
              entities: {}
            },
            {
              id: "Mock SKU B",
              aggregation: [16e3, 12e3],
              change: {
                ratio: -0.25,
                amount: -4e3
              },
              entities: {}
            },
            {
              id: "Mock SKU C",
              aggregation: [2e3, 0],
              change: {
                amount: -2e3
              },
              entities: {}
            }
          ]
        }
      },
      {
        id: "bucket-c",
        aggregation: [0, 0],
        change: {
          amount: 0
        },
        entities: {}
      }
    ]
  }
};
const MockComputeEngineInsights = {
  id: "computeEngine",
  aggregation: [8e4, 9e4],
  change: {
    ratio: 0.125,
    amount: 1e4
  },
  entities: {
    service: [
      {
        id: "service-a",
        aggregation: [2e4, 1e4],
        change: {
          ratio: -0.5,
          amount: -1e4
        },
        entities: {
          SKU: [
            {
              id: "Mock SKU A",
              aggregation: [4e3, 2e3],
              change: {
                ratio: -0.5,
                amount: -2e3
              },
              entities: {}
            },
            {
              id: "Mock SKU B",
              aggregation: [7e3, 6e3],
              change: {
                ratio: -0.14285714285714285,
                amount: -1e3
              },
              entities: {}
            },
            {
              id: "Mock SKU C",
              aggregation: [9e3, 2e3],
              change: {
                ratio: -0.7777777777777778,
                amount: -7e3
              },
              entities: {}
            }
          ],
          deployment: [
            {
              id: "Compute Engine",
              aggregation: [7e3, 6e3],
              change: {
                ratio: -0.5,
                amount: -2e3
              },
              entities: {}
            },
            {
              id: "Kubernetes",
              aggregation: [4e3, 2e3],
              change: {
                ratio: -0.14285714285714285,
                amount: -1e3
              },
              entities: {}
            }
          ]
        }
      },
      {
        id: "service-b",
        aggregation: [1e4, 2e4],
        change: {
          ratio: 1,
          amount: 1e4
        },
        entities: {
          SKU: [
            {
              id: "Mock SKU A",
              aggregation: [1e3, 2e3],
              change: {
                ratio: 1,
                amount: 1e3
              },
              entities: {}
            },
            {
              id: "Mock SKU B",
              aggregation: [4e3, 8e3],
              change: {
                ratio: 1,
                amount: 4e3
              },
              entities: {}
            },
            {
              id: "Mock SKU C",
              aggregation: [5e3, 1e4],
              change: {
                ratio: 1,
                amount: 5e3
              },
              entities: {}
            }
          ],
          deployment: [
            {
              id: "Compute Engine",
              aggregation: [7e3, 6e3],
              change: {
                ratio: -0.5,
                amount: -2e3
              },
              entities: {}
            },
            {
              id: "Kubernetes",
              aggregation: [4e3, 2e3],
              change: {
                ratio: -0.14285714285714285,
                amount: -1e3
              },
              entities: {}
            }
          ]
        }
      },
      {
        id: "service-c",
        aggregation: [0, 1e4],
        change: {
          amount: 1e4
        },
        entities: {}
      }
    ]
  }
};
const MockEventsInsights = {
  id: "events",
  aggregation: [2e4, 1e4],
  change: {
    ratio: -0.5,
    amount: -1e4
  },
  entities: {
    event: [
      {
        id: "event-a",
        aggregation: [15e3, 7e3],
        change: {
          ratio: -0.53333333333,
          amount: -8e3
        },
        entities: {
          product: [
            {
              id: "Mock Product A",
              aggregation: [5e3, 2e3],
              change: {
                ratio: -0.6,
                amount: -3e3
              },
              entities: {}
            },
            {
              id: "Mock Product B",
              aggregation: [7e3, 2500],
              change: {
                ratio: -0.64285714285,
                amount: -4500
              },
              entities: {}
            },
            {
              id: "Mock Product C",
              aggregation: [3e3, 2500],
              change: {
                ratio: -0.16666666666,
                amount: -500
              },
              entities: {}
            }
          ]
        }
      },
      {
        id: "event-b",
        aggregation: [5e3, 3e3],
        change: {
          ratio: -0.4,
          amount: -2e3
        },
        entities: {
          product: [
            {
              id: "Mock Product A",
              aggregation: [2e3, 1e3],
              change: {
                ratio: -0.5,
                amount: -1e3
              },
              entities: {}
            },
            {
              id: "Mock Product B",
              aggregation: [1e3, 1500],
              change: {
                ratio: 0.5,
                amount: 500
              },
              entities: {}
            },
            {
              id: "Mock Product C",
              aggregation: [2e3, 500],
              change: {
                ratio: -0.75,
                amount: -1500
              },
              entities: {}
            }
          ]
        }
      }
    ]
  }
};

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}var AsyncMode=l;var ConcurrentMode=m;var ContextConsumer=k;var ContextProvider=h;var Element=c;var ForwardRef=n;var Fragment=e;var Lazy=t;var Memo=r;var Portal=d;
var Profiler=g;var StrictMode=f;var Suspense=p;var isAsyncMode=function(a){return A(a)||z(a)===l};var isConcurrentMode=A;var isContextConsumer=function(a){return z(a)===k};var isContextProvider=function(a){return z(a)===h};var isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};var isForwardRef=function(a){return z(a)===n};var isFragment=function(a){return z(a)===e};var isLazy=function(a){return z(a)===t};
var isMemo=function(a){return z(a)===r};var isPortal=function(a){return z(a)===d};var isProfiler=function(a){return z(a)===g};var isStrictMode=function(a){return z(a)===f};var isSuspense=function(a){return z(a)===p};
var isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};var typeOf=z;

var reactIs_production_min = {
	AsyncMode: AsyncMode,
	ConcurrentMode: ConcurrentMode,
	ContextConsumer: ContextConsumer,
	ContextProvider: ContextProvider,
	Element: Element,
	ForwardRef: ForwardRef,
	Fragment: Fragment,
	Lazy: Lazy,
	Memo: Memo,
	Portal: Portal,
	Profiler: Profiler,
	StrictMode: StrictMode,
	Suspense: Suspense,
	isAsyncMode: isAsyncMode,
	isConcurrentMode: isConcurrentMode,
	isContextConsumer: isContextConsumer,
	isContextProvider: isContextProvider,
	isElement: isElement,
	isForwardRef: isForwardRef,
	isFragment: isFragment,
	isLazy: isLazy,
	isMemo: isMemo,
	isPortal: isPortal,
	isProfiler: isProfiler,
	isStrictMode: isStrictMode,
	isSuspense: isSuspense,
	isValidElementType: isValidElementType,
	typeOf: typeOf
};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var reactIs_development = createCommonjsModule(function (module, exports) {



if (process.env.NODE_ENV !== "production") {
  (function() {

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}
});

var reactIs = createCommonjsModule(function (module) {

if (process.env.NODE_ENV === 'production') {
  module.exports = reactIs_production_min;
} else {
  module.exports = reactIs_development;
}
});

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret$1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var printWarning$1 = function() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret = ReactPropTypesSecret_1;
  var loggedTypeFailures = {};
  var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning$1 = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (has$1(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning$1(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning$1(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (process.env.NODE_ENV !== 'production') {
    loggedTypeFailures = {};
  }
};

var checkPropTypes_1 = checkPropTypes;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */







var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (process.env.NODE_ENV !== 'production') {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret_1) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!reactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (process.env.NODE_ENV !== 'production') {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = objectAssign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes_1;
  ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret_1) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  }  shim.isRequired = shim;
  function getShim() {
    return shim;
  }  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var propTypes = createCommonjsModule(function (module) {
if (process.env.NODE_ENV !== 'production') {
  var ReactIs = reactIs;

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = factoryWithThrowingShims();
}
});

function getGlobalObject() {
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  return Function("return this")();
}
const globalObject = getGlobalObject();
const makeKey = (id) => `__@backstage/${id}__`;
function getOrCreateGlobalSingleton(id, supplier) {
  const key = makeKey(id);
  let value = globalObject[key];
  if (value) {
    return value;
  }
  value = supplier();
  globalObject[key] = value;
  return value;
}

getOrCreateGlobalSingleton("api-context", () => createContext(void 0));
({
  apis: propTypes.shape({get: propTypes.func.isRequired}).isRequired,
  children: propTypes.node
});

var ScopePriority;
(function(ScopePriority2) {
  ScopePriority2[ScopePriority2["default"] = 10] = "default";
  ScopePriority2[ScopePriority2["app"] = 50] = "app";
  ScopePriority2[ScopePriority2["static"] = 100] = "static";
})(ScopePriority || (ScopePriority = {}));

function showLoginPopup(options) {
  return new Promise((resolve, reject) => {
    const width = options.width || 500;
    const height = options.height || 700;
    const left = window.screen.width / 2 - width / 2;
    const top = window.screen.height / 2 - height / 2;
    const popup = window.open(options.url, options.name, `menubar=no,location=no,resizable=no,scrollbars=no,status=no,width=${width},height=${height},top=${top},left=${left}`);
    let targetOrigin = "";
    if (!popup || typeof popup.closed === "undefined" || popup.closed) {
      const error = new Error("Failed to open auth popup.");
      error.name = "PopupRejectedError";
      reject(error);
      return;
    }
    const messageListener = (event) => {
      if (event.source !== popup) {
        return;
      }
      if (event.origin !== options.origin) {
        return;
      }
      const {data} = event;
      if (data.type === "config_info") {
        targetOrigin = data.targetOrigin;
        return;
      }
      if (data.type !== "authorization_response") {
        return;
      }
      const authResult = data;
      if ("error" in authResult) {
        const error = new Error(authResult.error.message);
        error.name = authResult.error.name;
        reject(error);
      } else {
        resolve(authResult.response);
      }
      done();
    };
    const intervalId = setInterval(() => {
      if (popup.closed) {
        const errMessage = `Login failed, ${targetOrigin && targetOrigin !== window.location.origin ? `Incorrect app origin, expected ${targetOrigin}` : "popup was closed"}`;
        const error = new Error(errMessage);
        error.name = "PopupClosedError";
        reject(error);
        done();
      }
    }, 100);
    function done() {
      window.removeEventListener("message", messageListener);
      clearInterval(intervalId);
    }
    window.addEventListener("message", messageListener);
  });
}

function defaultJoinScopes(scopes) {
  return [...scopes].join(" ");
}
class DefaultAuthConnector {
  constructor(options) {
    const {
      discoveryApi,
      environment,
      provider,
      joinScopes = defaultJoinScopes,
      oauthRequestApi,
      sessionTransform = (id) => id
    } = options;
    this.authRequester = oauthRequestApi.createAuthRequester({
      provider,
      onAuthRequest: (scopes) => this.showPopup(scopes)
    });
    this.discoveryApi = discoveryApi;
    this.environment = environment;
    this.provider = provider;
    this.joinScopesFunc = joinScopes;
    this.sessionTransform = sessionTransform;
  }
  async createSession(options) {
    if (options.instantPopup) {
      return this.showPopup(options.scopes);
    }
    return this.authRequester(options.scopes);
  }
  async refreshSession() {
    const res = await fetch(await this.buildUrl("/refresh", {optional: true}), {
      headers: {
        "x-requested-with": "XMLHttpRequest"
      },
      credentials: "include"
    }).catch((error) => {
      throw new Error(`Auth refresh request failed, ${error}`);
    });
    if (!res.ok) {
      const error = new Error(`Auth refresh request failed, ${res.statusText}`);
      error.status = res.status;
      throw error;
    }
    const authInfo = await res.json();
    if (authInfo.error) {
      const error = new Error(authInfo.error.message);
      if (authInfo.error.name) {
        error.name = authInfo.error.name;
      }
      throw error;
    }
    return await this.sessionTransform(authInfo);
  }
  async removeSession() {
    const res = await fetch(await this.buildUrl("/logout"), {
      method: "POST",
      headers: {
        "x-requested-with": "XMLHttpRequest"
      },
      credentials: "include"
    }).catch((error) => {
      throw new Error(`Logout request failed, ${error}`);
    });
    if (!res.ok) {
      const error = new Error(`Logout request failed, ${res.statusText}`);
      error.status = res.status;
      throw error;
    }
  }
  async showPopup(scopes) {
    const scope = this.joinScopesFunc(scopes);
    const popupUrl = await this.buildUrl("/start", {scope});
    const payload = await showLoginPopup({
      url: popupUrl,
      name: `${this.provider.title} Login`,
      origin: new URL(popupUrl).origin,
      width: 450,
      height: 730
    });
    return await this.sessionTransform(payload);
  }
  async buildUrl(path, query) {
    const baseUrl = await this.discoveryApi.getBaseUrl("auth");
    const queryString = this.buildQueryString({
      ...query,
      env: this.environment
    });
    return `${baseUrl}/${this.provider.id}${path}${queryString}`;
  }
  buildQueryString(query) {
    if (!query) {
      return "";
    }
    const queryString = Object.entries(query).map(([key, value]) => {
      if (typeof value === "string") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      } else if (value) {
        return encodeURIComponent(key);
      }
      return void 0;
    }).filter(Boolean).join("&");
    if (!queryString) {
      return "";
    }
    return `?${queryString}`;
  }
}

class DirectAuthConnector {
  constructor(options) {
    const {discoveryApi, environment, provider} = options;
    this.discoveryApi = discoveryApi;
    this.environment = environment;
    this.provider = provider;
  }
  async createSession() {
    const popupUrl = await this.buildUrl("/start");
    const payload = await showLoginPopup({
      url: popupUrl,
      name: `${this.provider.title} Login`,
      origin: new URL(popupUrl).origin,
      width: 450,
      height: 730
    });
    return {
      ...payload,
      id: payload.profile.email
    };
  }
  async refreshSession() {
  }
  async removeSession() {
    const res = await fetch(await this.buildUrl("/logout"), {
      method: "POST",
      headers: {
        "x-requested-with": "XMLHttpRequest"
      },
      credentials: "include"
    }).catch((error) => {
      throw new Error(`Logout request failed, ${error}`);
    });
    if (!res.ok) {
      const error = new Error(`Logout request failed, ${res.statusText}`);
      error.status = res.status;
      throw error;
    }
  }
  async buildUrl(path) {
    const baseUrl = await this.discoveryApi.getBaseUrl("auth");
    return `${baseUrl}/${this.provider.id}${path}?env=${this.environment}`;
  }
}

function hasScopes$1(searched, searchFor) {
  for (const scope of searchFor) {
    if (!searched.has(scope)) {
      return false;
    }
  }
  return true;
}
class SessionScopeHelper {
  constructor(options) {
    this.options = options;
  }
  sessionExistsAndHasScope(session, scopes) {
    if (!session) {
      return false;
    }
    if (!scopes) {
      return true;
    }
    if (this.options.sessionScopes === void 0) {
      return true;
    }
    const sessionScopes = this.options.sessionScopes(session);
    return hasScopes$1(sessionScopes, scopes);
  }
  getExtendedScope(session, scopes) {
    const newScope = new Set(this.options.defaultScopes);
    if (session && this.options.sessionScopes !== void 0) {
      const sessionScopes = this.options.sessionScopes(session);
      for (const scope of sessionScopes) {
        newScope.add(scope);
      }
    }
    if (scopes) {
      for (const scope of scopes) {
        newScope.add(scope);
      }
    }
    return newScope;
  }
}

var Observable_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Observable = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// === Symbol Support ===
var hasSymbols = function () {
  return typeof Symbol === 'function';
};

var hasSymbol = function (name) {
  return hasSymbols() && Boolean(Symbol[name]);
};

var getSymbol = function (name) {
  return hasSymbol(name) ? Symbol[name] : '@@' + name;
};

if (hasSymbols() && !hasSymbol('observable')) {
  Symbol.observable = Symbol('observable');
}

var SymbolIterator = getSymbol('iterator');
var SymbolObservable = getSymbol('observable');
var SymbolSpecies = getSymbol('species'); // === Abstract Operations ===

function getMethod(obj, key) {
  var value = obj[key];
  if (value == null) return undefined;
  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');
  return value;
}

function getSpecies(obj) {
  var ctor = obj.constructor;

  if (ctor !== undefined) {
    ctor = ctor[SymbolSpecies];

    if (ctor === null) {
      ctor = undefined;
    }
  }

  return ctor !== undefined ? ctor : Observable;
}

function isObservable(x) {
  return x instanceof Observable; // SPEC: Brand check
}

function hostReportError(e) {
  if (hostReportError.log) {
    hostReportError.log(e);
  } else {
    setTimeout(function () {
      throw e;
    });
  }
}

function enqueue(fn) {
  Promise.resolve().then(function () {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}

function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === undefined) return;
  subscription._cleanup = undefined;

  if (!cleanup) {
    return;
  }

  try {
    if (typeof cleanup === 'function') {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, 'unsubscribe');

      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}

function closeSubscription(subscription) {
  subscription._observer = undefined;
  subscription._queue = undefined;
  subscription._state = 'closed';
}

function flushSubscription(subscription) {
  var queue = subscription._queue;

  if (!queue) {
    return;
  }

  subscription._queue = undefined;
  subscription._state = 'ready';

  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === 'closed') break;
  }
}

function notifySubscription(subscription, type, value) {
  subscription._state = 'running';
  var observer = subscription._observer;

  try {
    var m = getMethod(observer, type);

    switch (type) {
      case 'next':
        if (m) m.call(observer, value);
        break;

      case 'error':
        closeSubscription(subscription);
        if (m) m.call(observer, value);else throw value;
        break;

      case 'complete':
        closeSubscription(subscription);
        if (m) m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }

  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';
}

function onNotify(subscription, type, value) {
  if (subscription._state === 'closed') return;

  if (subscription._state === 'buffering') {
    subscription._queue.push({
      type: type,
      value: value
    });

    return;
  }

  if (subscription._state !== 'ready') {
    subscription._state = 'buffering';
    subscription._queue = [{
      type: type,
      value: value
    }];
    enqueue(function () {
      return flushSubscription(subscription);
    });
    return;
  }

  notifySubscription(subscription, type, value);
}

var Subscription =
/*#__PURE__*/
function () {
  function Subscription(observer, subscriber) {
    _classCallCheck(this, Subscription);

    // ASSERT: observer is an object
    // ASSERT: subscriber is callable
    this._cleanup = undefined;
    this._observer = observer;
    this._queue = undefined;
    this._state = 'initializing';
    var subscriptionObserver = new SubscriptionObserver(this);

    try {
      this._cleanup = subscriber.call(undefined, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }

    if (this._state === 'initializing') this._state = 'ready';
  }

  _createClass(Subscription, [{
    key: "unsubscribe",
    value: function unsubscribe() {
      if (this._state !== 'closed') {
        closeSubscription(this);
        cleanupSubscription(this);
      }
    }
  }, {
    key: "closed",
    get: function () {
      return this._state === 'closed';
    }
  }]);

  return Subscription;
}();

var SubscriptionObserver =
/*#__PURE__*/
function () {
  function SubscriptionObserver(subscription) {
    _classCallCheck(this, SubscriptionObserver);

    this._subscription = subscription;
  }

  _createClass(SubscriptionObserver, [{
    key: "next",
    value: function next(value) {
      onNotify(this._subscription, 'next', value);
    }
  }, {
    key: "error",
    value: function error(value) {
      onNotify(this._subscription, 'error', value);
    }
  }, {
    key: "complete",
    value: function complete() {
      onNotify(this._subscription, 'complete');
    }
  }, {
    key: "closed",
    get: function () {
      return this._subscription._state === 'closed';
    }
  }]);

  return SubscriptionObserver;
}();

var Observable =
/*#__PURE__*/
function () {
  function Observable(subscriber) {
    _classCallCheck(this, Observable);

    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');
    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');
    this._subscriber = subscriber;
  }

  _createClass(Observable, [{
    key: "subscribe",
    value: function subscribe(observer) {
      if (typeof observer !== 'object' || observer === null) {
        observer = {
          next: observer,
          error: arguments[1],
          complete: arguments[2]
        };
      }

      return new Subscription(observer, this._subscriber);
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (typeof fn !== 'function') {
          reject(new TypeError(fn + ' is not a function'));
          return;
        }

        function done() {
          subscription.unsubscribe();
          resolve();
        }

        var subscription = _this.subscribe({
          next: function (value) {
            try {
              fn(value, done);
            } catch (e) {
              reject(e);
              subscription.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
      });
    }
  }, {
    key: "map",
    value: function map(fn) {
      var _this2 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      return new C(function (observer) {
        return _this2.subscribe({
          next: function (value) {
            try {
              value = fn(value);
            } catch (e) {
              return observer.error(e);
            }

            observer.next(value);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: "filter",
    value: function filter(fn) {
      var _this3 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      return new C(function (observer) {
        return _this3.subscribe({
          next: function (value) {
            try {
              if (!fn(value)) return;
            } catch (e) {
              return observer.error(e);
            }

            observer.next(value);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: "reduce",
    value: function reduce(fn) {
      var _this4 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      var hasSeed = arguments.length > 1;
      var hasValue = false;
      var seed = arguments[1];
      var acc = seed;
      return new C(function (observer) {
        return _this4.subscribe({
          next: function (value) {
            var first = !hasValue;
            hasValue = true;

            if (!first || hasSeed) {
              try {
                acc = fn(acc, value);
              } catch (e) {
                return observer.error(e);
              }
            } else {
              acc = value;
            }
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));
            observer.next(acc);
            observer.complete();
          }
        });
      });
    }
  }, {
    key: "concat",
    value: function concat() {
      var _this5 = this;

      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }

      var C = getSpecies(this);
      return new C(function (observer) {
        var subscription;
        var index = 0;

        function startNext(next) {
          subscription = next.subscribe({
            next: function (v) {
              observer.next(v);
            },
            error: function (e) {
              observer.error(e);
            },
            complete: function () {
              if (index === sources.length) {
                subscription = undefined;
                observer.complete();
              } else {
                startNext(C.from(sources[index++]));
              }
            }
          });
        }

        startNext(_this5);
        return function () {
          if (subscription) {
            subscription.unsubscribe();
            subscription = undefined;
          }
        };
      });
    }
  }, {
    key: "flatMap",
    value: function flatMap(fn) {
      var _this6 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      return new C(function (observer) {
        var subscriptions = [];

        var outer = _this6.subscribe({
          next: function (value) {
            if (fn) {
              try {
                value = fn(value);
              } catch (e) {
                return observer.error(e);
              }
            }

            var inner = C.from(value).subscribe({
              next: function (value) {
                observer.next(value);
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                var i = subscriptions.indexOf(inner);
                if (i >= 0) subscriptions.splice(i, 1);
                completeIfDone();
              }
            });
            subscriptions.push(inner);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            completeIfDone();
          }
        });

        function completeIfDone() {
          if (outer.closed && subscriptions.length === 0) observer.complete();
        }

        return function () {
          subscriptions.forEach(function (s) {
            return s.unsubscribe();
          });
          outer.unsubscribe();
        };
      });
    }
  }, {
    key: SymbolObservable,
    value: function () {
      return this;
    }
  }], [{
    key: "from",
    value: function from(x) {
      var C = typeof this === 'function' ? this : Observable;
      if (x == null) throw new TypeError(x + ' is not an object');
      var method = getMethod(x, SymbolObservable);

      if (method) {
        var observable = method.call(x);
        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');
        if (isObservable(observable) && observable.constructor === C) return observable;
        return new C(function (observer) {
          return observable.subscribe(observer);
        });
      }

      if (hasSymbol('iterator')) {
        method = getMethod(x, SymbolIterator);

        if (method) {
          return new C(function (observer) {
            enqueue(function () {
              if (observer.closed) return;
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var _item = _step.value;
                  observer.next(_item);
                  if (observer.closed) return;
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              observer.complete();
            });
          });
        }
      }

      if (Array.isArray(x)) {
        return new C(function (observer) {
          enqueue(function () {
            if (observer.closed) return;

            for (var i = 0; i < x.length; ++i) {
              observer.next(x[i]);
              if (observer.closed) return;
            }

            observer.complete();
          });
        });
      }

      throw new TypeError(x + ' is not observable');
    }
  }, {
    key: "of",
    value: function of() {
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }

      var C = typeof this === 'function' ? this : Observable;
      return new C(function (observer) {
        enqueue(function () {
          if (observer.closed) return;

          for (var i = 0; i < items.length; ++i) {
            observer.next(items[i]);
            if (observer.closed) return;
          }

          observer.complete();
        });
      });
    }
  }, {
    key: SymbolSpecies,
    get: function () {
      return this;
    }
  }]);

  return Observable;
}();

exports.Observable = Observable;

if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol('extensions'), {
    value: {
      symbol: SymbolObservable,
      hostReportError: hostReportError
    },
    configurable: true
  });
}
});

var zenObservable = Observable_1.Observable;

class PublishSubject {
  constructor() {
    this.isClosed = false;
    this.observable = new zenObservable((subscriber) => {
      if (this.isClosed) {
        if (this.terminatingError) {
          subscriber.error(this.terminatingError);
        } else {
          subscriber.complete();
        }
        return () => {
        };
      }
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
    this.subscribers = new Set();
  }
  [Symbol.observable]() {
    return this;
  }
  get closed() {
    return this.isClosed;
  }
  next(value) {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.subscribers.forEach((subscriber) => subscriber.next(value));
  }
  error(error) {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.isClosed = true;
    this.terminatingError = error;
    this.subscribers.forEach((subscriber) => subscriber.error(error));
  }
  complete() {
    if (this.isClosed) {
      throw new Error("PublishSubject is closed");
    }
    this.isClosed = true;
    this.subscribers.forEach((subscriber) => subscriber.complete());
  }
  subscribe(onNext, onError, onComplete) {
    const observer = typeof onNext === "function" ? {
      next: onNext,
      error: onError,
      complete: onComplete
    } : onNext;
    return this.observable.subscribe(observer);
  }
}
class BehaviorSubject {
  constructor(value) {
    this.isClosed = false;
    this.observable = new zenObservable((subscriber) => {
      if (this.isClosed) {
        if (this.terminatingError) {
          subscriber.error(this.terminatingError);
        } else {
          subscriber.complete();
        }
        return () => {
        };
      }
      subscriber.next(this.currentValue);
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
    this.subscribers = new Set();
    this.currentValue = value;
  }
  [Symbol.observable]() {
    return this;
  }
  get closed() {
    return this.isClosed;
  }
  next(value) {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.currentValue = value;
    this.subscribers.forEach((subscriber) => subscriber.next(value));
  }
  error(error) {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.isClosed = true;
    this.terminatingError = error;
    this.subscribers.forEach((subscriber) => subscriber.error(error));
  }
  complete() {
    if (this.isClosed) {
      throw new Error("BehaviorSubject is closed");
    }
    this.isClosed = true;
    this.subscribers.forEach((subscriber) => subscriber.complete());
  }
  subscribe(onNext, onError, onComplete) {
    const observer = typeof onNext === "function" ? {
      next: onNext,
      error: onError,
      complete: onComplete
    } : onNext;
    return this.observable.subscribe(observer);
  }
}

class SessionStateTracker {
  constructor() {
    this.subject = new BehaviorSubject(SessionState.SignedOut);
    this.signedIn = false;
  }
  setIsSignedIn(isSignedIn) {
    if (this.signedIn !== isSignedIn) {
      this.signedIn = isSignedIn;
      this.subject.next(this.signedIn ? SessionState.SignedIn : SessionState.SignedOut);
    }
  }
  sessionState$() {
    return this.subject;
  }
}

class RefreshingAuthSessionManager {
  constructor(options) {
    this.stateTracker = new SessionStateTracker();
    const {
      connector,
      defaultScopes = new Set(),
      sessionScopes,
      sessionShouldRefresh
    } = options;
    this.connector = connector;
    this.sessionScopesFunc = sessionScopes;
    this.sessionShouldRefreshFunc = sessionShouldRefresh;
    this.helper = new SessionScopeHelper({sessionScopes, defaultScopes});
  }
  async getSession(options) {
    if (this.helper.sessionExistsAndHasScope(this.currentSession, options.scopes)) {
      const shouldRefresh = this.sessionShouldRefreshFunc(this.currentSession);
      if (!shouldRefresh) {
        return this.currentSession;
      }
      try {
        const refreshedSession = await this.collapsedSessionRefresh();
        const currentScopes = this.sessionScopesFunc(this.currentSession);
        const refreshedScopes = this.sessionScopesFunc(refreshedSession);
        if (hasScopes$1(refreshedScopes, currentScopes)) {
          this.currentSession = refreshedSession;
        }
        return refreshedSession;
      } catch (error) {
        if (options.optional) {
          return void 0;
        }
        throw error;
      }
    }
    if (!this.currentSession && !options.instantPopup) {
      try {
        const newSession = await this.collapsedSessionRefresh();
        this.currentSession = newSession;
        return this.getSession(options);
      } catch {
      }
    }
    if (options.optional) {
      return void 0;
    }
    this.currentSession = await this.connector.createSession({
      ...options,
      scopes: this.helper.getExtendedScope(this.currentSession, options.scopes)
    });
    this.stateTracker.setIsSignedIn(true);
    return this.currentSession;
  }
  async removeSession() {
    this.currentSession = void 0;
    await this.connector.removeSession();
    this.stateTracker.setIsSignedIn(false);
  }
  sessionState$() {
    return this.stateTracker.sessionState$();
  }
  async collapsedSessionRefresh() {
    if (this.refreshPromise) {
      return this.refreshPromise;
    }
    this.refreshPromise = this.connector.refreshSession();
    try {
      const session = await this.refreshPromise;
      this.stateTracker.setIsSignedIn(true);
      return session;
    } finally {
      delete this.refreshPromise;
    }
  }
}

class StaticAuthSessionManager {
  constructor(options) {
    this.stateTracker = new SessionStateTracker();
    const {connector, defaultScopes = new Set(), sessionScopes} = options;
    this.connector = connector;
    this.helper = new SessionScopeHelper({sessionScopes, defaultScopes});
  }
  setSession(session) {
    this.currentSession = session;
    this.stateTracker.setIsSignedIn(Boolean(session));
  }
  async getSession(options) {
    if (this.helper.sessionExistsAndHasScope(this.currentSession, options.scopes)) {
      return this.currentSession;
    }
    if (options.optional) {
      return void 0;
    }
    this.currentSession = await this.connector.createSession({
      ...options,
      scopes: this.helper.getExtendedScope(this.currentSession, options.scopes)
    });
    this.stateTracker.setIsSignedIn(true);
    return this.currentSession;
  }
  async removeSession() {
    this.currentSession = void 0;
    await this.connector.removeSession();
    this.stateTracker.setIsSignedIn(false);
  }
  sessionState$() {
    return this.stateTracker.sessionState$();
  }
}

class AuthSessionStore {
  constructor(options) {
    const {
      manager,
      storageKey,
      sessionScopes,
      sessionShouldRefresh = () => false
    } = options;
    this.manager = manager;
    this.storageKey = storageKey;
    this.sessionShouldRefreshFunc = sessionShouldRefresh;
    this.helper = new SessionScopeHelper({
      sessionScopes,
      defaultScopes: new Set()
    });
  }
  async getSession(options) {
    const {scopes} = options;
    const session = this.loadSession();
    if (this.helper.sessionExistsAndHasScope(session, scopes)) {
      const shouldRefresh = this.sessionShouldRefreshFunc(session);
      if (!shouldRefresh) {
        this.manager.setSession(session);
        return session;
      }
    }
    const newSession = await this.manager.getSession(options);
    this.saveSession(newSession);
    return newSession;
  }
  async removeSession() {
    localStorage.removeItem(this.storageKey);
    await this.manager.removeSession();
  }
  sessionState$() {
    return this.manager.sessionState$();
  }
  loadSession() {
    try {
      const sessionJson = localStorage.getItem(this.storageKey);
      if (sessionJson) {
        const session = JSON.parse(sessionJson, (_key, value) => {
          if ((value == null ? void 0 : value.__type) === "Set") {
            return new Set(value.__value);
          }
          return value;
        });
        return session;
      }
      return void 0;
    } catch (error) {
      localStorage.removeItem(this.storageKey);
      return void 0;
    }
  }
  saveSession(session) {
    if (session === void 0) {
      localStorage.removeItem(this.storageKey);
    } else {
      localStorage.setItem(this.storageKey, JSON.stringify(session, (_key, value) => {
        if (value instanceof Set) {
          return {
            __type: "Set",
            __value: Array.from(value)
          };
        }
        return value;
      }));
    }
  }
}

const DEFAULT_PROVIDER$8 = {
  id: "github",
  title: "GitHub",
  icon: OAuth2Icon
};
class GithubAuth {
  constructor(sessionManager) {
    this.sessionManager = sessionManager;
  }
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$8,
    oauthRequestApi,
    defaultScopes = ["read:user"]
  }) {
    const connector = new DefaultAuthConnector({
      discoveryApi,
      environment,
      provider,
      oauthRequestApi,
      sessionTransform(res) {
        return {
          ...res,
          providerInfo: {
            accessToken: res.providerInfo.accessToken,
            scopes: GithubAuth.normalizeScope(res.providerInfo.scope),
            expiresAt: new Date(Date.now() + res.providerInfo.expiresInSeconds * 1e3)
          }
        };
      }
    });
    const sessionManager = new StaticAuthSessionManager({
      connector,
      defaultScopes: new Set(defaultScopes),
      sessionScopes: (session) => session.providerInfo.scopes
    });
    const authSessionStore = new AuthSessionStore({
      manager: sessionManager,
      storageKey: `${provider.id}Session`,
      sessionScopes: (session) => session.providerInfo.scopes
    });
    return new GithubAuth(authSessionStore);
  }
  async signIn() {
    await this.getAccessToken();
  }
  async signOut() {
    await this.sessionManager.removeSession();
  }
  sessionState$() {
    return this.sessionManager.sessionState$();
  }
  async getAccessToken(scope, options) {
    var _a;
    const session = await this.sessionManager.getSession({
      ...options,
      scopes: GithubAuth.normalizeScope(scope)
    });
    return (_a = session == null ? void 0 : session.providerInfo.accessToken) != null ? _a : "";
  }
  async getBackstageIdentity(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.backstageIdentity;
  }
  async getProfile(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.profile;
  }
  static normalizeScope(scope) {
    if (!scope) {
      return new Set();
    }
    const scopeList = Array.isArray(scope) ? scope : scope.split(/[\s|,]/).filter(Boolean);
    return new Set(scopeList);
  }
}

const DEFAULT_PROVIDER$7 = {
  id: "oauth2",
  title: "Your Identity Provider",
  icon: OAuth2Icon
};
class OAuth2 {
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$7,
    oauthRequestApi,
    defaultScopes = [],
    scopeTransform = (x) => x
  }) {
    const connector = new DefaultAuthConnector({
      discoveryApi,
      environment,
      provider,
      oauthRequestApi,
      sessionTransform(res) {
        return {
          ...res,
          providerInfo: {
            idToken: res.providerInfo.idToken,
            accessToken: res.providerInfo.accessToken,
            scopes: OAuth2.normalizeScopes(scopeTransform, res.providerInfo.scope),
            expiresAt: new Date(Date.now() + res.providerInfo.expiresInSeconds * 1e3)
          }
        };
      }
    });
    const sessionManager = new RefreshingAuthSessionManager({
      connector,
      defaultScopes: new Set(defaultScopes),
      sessionScopes: (session) => session.providerInfo.scopes,
      sessionShouldRefresh: (session) => {
        const expiresInSec = (session.providerInfo.expiresAt.getTime() - Date.now()) / 1e3;
        return expiresInSec < 60 * 5;
      }
    });
    return new OAuth2({sessionManager, scopeTransform});
  }
  constructor(options) {
    this.sessionManager = options.sessionManager;
    this.scopeTransform = options.scopeTransform;
  }
  async signIn() {
    await this.getAccessToken();
  }
  async signOut() {
    await this.sessionManager.removeSession();
  }
  sessionState$() {
    return this.sessionManager.sessionState$();
  }
  async getAccessToken(scope, options) {
    var _a;
    const normalizedScopes = OAuth2.normalizeScopes(this.scopeTransform, scope);
    const session = await this.sessionManager.getSession({
      ...options,
      scopes: normalizedScopes
    });
    return (_a = session == null ? void 0 : session.providerInfo.accessToken) != null ? _a : "";
  }
  async getIdToken(options = {}) {
    var _a;
    const session = await this.sessionManager.getSession(options);
    return (_a = session == null ? void 0 : session.providerInfo.idToken) != null ? _a : "";
  }
  async getBackstageIdentity(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.backstageIdentity;
  }
  async getProfile(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.profile;
  }
  static normalizeScopes(scopeTransform, scopes) {
    if (!scopes) {
      return new Set();
    }
    const scopeList = Array.isArray(scopes) ? scopes : scopes.split(/[\s|,]/).filter(Boolean);
    return new Set(scopeTransform(scopeList));
  }
}

const DEFAULT_PROVIDER$6 = {
  id: "gitlab",
  title: "GitLab",
  icon: OAuth2Icon
};
class GitlabAuth {
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$6,
    oauthRequestApi,
    defaultScopes = ["read_user"]
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes
    });
  }
}

const DEFAULT_PROVIDER$5 = {
  id: "google",
  title: "Google",
  icon: OAuth2Icon
};
const SCOPE_PREFIX$1 = "https://www.googleapis.com/auth/";
class GoogleAuth {
  static create({
    discoveryApi,
    oauthRequestApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$5,
    defaultScopes = [
      "openid",
      `${SCOPE_PREFIX$1}userinfo.email`,
      `${SCOPE_PREFIX$1}userinfo.profile`
    ]
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes,
      scopeTransform(scopes) {
        return scopes.map((scope) => {
          if (scope === "openid") {
            return scope;
          }
          if (scope === "profile" || scope === "email") {
            return `${SCOPE_PREFIX$1}userinfo.${scope}`;
          }
          if (scope.startsWith(SCOPE_PREFIX$1)) {
            return scope;
          }
          return `${SCOPE_PREFIX$1}${scope}`;
        });
      }
    });
  }
}

const DEFAULT_PROVIDER$4 = {
  id: "okta",
  title: "Okta",
  icon: OAuth2Icon
};
const OKTA_OIDC_SCOPES = new Set([
  "openid",
  "profile",
  "email",
  "phone",
  "address",
  "groups",
  "offline_access"
]);
const OKTA_SCOPE_PREFIX = "okta.";
class OktaAuth {
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$4,
    oauthRequestApi,
    defaultScopes = ["openid", "email", "profile", "offline_access"]
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes,
      scopeTransform(scopes) {
        return scopes.map((scope) => {
          if (OKTA_OIDC_SCOPES.has(scope)) {
            return scope;
          }
          if (scope.startsWith(OKTA_SCOPE_PREFIX)) {
            return scope;
          }
          return `${OKTA_SCOPE_PREFIX}${scope}`;
        });
      }
    });
  }
}

const DEFAULT_PROVIDER$3 = {
  id: "saml",
  title: "SAML",
  icon: OAuth2Icon
};
class SamlAuth {
  constructor(sessionManager) {
    this.sessionManager = sessionManager;
  }
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$3
  }) {
    const connector = new DirectAuthConnector({
      discoveryApi,
      environment,
      provider
    });
    const sessionManager = new StaticAuthSessionManager({
      connector
    });
    const authSessionStore = new AuthSessionStore({
      manager: sessionManager,
      storageKey: `${provider.id}Session`
    });
    return new SamlAuth(authSessionStore);
  }
  sessionState$() {
    return this.sessionManager.sessionState$();
  }
  async signIn() {
    await this.getBackstageIdentity({});
  }
  async signOut() {
    await this.sessionManager.removeSession();
  }
  async getBackstageIdentity(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.backstageIdentity;
  }
  async getProfile(options = {}) {
    const session = await this.sessionManager.getSession(options);
    return session == null ? void 0 : session.profile;
  }
}

const DEFAULT_PROVIDER$2 = {
  id: "auth0",
  title: "Auth0",
  icon: OAuth2Icon
};
class Auth0Auth {
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER$2,
    oauthRequestApi,
    defaultScopes = ["openid", `email`, `profile`]
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes
    });
  }
}

const DEFAULT_PROVIDER$1 = {
  id: "microsoft",
  title: "Microsoft",
  icon: OAuth2Icon
};
class MicrosoftAuth {
  static create({
    environment = "development",
    provider = DEFAULT_PROVIDER$1,
    oauthRequestApi,
    discoveryApi,
    defaultScopes = [
      "openid",
      "offline_access",
      "profile",
      "email",
      "User.Read"
    ]
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes
    });
  }
}

const DEFAULT_PROVIDER = {
  id: "onelogin",
  title: "onelogin",
  icon: OAuth2Icon
};
const OIDC_SCOPES = new Set([
  "openid",
  "profile",
  "email",
  "phone",
  "address",
  "groups",
  "offline_access"
]);
const SCOPE_PREFIX = "onelogin.";
class OneLoginAuth {
  static create({
    discoveryApi,
    environment = "development",
    provider = DEFAULT_PROVIDER,
    oauthRequestApi
  }) {
    return OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider,
      environment,
      defaultScopes: ["openid", "email", "profile", "offline_access"],
      scopeTransform(scopes) {
        return scopes.map((scope) => {
          if (OIDC_SCOPES.has(scope)) {
            return scope;
          }
          if (scope.startsWith(SCOPE_PREFIX)) {
            return scope;
          }
          return `${SCOPE_PREFIX}${scope}`;
        });
      }
    });
  }
}

class AlertApiForwarder {
  constructor() {
    this.subject = new PublishSubject();
  }
  post(alert) {
    this.subject.next(alert);
  }
  alert$() {
    return this.subject;
  }
}

class UrlPatternDiscovery {
  constructor(parts) {
    this.parts = parts;
  }
  static compile(pattern) {
    const parts = pattern.split(/\{\{\s*pluginId\s*\}\}/);
    try {
      const urlStr = parts.join("pluginId");
      const url = new URL(urlStr);
      if (url.hash) {
        throw new Error("URL must not have a hash");
      }
      if (url.search) {
        throw new Error("URL must not have a query");
      }
      if (urlStr.endsWith("/")) {
        throw new Error("URL must not end with a slash");
      }
    } catch (error) {
      throw new Error(`Invalid discovery URL pattern, ${error.message}`);
    }
    return new UrlPatternDiscovery(parts);
  }
  async getBaseUrl(pluginId) {
    return this.parts.join(pluginId);
  }
}

class ErrorAlerter {
  constructor(alertApi, errorApi) {
    this.alertApi = alertApi;
    this.errorApi = errorApi;
  }
  post(error, context) {
    if (!(context == null ? void 0 : context.hidden)) {
      this.alertApi.post({message: error.message, severity: "error"});
    }
    return this.errorApi.post(error, context);
  }
  error$() {
    return this.errorApi.error$();
  }
}

class ErrorApiForwarder {
  constructor() {
    this.subject = new PublishSubject();
  }
  post(error, context) {
    this.subject.next({error, context});
  }
  error$() {
    return this.subject;
  }
}

class UnhandledErrorForwarder {
  static forward(errorApi, errorContext) {
    window.addEventListener("unhandledrejection", (e) => {
      errorApi.post(e.reason, errorContext);
    });
  }
}

function hasScopes(searched, searchFor) {
  for (const scope of searchFor) {
    if (!searched.has(scope)) {
      return false;
    }
  }
  return true;
}
function joinScopes(scopes, ...moreScopess) {
  const result = new Set(scopes);
  for (const moreScopes of moreScopess) {
    for (const scope of moreScopes) {
      result.add(scope);
    }
  }
  return result;
}
class OAuthPendingRequests {
  constructor() {
    this.requests = [];
    this.subject = new BehaviorSubject(this.getCurrentPending());
  }
  request(scopes) {
    return new Promise((resolve, reject) => {
      this.requests.push({scopes, resolve, reject});
      this.subject.next(this.getCurrentPending());
    });
  }
  resolve(scopes, result) {
    this.requests = this.requests.filter((request) => {
      if (hasScopes(scopes, request.scopes)) {
        request.resolve(result);
        return false;
      }
      return true;
    });
    this.subject.next(this.getCurrentPending());
  }
  reject(error) {
    this.requests.forEach((request) => request.reject(error));
    this.requests = [];
    this.subject.next(this.getCurrentPending());
  }
  pending() {
    return this.subject;
  }
  getCurrentPending() {
    const currentScopes = this.requests.length === 0 ? void 0 : this.requests.slice(1).reduce((acc, current) => joinScopes(acc, current.scopes), this.requests[0].scopes);
    return {
      scopes: currentScopes,
      resolve: (value) => {
        if (currentScopes) {
          this.resolve(currentScopes, value);
        }
      },
      reject: (reason) => {
        if (currentScopes) {
          this.reject(reason);
        }
      }
    };
  }
}

class OAuthRequestManager {
  constructor() {
    this.subject = new BehaviorSubject([]);
    this.currentRequests = [];
    this.handlerCount = 0;
  }
  createAuthRequester(options) {
    const handler = new OAuthPendingRequests();
    const index = this.handlerCount;
    this.handlerCount++;
    handler.pending().subscribe({
      next: (scopeRequest) => {
        const newRequests = this.currentRequests.slice();
        const request = this.makeAuthRequest(scopeRequest, options);
        if (!request) {
          delete newRequests[index];
        } else {
          newRequests[index] = request;
        }
        this.currentRequests = newRequests;
        this.subject.next(newRequests.filter(Boolean));
      }
    });
    return (scopes) => {
      return handler.request(scopes);
    };
  }
  makeAuthRequest(request, options) {
    const {scopes} = request;
    if (!scopes) {
      return void 0;
    }
    return {
      provider: options.provider,
      trigger: async () => {
        const result = await options.onAuthRequest(scopes);
        request.resolve(result);
      },
      reject: () => {
        const error = new Error("Login failed, rejected by user");
        error.name = "RejectedError";
        request.reject(error);
      }
    };
  }
  authRequest$() {
    return this.subject;
  }
}

const buckets = new Map();
class WebStorage {
  constructor(namespace, errorApi) {
    this.namespace = namespace;
    this.errorApi = errorApi;
    this.subscribers = new Set();
    this.observable = new zenObservable((subscriber) => {
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    });
  }
  static create(options) {
    var _a;
    return new WebStorage((_a = options.namespace) != null ? _a : "", options.errorApi);
  }
  get(key) {
    try {
      const storage = JSON.parse(localStorage.getItem(this.getKeyName(key)));
      return storage != null ? storage : void 0;
    } catch (e) {
      this.errorApi.post(new Error(`Error when parsing JSON config from storage for: ${key}`));
    }
    return void 0;
  }
  forBucket(name) {
    const bucketPath = `${this.namespace}/${name}`;
    if (!buckets.has(bucketPath)) {
      buckets.set(bucketPath, new WebStorage(bucketPath, this.errorApi));
    }
    return buckets.get(bucketPath);
  }
  async set(key, data) {
    localStorage.setItem(this.getKeyName(key), JSON.stringify(data, null, 2));
    this.notifyChanges({key, newValue: data});
  }
  async remove(key) {
    localStorage.removeItem(this.getKeyName(key));
    this.notifyChanges({key, newValue: void 0});
  }
  observe$(key) {
    return this.observable.filter(({key: messageKey}) => messageKey === key);
  }
  getKeyName(key) {
    return `${this.namespace}/${encodeURIComponent(key)}`;
  }
  notifyChanges(message) {
    for (const subscription of this.subscribers) {
      subscription.next(message);
    }
  }
}

getOrCreateGlobalSingleton("component-data-store", () => new WeakMap());

const FeatureFlagged = (props) => {
  const {children} = props;
  const featureFlagApi = useApi(featureFlagsApiRef);
  const isEnabled = "with" in props ? featureFlagApi.isActive(props.with) : !featureFlagApi.isActive(props.without);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, isEnabled ? children : null);
};
attachComponentData(FeatureFlagged, "core.featureFlagged", true);

getOrCreateGlobalSingleton("route-ref-type", () => Symbol("route-ref-type"));

getOrCreateGlobalSingleton("routing-context", () => createContext(void 0));

getOrCreateGlobalSingleton("app-context", () => createContext(void 0));

[
  createApiFactory({
    api: discoveryApiRef,
    deps: {configApi: configApiRef},
    factory: ({configApi}) => UrlPatternDiscovery.compile(`${configApi.getString("backend.baseUrl")}/api/{{ pluginId }}`)
  }),
  createApiFactory(alertApiRef, new AlertApiForwarder()),
  createApiFactory({
    api: errorApiRef,
    deps: {alertApi: alertApiRef},
    factory: ({alertApi}) => {
      const errorApi = new ErrorAlerter(alertApi, new ErrorApiForwarder());
      UnhandledErrorForwarder.forward(errorApi, {hidden: false});
      return errorApi;
    }
  }),
  createApiFactory({
    api: storageApiRef,
    deps: {errorApi: errorApiRef},
    factory: ({errorApi}) => WebStorage.create({errorApi})
  }),
  createApiFactory(oauthRequestApiRef, new OAuthRequestManager()),
  createApiFactory({
    api: googleAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({discoveryApi, oauthRequestApi, configApi}) => GoogleAuth.create({
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: microsoftAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({discoveryApi, oauthRequestApi, configApi}) => MicrosoftAuth.create({
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: githubAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({discoveryApi, oauthRequestApi, configApi}) => GithubAuth.create({
      discoveryApi,
      oauthRequestApi,
      defaultScopes: ["read:user"],
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: oktaAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({discoveryApi, oauthRequestApi, configApi}) => OktaAuth.create({
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: gitlabAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({discoveryApi, oauthRequestApi, configApi}) => GitlabAuth.create({
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: auth0AuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({discoveryApi, oauthRequestApi, configApi}) => Auth0Auth.create({
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: oauth2ApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({discoveryApi, oauthRequestApi, configApi}) => OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: samlAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      configApi: configApiRef
    },
    factory: ({discoveryApi, configApi}) => SamlAuth.create({
      discoveryApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: oneloginAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({discoveryApi, oauthRequestApi, configApi}) => OneLoginAuth.create({
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: oidcAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({discoveryApi, oauthRequestApi, configApi}) => OAuth2.create({
      discoveryApi,
      oauthRequestApi,
      provider: {
        id: "oidc",
        title: "Your Identity Provider",
        icon: OAuth2Icon
      },
      environment: configApi.getOptionalString("auth.environment")
    })
  })
];

const MockConfigProvider = ({
  children,
  ...context
}) => {
  const defaultContext = {
    metrics: [],
    products: [],
    icons: [],
    engineerCost: 0,
    currencies: []
  };
  return /* @__PURE__ */ React.createElement(ConfigContext.Provider, {
    value: {...defaultContext, ...context}
  }, children);
};
const MockCurrencyProvider = ({
  children,
  ...context
}) => {
  const defaultContext = {
    currency: {
      kind: null,
      label: "Engineers \u{1F6E0}",
      unit: "engineer"
    },
    setCurrency: jest.fn()
  };
  return /* @__PURE__ */ React.createElement(CurrencyContext.Provider, {
    value: {...defaultContext, ...context}
  }, children);
};

function parseIntervals(intervals) {
  const match = intervals.match(/\/(?<duration>P\d+[DM])\/(?<date>\d{4}-\d{2}-\d{2})/);
  if (Object.keys((match == null ? void 0 : match.groups) || {}).length !== 2) {
    throw new Error(`Invalid intervals: ${intervals}`);
  }
  const {duration, date} = match.groups;
  return {
    duration,
    endDate: date
  };
}
function aggregationFor(intervals, baseline) {
  const {duration, endDate} = parseIntervals(intervals);
  const inclusiveEndDate = inclusiveEndDateOf(duration, endDate);
  const days = DateTime.fromISO(endDate).diff(DateTime.fromISO(inclusiveStartDateOf(duration, inclusiveEndDate)), "days");
  function nextDelta() {
    const varianceFromBaseline = 0.15;
    const positiveTrendChance = 0.55;
    const normalization = positiveTrendChance - 1;
    return baseline * (Math.random() + normalization) * varianceFromBaseline;
  }
  return [...Array(days).keys()].reduce((values, i) => {
    const last = values.length ? values[values.length - 1].amount : baseline;
    const date = DateTime.fromISO(inclusiveStartDateOf(duration, inclusiveEndDate)).plus({days: i}).toFormat(DEFAULT_DATE_FORMAT);
    const amount = Math.max(0, last + nextDelta());
    values.push({
      date,
      amount
    });
    return values;
  }, []);
}
function changeOf(aggregation) {
  const firstAmount = aggregation.length ? aggregation[0].amount : 0;
  const lastAmount = aggregation.length ? aggregation[aggregation.length - 1].amount : 0;
  if (!firstAmount || !lastAmount) {
    return {
      amount: lastAmount - firstAmount
    };
  }
  return {
    ratio: (lastAmount - firstAmount) / firstAmount,
    amount: lastAmount - firstAmount
  };
}
function trendlineOf(aggregation) {
  const data = aggregation.map((a) => [
    Date.parse(a.date) / 1e3,
    a.amount
  ]);
  const result = regression.linear(data, {precision: 5});
  return {
    slope: result.equation[0],
    intercept: result.equation[1]
  };
}
function entityOf(product) {
  switch (product) {
    case "computeEngine":
      return MockComputeEngineInsights;
    case "cloudDataflow":
      return MockCloudDataflowInsights;
    case "cloudStorage":
      return MockCloudStorageInsights;
    case "bigQuery":
      return MockBigQueryInsights;
    case "events":
      return MockEventsInsights;
    default:
      throw new Error(`Cannot get insights for ${product}. Make sure product matches product property in app-info.yaml`);
  }
}
const getGroupedProducts = (intervals) => [
  {
    id: "Cloud Dataflow",
    aggregation: aggregationFor(intervals, 1700)
  },
  {
    id: "Compute Engine",
    aggregation: aggregationFor(intervals, 350)
  },
  {
    id: "Cloud Storage",
    aggregation: aggregationFor(intervals, 1300)
  },
  {
    id: "BigQuery",
    aggregation: aggregationFor(intervals, 2e3)
  },
  {
    id: "Cloud SQL",
    aggregation: aggregationFor(intervals, 750)
  },
  {
    id: "Cloud Spanner",
    aggregation: aggregationFor(intervals, 50)
  },
  {
    id: "Cloud Pub/Sub",
    aggregation: aggregationFor(intervals, 1e3)
  },
  {
    id: "Cloud Bigtable",
    aggregation: aggregationFor(intervals, 250)
  }
];
const getGroupedProjects = (intervals) => [
  {
    id: "project-a",
    aggregation: aggregationFor(intervals, 1700)
  },
  {
    id: "project-b",
    aggregation: aggregationFor(intervals, 350)
  },
  {
    id: "project-c",
    aggregation: aggregationFor(intervals, 1300)
  }
];

class ExampleCostInsightsClient {
  request(_, res) {
    return new Promise((resolve) => setTimeout(resolve, 0, res));
  }
  getLastCompleteBillingDate() {
    return Promise.resolve(DateTime.now().minus({days: 1}).toFormat(DEFAULT_DATE_FORMAT));
  }
  async getUserGroups(userId) {
    const groups = await this.request({userId}, [
      {id: "pied-piper"}
    ]);
    return groups;
  }
  async getGroupProjects(group) {
    const projects = await this.request({group}, [
      {id: "project-a"},
      {id: "project-b"},
      {id: "project-c"}
    ]);
    return projects;
  }
  async getDailyMetricData(metric, intervals) {
    const aggregation = aggregationFor(intervals, 1e5).map((entry) => ({
      ...entry,
      amount: Math.round(entry.amount)
    }));
    const cost = await this.request({metric, intervals}, {
      format: "number",
      aggregation,
      change: changeOf(aggregation),
      trendline: trendlineOf(aggregation)
    });
    return cost;
  }
  async getGroupDailyCost(group, intervals) {
    const aggregation = aggregationFor(intervals, 8e3);
    const groupDailyCost = await this.request({group, intervals}, {
      aggregation,
      change: changeOf(aggregation),
      trendline: trendlineOf(aggregation),
      groupedCosts: {
        product: getGroupedProducts(intervals),
        project: getGroupedProjects(intervals)
      }
    });
    return groupDailyCost;
  }
  async getProjectDailyCost(project, intervals) {
    const aggregation = aggregationFor(intervals, 1500);
    const projectDailyCost = await this.request({project, intervals}, {
      id: "project-a",
      aggregation,
      change: changeOf(aggregation),
      trendline: trendlineOf(aggregation),
      groupedCosts: {
        product: getGroupedProducts(intervals)
      }
    });
    return projectDailyCost;
  }
  async getProductInsights(options) {
    const productInsights = await this.request(options, entityOf(options.product));
    return productInsights;
  }
  async getAlerts(group) {
    const projectGrowthData = {
      project: "example-project",
      periodStart: "2020-Q2",
      periodEnd: "2020-Q3",
      aggregation: [6e4, 12e4],
      change: {
        ratio: 1,
        amount: 6e4
      },
      products: [
        {id: "Compute Engine", aggregation: [58e3, 118e3]},
        {id: "Cloud Dataflow", aggregation: [1200, 1500]},
        {id: "Cloud Storage", aggregation: [800, 500]}
      ]
    };
    const unlabeledDataflowData = {
      periodStart: "2020-09-01",
      periodEnd: "2020-09-30",
      labeledCost: 6200,
      unlabeledCost: 7e3,
      projects: [
        {
          id: "example-project-1",
          unlabeledCost: 5e3,
          labeledCost: 3e3
        },
        {
          id: "example-project-2",
          unlabeledCost: 2e3,
          labeledCost: 3200
        }
      ]
    };
    const today = DateTime.now();
    const alerts = await this.request({group}, [
      new ProjectGrowthAlert(projectGrowthData),
      new UnlabeledDataflowAlert(unlabeledDataflowData),
      new KubernetesMigrationAlert(this, {
        startDate: today.minus({days: 30}).toFormat(DEFAULT_DATE_FORMAT),
        endDate: today.toFormat(DEFAULT_DATE_FORMAT),
        change: {
          ratio: 0,
          amount: 0
        },
        services: [
          {
            id: "service-a",
            aggregation: [2e4, 1e4],
            change: {
              ratio: -0.5,
              amount: -1e4
            },
            entities: {}
          },
          {
            id: "service-b",
            aggregation: [3e4, 15e3],
            change: {
              ratio: -0.5,
              amount: -15e3
            },
            entities: {}
          }
        ]
      })
    ]);
    return alerts;
  }
}

export { getResetState as $, AlertStatus as A, overviewGraphTickFormatter as B, CostGrowth as C, DefaultNavigation as D, formatGraphValue as E, isInvalid as F, DEFAULT_DATE_FORMAT as G, BarChartTooltip as H, BarChartTooltipItem as I, getPreviousPeriodTotalCost as J, formatPeriod as K, LegendItem as L, BarChartLegend as M, Duration as N, formatLastTwoLookaheadQuarters as O, useOverviewTabsStyles as P, useConfig as Q, useProductInsightsCardStyles as R, ScrollType as S, findAnyKey as T, ProductInsightsChart as U, costInsightsApiRef as V, intervalsOf as W, DEFAULT_DURATION as X, settledResponseOf as Y, initialStatesOf as Z, totalAggregationSort as _, useScroll as a, getResetStateWithoutInitial as a0, useSubtleTypographyStyles as a1, useGroups as a2, useCurrency as a3, isAlertActive as a4, isAlertSnoozed as a5, isAlertAccepted as a6, isAlertDismissed as a7, CostInsightsLayout as a8, CostInsightsNavigation as a9, ChangeThreshold as aA, GrowthType as aB, CurrencyType as aC, IconType as aD, CostInsightsThemeProvider as aa, ConfigProvider as ab, LoadingProvider as ac, GroupsProvider as ad, BillingDateProvider as ae, FilterProvider as af, ScrollProvider as ag, CurrencyProvider as ah, ProjectGrowthInstructionsPage as ai, AlertInstructionsLayout as aj, costInsightsPlugin as ak, CostInsightsPage as al, CostInsightsProjectGrowthInstructionsPage as am, CostInsightsLabelDataflowInstructionsPage as an, ExampleCostInsightsClient as ao, BarChart as ap, CostGrowthIndicator as aq, MockConfigProvider as ar, MockCurrencyProvider as as, ProjectGrowthAlert as at, UnlabeledDataflowAlert as au, AlertDismissReason as av, AlertDismissOptions as aw, AlertSnoozeOptions as ax, DataKey as ay, EngineerThreshold as az, useAlertDialogStyles as b, choose$1 as c, useAlertStatusSummaryButtonStyles as d, useCostInsightsStyles as e, formOf as f, useAlertInsightsSectionStyles as g, isAcceptEnabled as h, isSnoozeEnabled as i, isDismissEnabled as j, useLoading as k, isStatusSnoozed as l, isStatusAccepted as m, isStatusDismissed as n, DefaultLoadingAction as o, useSelectStyles as p, findAlways as q, useFilters as r, sumOfAllAlerts as s, useLastCompleteBillingDate as t, useActionItemCardStyles as u, getComparedChange as v, formatChange as w, choose as x, useCostOverviewStyles as y, aggregationSort as z };
//# sourceMappingURL=index-7cd0bf61.esm.js.map
