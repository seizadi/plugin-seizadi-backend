import { JsonObject } from '@backstage/config';

declare class CustomErrorBase extends Error {
    readonly cause?: Error;
    constructor(message?: string, cause?: Error);
}

/**
 * The given inputs are malformed and cannot be processed.
 */
declare class InputError extends CustomErrorBase {
}
/**
 * The request requires authentication, which was not properly supplied.
 */
declare class AuthenticationError extends CustomErrorBase {
}
/**
 * The authenticated caller is not allowed to perform this request.
 */
declare class NotAllowedError extends CustomErrorBase {
}
/**
 * The requested resource could not be found.
 *
 * Note that this error usually is used to indicate that an entity with a given
 * ID does not exist, rather than signalling that an entire route is missing.
 */
declare class NotFoundError extends CustomErrorBase {
}
/**
 * The request could not complete due to a conflict in the current state of the
 * resource.
 */
declare class ConflictError extends CustomErrorBase {
}
/**
 * The requested resource has not changed since last request.
 */
declare class NotModifiedError extends CustomErrorBase {
}

/**
 * The serialized form of an Error.
 */
declare type SerializedError = JsonObject & {
    /** The name of the exception that was thrown */
    name: string;
    /** The message of the exception that was thrown */
    message: string;
    /** A stringified stack trace; may not be present */
    stack?: string;
    /** A custom code (not necessarily the same as an HTTP response code); may not be present */
    code?: string;
};
/**
 * Serializes an error object to a JSON friendly form.
 *
 * @param error The error
 * @param options.includeStackTraces: Include stack trace in the output (default false)
 */
declare function serializeError(error: Error, options?: {
    includeStack?: boolean;
}): SerializedError;
/**
 * Deserializes a serialized error object back to an Error.
 */
declare function deserializeError<T extends Error = Error>(data: SerializedError): T;

/**
 * A standard shape of JSON data returned as the body of backend errors.
 */
declare type ErrorResponse = {
    /** Details of the error that was caught */
    error: SerializedError;
    /** Details about the incoming request */
    request?: {
        /** The HTTP method of the request */
        method: string;
        /** The URL of the request (excluding protocol and host/port) */
        url: string;
    };
    /** Details about the response */
    response: {
        /** The numeric HTTP status code that was returned */
        statusCode: number;
    };
};
/**
 * Attempts to construct an ErrorResponse out of a failed server request.
 * Assumes that the response has already been checked to be not ok. This
 * function consumes the body of the response, and assumes that it hasn't
 * been consumed before.
 *
 * The code is forgiving, and constructs a useful synthetic body as best it can
 * if the response body wasn't on the expected form.
 *
 * @param response The response of a failed request
 */
declare function parseErrorResponse(response: Response): Promise<ErrorResponse>;

/**
 * An error thrown as the result of a failed server request.
 *
 * The server is expected to respond on the ErrorResponse format.
 */
declare class ResponseError extends Error {
    /**
     * The actual response, as seen by the client.
     *
     * Note that the body of this response is always consumed. Its parsed form is
     * in the `body` field.
     */
    readonly response: Response;
    /**
     * The parsed JSON error body, as sent by the server.
     */
    readonly data: ErrorResponse;
    /**
     * The Error cause, as seen by the remote server. This is parsed out of the
     * JSON error body.
     *
     * This error always has the plain Error constructor, however all
     * serializable enumerable fields on the remote error including its name are
     * preserved. Therefore, if you want to check the error type, use its name
     * property rather than checking typeof or its constructor or prototype.
     */
    readonly cause: Error;
    /**
     * Constructs a ResponseError based on a failed response.
     *
     * Assumes that the response has already been checked to be not ok. This
     * function consumes the body of the response, and assumes that it hasn't
     * been consumed before.
     */
    static fromResponse(response: Response): Promise<ResponseError>;
    constructor(props: {
        message: string;
        response: Response;
        data: ErrorResponse;
        cause: Error;
    });
}

export { AuthenticationError, ConflictError, CustomErrorBase, ErrorResponse, InputError, NotAllowedError, NotFoundError, NotModifiedError, ResponseError, SerializedError, deserializeError, parseErrorResponse, serializeError };
