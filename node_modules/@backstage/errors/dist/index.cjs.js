'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var serializeError$1 = require('serialize-error');

class CustomErrorBase extends Error {
  constructor(message, cause) {
    var _a;
    let fullMessage = message;
    if (cause) {
      if (fullMessage) {
        fullMessage += `; caused by ${cause}`;
      } else {
        fullMessage = `caused by ${cause}`;
      }
    }
    super(fullMessage);
    (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, this, this.constructor);
    this.name = this.constructor.name;
    this.cause = cause;
  }
}

class InputError extends CustomErrorBase {
}
class AuthenticationError extends CustomErrorBase {
}
class NotAllowedError extends CustomErrorBase {
}
class NotFoundError extends CustomErrorBase {
}
class ConflictError extends CustomErrorBase {
}
class NotModifiedError extends CustomErrorBase {
}

function serializeError(error, options) {
  const serialized = serializeError$1.serializeError(error);
  const result = {
    name: "Unknown",
    message: "<no reason given>",
    ...serialized
  };
  if (!(options == null ? void 0 : options.includeStack)) {
    delete result.stack;
  }
  return result;
}
function deserializeError(data) {
  const result = serializeError$1.deserializeError(data);
  if (!data.stack) {
    result.stack = void 0;
  }
  return result;
}

async function parseErrorResponse(response) {
  var _a;
  try {
    const text = await response.text();
    if (text) {
      if ((_a = response.headers.get("content-type")) == null ? void 0 : _a.startsWith("application/json")) {
        try {
          const body = JSON.parse(text);
          if (body.error && body.response) {
            return body;
          }
        } catch {
        }
      }
      return {
        error: {
          name: "Unknown",
          message: `Request failed with status ${response.status} ${response.statusText}, ${text}`
        },
        response: {
          statusCode: response.status
        }
      };
    }
  } catch {
  }
  return {
    error: {
      name: "Unknown",
      message: `Request failed with status ${response.status} ${response.statusText}`
    },
    response: {
      statusCode: response.status
    }
  };
}

class ResponseError extends Error {
  static async fromResponse(response) {
    const data = await parseErrorResponse(response);
    const status = data.response.statusCode || response.status;
    const statusText = data.error.name || response.statusText;
    const message = `Request failed with ${status} ${statusText}`;
    const cause = deserializeError(data.error);
    return new ResponseError({
      message,
      response,
      data,
      cause
    });
  }
  constructor(props) {
    super(props.message);
    this.name = "ResponseError";
    this.response = props.response;
    this.data = props.data;
    this.cause = props.cause;
  }
}

exports.AuthenticationError = AuthenticationError;
exports.ConflictError = ConflictError;
exports.CustomErrorBase = CustomErrorBase;
exports.InputError = InputError;
exports.NotAllowedError = NotAllowedError;
exports.NotFoundError = NotFoundError;
exports.NotModifiedError = NotModifiedError;
exports.ResponseError = ResponseError;
exports.deserializeError = deserializeError;
exports.parseErrorResponse = parseErrorResponse;
exports.serializeError = serializeError;
//# sourceMappingURL=index.cjs.js.map
