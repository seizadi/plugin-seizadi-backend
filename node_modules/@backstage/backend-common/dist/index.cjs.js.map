{"version":3,"file":"index.cjs.js","sources":["../src/logging/formats.ts","../src/logging/rootLogger.ts","../src/logging/voidLogger.ts","../src/cache/CacheClient.ts","../src/cache/NoStore.ts","../src/cache/CacheManager.ts","../src/config.ts","../src/database/config.ts","../src/database/connectors/defaultNameOverride.ts","../src/database/connectors/mysql.ts","../src/database/connectors/postgres.ts","../src/database/connectors/sqlite3.ts","../src/database/connection.ts","../src/database/DatabaseManager.ts","../src/database/SingleConnection.ts","../src/service/lib/config.ts","../src/hot.ts","../src/middleware/errorHandler.ts","../src/middleware/notFoundHandler.ts","../src/middleware/requestLoggingHandler.ts","../src/middleware/statusCheckHandler.ts","../src/service/lib/hostFactory.ts","../src/service/lib/ServiceBuilderImpl.ts","../src/discovery/SingleHostDiscovery.ts","../src/paths.ts","../src/reading/tree/util.ts","../src/reading/AzureUrlReader.ts","../src/reading/BitbucketUrlReader.ts","../src/reading/GithubUrlReader.ts","../src/reading/GitlabUrlReader.ts","../src/reading/UrlReaderPredicateMux.ts","../src/reading/tree/TarArchiveResponse.ts","../src/reading/tree/ZipArchiveResponse.ts","../src/reading/tree/ReadTreeResponseFactory.ts","../src/reading/FetchUrlReader.ts","../src/reading/GoogleGcsUrlReader.ts","../src/reading/AwsS3UrlReader.ts","../src/reading/UrlReaders.ts","../src/scm/git.ts","../src/service/createServiceBuilder.ts","../src/service/createStatusCheckRouter.ts","../src/util/DockerContainerRunner.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as winston from 'winston';\nimport { TransformableInfo } from 'logform';\n\nconst coloredTemplate = (info: TransformableInfo) => {\n  const { timestamp, level, message, plugin, service, ...fields } = info;\n  const colorizer = winston.format.colorize();\n  const prefix = plugin || service;\n  const timestampColor = colorizer.colorize('timestamp', timestamp);\n  const prefixColor = colorizer.colorize('prefix', prefix);\n\n  const extraFields = Object.entries(fields)\n    .map(([key, value]) => `${colorizer.colorize('field', `${key}`)}=${value}`)\n    .join(' ');\n\n  return `${timestampColor} ${prefixColor} ${level} ${message} ${extraFields}`;\n};\n\nexport const coloredFormat = winston.format.combine(\n  winston.format.timestamp(),\n  winston.format.colorize({\n    colors: { timestamp: 'dim', prefix: 'blue', field: 'cyan', debug: 'grey' },\n  }),\n  winston.format.printf(coloredTemplate),\n);\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { merge } from 'lodash';\nimport * as winston from 'winston';\nimport { LoggerOptions } from 'winston';\nimport { coloredFormat } from './formats';\n\nlet rootLogger: winston.Logger;\n\nexport function getRootLogger(): winston.Logger {\n  return rootLogger;\n}\n\nexport function setRootLogger(newLogger: winston.Logger) {\n  rootLogger = newLogger;\n}\n\nexport function createRootLogger(\n  options: winston.LoggerOptions = {},\n  env = process.env,\n): winston.Logger {\n  const logger = winston.createLogger(\n    merge<LoggerOptions, LoggerOptions>(\n      {\n        level: env.LOG_LEVEL || 'info',\n        format: winston.format.combine(\n          env.NODE_ENV === 'production' ? winston.format.json() : coloredFormat,\n        ),\n        defaultMeta: {\n          service: 'backstage',\n        },\n        transports: [\n          new winston.transports.Console({\n            silent: env.JEST_WORKER_ID !== undefined && !env.LOG_LEVEL,\n          }),\n        ],\n      },\n      options,\n    ),\n  );\n\n  setRootLogger(logger);\n\n  return logger;\n}\n\nrootLogger = createRootLogger();\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PassThrough } from 'stream';\nimport * as winston from 'winston';\n\n/**\n * A logger that just throws away all messages.\n */\nexport function getVoidLogger(): winston.Logger {\n  return winston.createLogger({\n    transports: [new winston.transports.Stream({ stream: new PassThrough() })],\n  });\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonValue } from '@backstage/config';\nimport { createHash } from 'crypto';\nimport Keyv from 'keyv';\n\ntype CacheClientArgs = {\n  client: Keyv;\n};\n\ntype CacheSetOptions = {\n  /**\n   * Optional TTL in milliseconds. Defaults to the TTL provided when the client\n   * was set up (or no TTL if none are provided).\n   */\n  ttl?: number;\n};\n\n/**\n * A pre-configured, storage agnostic cache client suitable for use by\n * Backstage plugins.\n */\nexport interface CacheClient {\n  /**\n   * Reads data from a cache store for the given key. If no data was found,\n   * returns undefined.\n   */\n  get(key: string): Promise<JsonValue | undefined>;\n\n  /**\n   * Writes the given data to a cache store, associated with the given key. An\n   * optional TTL may also be provided, otherwise it defaults to the TTL that\n   * was provided when the client was instantiated.\n   */\n  set(key: string, value: JsonValue, options?: CacheSetOptions): Promise<void>;\n\n  /**\n   * Removes the given key from the cache store.\n   */\n  delete(key: string): Promise<void>;\n}\n\n/**\n * A basic, concrete implementation of the CacheClient, suitable for almost\n * all uses in Backstage.\n */\nexport class DefaultCacheClient implements CacheClient {\n  private readonly client: Keyv;\n\n  constructor({ client }: CacheClientArgs) {\n    this.client = client;\n  }\n\n  async get(key: string): Promise<JsonValue | undefined> {\n    const k = this.getNormalizedKey(key);\n    return await this.client.get(k);\n  }\n\n  async set(\n    key: string,\n    value: JsonValue,\n    opts: CacheSetOptions = {},\n  ): Promise<void> {\n    const k = this.getNormalizedKey(key);\n    await this.client.set(k, value, opts.ttl);\n  }\n\n  async delete(key: string): Promise<void> {\n    const k = this.getNormalizedKey(key);\n    await this.client.delete(k);\n  }\n\n  /**\n   * Ensures keys are well-formed for any/all cache stores.\n   */\n  private getNormalizedKey(candidateKey: string): string {\n    // Remove potentially invalid characters.\n    const wellFormedKey = Buffer.from(candidateKey).toString('base64');\n\n    // Memcache in particular doesn't do well with keys > 250 bytes.\n    // Padded because a plugin ID is also prepended to the key.\n    if (wellFormedKey.length < 200) {\n      return wellFormedKey;\n    }\n\n    return createHash('md5').update(candidateKey).digest('base64');\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Storage class compatible with Keyv which always results in a no-op. This is\n * used when no cache store is configured in a Backstage backend instance.\n */\nexport class NoStore extends Map<string, any> {\n  clear(): void {\n    return;\n  }\n\n  delete(_key: string): boolean {\n    return false;\n  }\n\n  get(_key: string) {\n    return;\n  }\n\n  has(_key: string): boolean {\n    return false;\n  }\n\n  set(_key: string, _value: any): this {\n    return this;\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport Keyv from 'keyv';\n// @ts-expect-error\nimport KeyvMemcache from 'keyv-memcache';\nimport { Logger } from 'winston';\nimport { getRootLogger } from '../logging';\nimport { DefaultCacheClient, CacheClient } from './CacheClient';\nimport { NoStore } from './NoStore';\nimport {\n  CacheManagerOptions,\n  OptionalOnError,\n  PluginCacheManager,\n} from './types';\n\n/**\n * Implements a Cache Manager which will automatically create new cache clients\n * for plugins when requested. All requested cache clients are created with the\n * connection details provided.\n */\nexport class CacheManager {\n  /**\n   * Keys represent supported `backend.cache.store` values, mapped to factories\n   * that return Keyv instances appropriate to the store.\n   */\n  private readonly storeFactories = {\n    memcache: this.getMemcacheClient,\n    memory: this.getMemoryClient,\n    none: this.getNoneClient,\n  };\n\n  private readonly logger: Logger;\n  private readonly store: keyof CacheManager['storeFactories'];\n  private readonly connection: string;\n  private readonly errorHandler: OptionalOnError;\n\n  /**\n   * Creates a new CacheManager instance by reading from the `backend` config\n   * section, specifically the `.cache` key.\n   *\n   * @param config The loaded application configuration.\n   */\n  static fromConfig(\n    config: Config,\n    options: CacheManagerOptions = {},\n  ): CacheManager {\n    // If no `backend.cache` config is provided, instantiate the CacheManager\n    // with a \"NoStore\" cache client.\n    const store = config.getOptionalString('backend.cache.store') || 'none';\n    const connectionString =\n      config.getOptionalString('backend.cache.connection') || '';\n    const logger = (options.logger || getRootLogger()).child({\n      type: 'cacheManager',\n    });\n    return new CacheManager(store, connectionString, logger, options.onError);\n  }\n\n  private constructor(\n    store: string,\n    connectionString: string,\n    logger: Logger,\n    errorHandler: OptionalOnError,\n  ) {\n    if (!this.storeFactories.hasOwnProperty(store)) {\n      throw new Error(`Unknown cache store: ${store}`);\n    }\n    this.logger = logger;\n    this.store = store as keyof CacheManager['storeFactories'];\n    this.connection = connectionString;\n    this.errorHandler = errorHandler;\n  }\n\n  /**\n   * Generates a PluginCacheManager for consumption by plugins.\n   *\n   * @param pluginId The plugin that the cache manager should be created for. Plugin names should be unique.\n   */\n  forPlugin(pluginId: string): PluginCacheManager {\n    return {\n      getClient: (opts = {}): CacheClient => {\n        const concreteClient = this.getClientWithTtl(pluginId, opts.defaultTtl);\n\n        // Always provide an error handler to avoid killing the process.\n        concreteClient.on('error', (err: Error) => {\n          // In all cases, just log the error.\n          this.logger.error(err);\n\n          // Invoke any custom error handler if provided.\n          if (typeof this.errorHandler === 'function') {\n            this.errorHandler(err);\n          }\n        });\n\n        return new DefaultCacheClient({\n          client: concreteClient,\n        });\n      },\n    };\n  }\n\n  private getClientWithTtl(pluginId: string, ttl: number | undefined): Keyv {\n    return this.storeFactories[this.store].call(this, pluginId, ttl);\n  }\n\n  private getMemcacheClient(\n    pluginId: string,\n    defaultTtl: number | undefined,\n  ): Keyv {\n    return new Keyv({\n      namespace: pluginId,\n      ttl: defaultTtl,\n      store: new KeyvMemcache(this.connection),\n    });\n  }\n\n  private getMemoryClient(\n    pluginId: string,\n    defaultTtl: number | undefined,\n  ): Keyv {\n    return new Keyv({\n      namespace: pluginId,\n      ttl: defaultTtl,\n    });\n  }\n\n  private getNoneClient(pluginId: string): Keyv {\n    return new Keyv({\n      namespace: pluginId,\n      store: new NoStore(),\n    });\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { resolve as resolvePath } from 'path';\nimport parseArgs from 'minimist';\nimport { Logger } from 'winston';\nimport { findPaths } from '@backstage/cli-common';\nimport { Config, ConfigReader, JsonValue } from '@backstage/config';\nimport { loadConfig } from '@backstage/config-loader';\n\nclass ObservableConfigProxy implements Config {\n  private config: Config = new ConfigReader({});\n\n  private readonly subscribers: (() => void)[] = [];\n\n  constructor(private readonly logger: Logger) {}\n\n  setConfig(config: Config) {\n    this.config = config;\n    for (const subscriber of this.subscribers) {\n      try {\n        subscriber();\n      } catch (error) {\n        this.logger.error(`Config subscriber threw error, ${error}`);\n      }\n    }\n  }\n\n  subscribe(onChange: () => void): { unsubscribe: () => void } {\n    this.subscribers.push(onChange);\n    return {\n      unsubscribe: () => {\n        const index = this.subscribers.indexOf(onChange);\n        if (index >= 0) {\n          this.subscribers.splice(index, 1);\n        }\n      },\n    };\n  }\n\n  has(key: string): boolean {\n    return this.config.has(key);\n  }\n  keys(): string[] {\n    return this.config.keys();\n  }\n  get<T = JsonValue>(key?: string): T {\n    return this.config.get(key);\n  }\n  getOptional<T = JsonValue>(key?: string): T | undefined {\n    return this.config.getOptional(key);\n  }\n  getConfig(key: string): Config {\n    return this.config.getConfig(key);\n  }\n  getOptionalConfig(key: string): Config | undefined {\n    return this.config.getOptionalConfig(key);\n  }\n  getConfigArray(key: string): Config[] {\n    return this.config.getConfigArray(key);\n  }\n  getOptionalConfigArray(key: string): Config[] | undefined {\n    return this.config.getOptionalConfigArray(key);\n  }\n  getNumber(key: string): number {\n    return this.config.getNumber(key);\n  }\n  getOptionalNumber(key: string): number | undefined {\n    return this.config.getOptionalNumber(key);\n  }\n  getBoolean(key: string): boolean {\n    return this.config.getBoolean(key);\n  }\n  getOptionalBoolean(key: string): boolean | undefined {\n    return this.config.getOptionalBoolean(key);\n  }\n  getString(key: string): string {\n    return this.config.getString(key);\n  }\n  getOptionalString(key: string): string | undefined {\n    return this.config.getOptionalString(key);\n  }\n  getStringArray(key: string): string[] {\n    return this.config.getStringArray(key);\n  }\n  getOptionalStringArray(key: string): string[] | undefined {\n    return this.config.getOptionalStringArray(key);\n  }\n}\n\ntype Options = {\n  logger: Logger;\n  // process.argv or any other overrides\n  argv: string[];\n};\n\n// A global used to ensure that only a single file watcher is active at a time.\nlet currentCancelFunc: () => void;\n\n/**\n * Load configuration for a Backend.\n *\n * This function should only be called once, during the initialization of the backend.\n */\nexport async function loadBackendConfig(options: Options): Promise<Config> {\n  const args = parseArgs(options.argv);\n  const configPaths: string[] = [args.config ?? []].flat();\n\n  const config = new ObservableConfigProxy(options.logger);\n\n  /* eslint-disable-next-line no-restricted-syntax */\n  const paths = findPaths(__dirname);\n\n  const configs = await loadConfig({\n    configRoot: paths.targetRoot,\n    configPaths: configPaths.map(opt => resolvePath(opt)),\n    watch: {\n      onChange(newConfigs) {\n        options.logger.info(\n          `Reloaded config from ${newConfigs.map(c => c.context).join(', ')}`,\n        );\n\n        config.setConfig(ConfigReader.fromConfigs(newConfigs));\n      },\n      stopSignal: new Promise(resolve => {\n        if (currentCancelFunc) {\n          currentCancelFunc();\n        }\n        currentCancelFunc = resolve;\n\n        // For reloads of this module we need to use a dispose handler rather than the global.\n        if (module.hot) {\n          module.hot.addDisposeHandler(resolve);\n        }\n      }),\n    },\n  });\n\n  options.logger.info(\n    `Loaded config from ${configs.map(c => c.context).join(', ')}`,\n  );\n\n  config.setConfig(ConfigReader.fromConfigs(configs));\n\n  return config;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { merge } from 'lodash';\n\n/**\n * Merges database objects together\n *\n * @param config The base config. The input is not modified\n * @param overrides Any additional overrides\n */\nexport function mergeDatabaseConfig(config: any, ...overrides: any[]) {\n  return merge({}, config, ...overrides);\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Knex } from 'knex';\n\n/**\n * Provides a partial knex config with database name override.\n *\n * Default override for knex database drivers which accept ConnectionConfig\n * with `connection.database` as the database name field.\n *\n * @param name database name to get config override for\n */\nexport default function defaultNameOverride(\n  name: string,\n): Partial<Knex.Config> {\n  return {\n    connection: {\n      database: name,\n    },\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport knexFactory, { Knex } from 'knex';\nimport yn from 'yn';\n\nimport { Config } from '@backstage/config';\nimport { InputError } from '@backstage/errors';\nimport { mergeDatabaseConfig } from '../config';\nimport { DatabaseConnector } from '../types';\nimport defaultNameOverride from './defaultNameOverride';\n\n/**\n * Creates a knex mysql database connection\n *\n * @param dbConfig The database config\n * @param overrides Additional options to merge with the config\n */\nexport function createMysqlDatabaseClient(\n  dbConfig: Config,\n  overrides?: Knex.Config,\n) {\n  const knexConfig = buildMysqlDatabaseConfig(dbConfig, overrides);\n  const database = knexFactory(knexConfig);\n  return database;\n}\n\n/**\n * Builds a knex mysql database connection\n *\n * @param dbConfig The database config\n * @param overrides Additional options to merge with the config\n */\nexport function buildMysqlDatabaseConfig(\n  dbConfig: Config,\n  overrides?: Knex.Config,\n) {\n  return mergeDatabaseConfig(\n    dbConfig.get(),\n    {\n      connection: getMysqlConnectionConfig(dbConfig, !!overrides),\n      useNullAsDefault: true,\n    },\n    overrides,\n  );\n}\n\n/**\n * Gets the mysql connection config\n *\n * @param dbConfig The database config\n * @param parseConnectionString Flag to explicitly control connection string parsing\n */\nexport function getMysqlConnectionConfig(\n  dbConfig: Config,\n  parseConnectionString?: boolean,\n): Knex.MySqlConnectionConfig | string {\n  const connection = dbConfig.get('connection') as any;\n  const isConnectionString =\n    typeof connection === 'string' || connection instanceof String;\n  const autoParse = typeof parseConnectionString !== 'boolean';\n\n  const shouldParseConnectionString = autoParse\n    ? isConnectionString\n    : parseConnectionString && isConnectionString;\n\n  return shouldParseConnectionString\n    ? parseMysqlConnectionString(connection as string)\n    : connection;\n}\n\n/**\n * Parses a mysql connection string.\n *\n * e.g. mysql://examplename:somepassword@examplehost:3306/dbname\n * @param connectionString The mysql connection string\n */\nexport function parseMysqlConnectionString(\n  connectionString: string,\n): Knex.MySqlConnectionConfig {\n  try {\n    const {\n      protocol,\n      username,\n      password,\n      port,\n      hostname,\n      pathname,\n      searchParams,\n    } = new URL(connectionString);\n\n    if (protocol !== 'mysql:') {\n      throw new Error(`Unknown protocol ${protocol}`);\n    } else if (!username || !password) {\n      throw new Error(`Missing username/password`);\n    } else if (!pathname.match(/^\\/[^/]+$/)) {\n      throw new Error(`Expected single path segment`);\n    }\n\n    const result: Knex.MySqlConnectionConfig = {\n      user: username,\n      password,\n      host: hostname,\n      port: Number(port || 3306),\n      database: decodeURIComponent(pathname.substr(1)),\n    };\n\n    const ssl = searchParams.get('ssl');\n    if (ssl) {\n      result.ssl = ssl;\n    }\n\n    const debug = searchParams.get('debug');\n    if (debug) {\n      result.debug = yn(debug);\n    }\n\n    return result;\n  } catch (e) {\n    throw new InputError(\n      `Error while parsing MySQL connection string, ${e}`,\n      e,\n    );\n  }\n}\n\n/**\n * Creates the missing mysql database if it does not exist\n *\n * @param dbConfig The database config\n * @param databases The names of the databases to create\n */\nexport async function ensureMysqlDatabaseExists(\n  dbConfig: Config,\n  ...databases: Array<string>\n) {\n  const admin = createMysqlDatabaseClient(dbConfig, {\n    connection: {\n      database: null as unknown as string,\n    },\n  });\n\n  try {\n    const ensureDatabase = async (database: string) => {\n      await admin.raw(`CREATE DATABASE IF NOT EXISTS ??`, [database]);\n    };\n    await Promise.all(databases.map(ensureDatabase));\n  } finally {\n    await admin.destroy();\n  }\n}\n\n/**\n * MySQL database connector.\n *\n * Exposes database connector functionality via an immutable object.\n */\nexport const mysqlConnector: DatabaseConnector = Object.freeze({\n  createClient: createMysqlDatabaseClient,\n  ensureDatabaseExists: ensureMysqlDatabaseExists,\n  createNameOverride: defaultNameOverride,\n  parseConnectionString: parseMysqlConnectionString,\n});\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport knexFactory, { Knex } from 'knex';\n\nimport { Config } from '@backstage/config';\nimport { mergeDatabaseConfig } from '../config';\nimport { DatabaseConnector } from '../types';\nimport defaultNameOverride from './defaultNameOverride';\n\n/**\n * Creates a knex postgres database connection\n *\n * @param dbConfig The database config\n * @param overrides Additional options to merge with the config\n */\nexport function createPgDatabaseClient(\n  dbConfig: Config,\n  overrides?: Knex.Config,\n) {\n  const knexConfig = buildPgDatabaseConfig(dbConfig, overrides);\n  const database = knexFactory(knexConfig);\n  return database;\n}\n\n/**\n * Builds a knex postgres database connection\n *\n * @param dbConfig The database config\n * @param overrides Additional options to merge with the config\n */\nexport function buildPgDatabaseConfig(\n  dbConfig: Config,\n  overrides?: Knex.Config,\n) {\n  return mergeDatabaseConfig(\n    dbConfig.get(),\n    {\n      connection: getPgConnectionConfig(dbConfig, !!overrides),\n      useNullAsDefault: true,\n    },\n    overrides,\n  );\n}\n\n/**\n * Gets the postgres connection config\n *\n * @param dbConfig The database config\n * @param parseConnectionString Flag to explicitly control connection string parsing\n */\nexport function getPgConnectionConfig(\n  dbConfig: Config,\n  parseConnectionString?: boolean,\n): Knex.PgConnectionConfig | string {\n  const connection = dbConfig.get('connection') as any;\n  const isConnectionString =\n    typeof connection === 'string' || connection instanceof String;\n  const autoParse = typeof parseConnectionString !== 'boolean';\n\n  const shouldParseConnectionString = autoParse\n    ? isConnectionString\n    : parseConnectionString && isConnectionString;\n\n  return shouldParseConnectionString\n    ? parsePgConnectionString(connection as string)\n    : connection;\n}\n\n/**\n * Parses a connection string using pg-connection-string\n *\n * @param connectionString The postgres connection string\n */\nexport function parsePgConnectionString(connectionString: string) {\n  const parse = requirePgConnectionString();\n  return parse(connectionString);\n}\n\nfunction requirePgConnectionString() {\n  try {\n    return require('pg-connection-string').parse;\n  } catch (e) {\n    const message = `Postgres: Install 'pg-connection-string'`;\n    throw new Error(`${message}\\n${e.message}`);\n  }\n}\n\n/**\n * Creates the missing Postgres database if it does not exist\n *\n * @param dbConfig The database config\n * @param databases The name of the databases to create\n */\nexport async function ensurePgDatabaseExists(\n  dbConfig: Config,\n  ...databases: Array<string>\n) {\n  const admin = createPgDatabaseClient(dbConfig, {\n    connection: {\n      database: 'postgres',\n    },\n  });\n\n  try {\n    const ensureDatabase = async (database: string) => {\n      const result = await admin\n        .from('pg_database')\n        .where('datname', database)\n        .count<Record<string, { count: string }>>();\n\n      if (parseInt(result[0].count, 10) > 0) {\n        return;\n      }\n\n      await admin.raw(`CREATE DATABASE ??`, [database]);\n    };\n\n    await Promise.all(databases.map(ensureDatabase));\n  } finally {\n    await admin.destroy();\n  }\n}\n\n/**\n * PostgreSQL database connector.\n *\n * Exposes database connector functionality via an immutable object.\n */\nexport const pgConnector: DatabaseConnector = Object.freeze({\n  createClient: createPgDatabaseClient,\n  ensureDatabaseExists: ensurePgDatabaseExists,\n  createNameOverride: defaultNameOverride,\n  parseConnectionString: parsePgConnectionString,\n});\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport path from 'path';\n\nimport { ensureDirSync } from 'fs-extra';\nimport knexFactory, { Knex } from 'knex';\n\nimport { Config } from '@backstage/config';\nimport { mergeDatabaseConfig } from '../config';\nimport { DatabaseConnector } from '../types';\n\n/**\n * Creates a knex SQLite3 database connection\n *\n * @param dbConfig The database config\n * @param overrides Additional options to merge with the config\n */\nexport function createSqliteDatabaseClient(\n  dbConfig: Config,\n  overrides?: Knex.Config,\n) {\n  const knexConfig = buildSqliteDatabaseConfig(dbConfig, overrides);\n\n  // If storage on disk is used, ensure that the directory exists\n  if (\n    (knexConfig.connection as Knex.Sqlite3ConnectionConfig).filename &&\n    (knexConfig.connection as Knex.Sqlite3ConnectionConfig).filename !==\n      ':memory:'\n  ) {\n    const { filename } = knexConfig.connection as Knex.Sqlite3ConnectionConfig;\n    const directory = path.dirname(filename);\n\n    ensureDirSync(directory);\n  }\n\n  const database = knexFactory(knexConfig);\n\n  database.client.pool.on('createSuccess', (_eventId: any, resource: any) => {\n    resource.run('PRAGMA foreign_keys = ON', () => {});\n  });\n\n  return database;\n}\n\n/**\n * Builds a knex SQLite3 connection config\n *\n * @param dbConfig The database config\n * @param overrides Additional options to merge with the config\n */\nexport function buildSqliteDatabaseConfig(\n  dbConfig: Config,\n  overrides?: Knex.Config,\n): Knex.Config {\n  const baseConfig = dbConfig.get<Knex.Config>();\n\n  // Normalize config to always contain a connection object\n  if (typeof baseConfig.connection === 'string') {\n    baseConfig.connection = { filename: baseConfig.connection };\n  }\n  if (overrides && typeof overrides.connection === 'string') {\n    overrides.connection = { filename: overrides.connection };\n  }\n\n  const config: Knex.Config = mergeDatabaseConfig(\n    {\n      connection: {},\n    },\n    baseConfig,\n    {\n      useNullAsDefault: true,\n    },\n    overrides,\n  );\n\n  // If we don't create an in-memory database, interpret the connection string\n  // as a directory that contains multiple sqlite files based on the database\n  // name.\n  const database = (config.connection as Knex.ConnectionConfig).database;\n  const sqliteConnection = config.connection as Knex.Sqlite3ConnectionConfig;\n\n  if (database && sqliteConnection.filename !== ':memory:') {\n    sqliteConnection.filename = path.join(\n      sqliteConnection.filename,\n      `${database}.sqlite`,\n    );\n  }\n\n  return config;\n}\n\n/**\n * Provides a partial knex SQLite3 config to override database name.\n */\nexport function createSqliteNameOverride(name: string): Partial<Knex.Config> {\n  return {\n    connection: parseSqliteConnectionString(name),\n  };\n}\n\n/**\n * Produces a partial knex SQLite3 connection config with database name.\n */\nexport function parseSqliteConnectionString(\n  name: string,\n): Knex.Sqlite3ConnectionConfig {\n  return {\n    filename: name,\n  };\n}\n\n/**\n * SQLite3 database connector.\n *\n * Exposes database connector functionality via an immutable object.\n */\nexport const sqlite3Connector: DatabaseConnector = Object.freeze({\n  createClient: createSqliteDatabaseClient,\n  createNameOverride: createSqliteNameOverride,\n  parseConnectionString: parseSqliteConnectionString,\n});\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config, JsonObject } from '@backstage/config';\nimport { InputError } from '@backstage/errors';\nimport knexFactory, { Knex } from 'knex';\nimport { mergeDatabaseConfig } from './config';\nimport { DatabaseConnector } from './types';\n\nimport { mysqlConnector, pgConnector, sqlite3Connector } from './connectors';\n\ntype DatabaseClient = 'pg' | 'sqlite3' | 'mysql' | 'mysql2' | string;\n\n/**\n * Mapping of client type to supported database connectors\n *\n * Database connectors can be aliased here, for example mysql2 uses\n * the same connector as mysql.\n */\nconst ConnectorMapping: Record<DatabaseClient, DatabaseConnector> = {\n  pg: pgConnector,\n  sqlite3: sqlite3Connector,\n  mysql: mysqlConnector,\n  mysql2: mysqlConnector,\n};\n\n/**\n * Creates a knex database connection\n *\n * @param dbConfig The database config\n * @param overrides Additional options to merge with the config\n */\nexport function createDatabaseClient(\n  dbConfig: Config,\n  overrides?: Partial<Knex.Config>,\n) {\n  const client: DatabaseClient = dbConfig.getString('client');\n\n  return (\n    ConnectorMapping[client]?.createClient(dbConfig, overrides) ??\n    knexFactory(mergeDatabaseConfig(dbConfig.get(), overrides))\n  );\n}\n\n/**\n * Alias for createDatabaseClient\n * @deprecated Use createDatabaseClient instead\n */\nexport const createDatabase = createDatabaseClient;\n\n/**\n * Ensures that the given databases all exist, creating them if they do not.\n */\nexport async function ensureDatabaseExists(\n  dbConfig: Config,\n  ...databases: Array<string>\n): Promise<void> {\n  const client: DatabaseClient = dbConfig.getString('client');\n\n  return ConnectorMapping[client]?.ensureDatabaseExists?.(\n    dbConfig,\n    ...databases,\n  );\n}\n\n/**\n * Provides a Knex.Config object with the provided database name for a given client.\n */\nexport function createNameOverride(\n  client: string,\n  name: string,\n): Partial<Knex.Config> {\n  try {\n    return ConnectorMapping[client].createNameOverride(name);\n  } catch (e) {\n    throw new InputError(\n      `Unable to create database name override for '${client}' connector`,\n      e,\n    );\n  }\n}\n\n/**\n * Parses a connection string for a given client and provides a connection config.\n */\nexport function parseConnectionString(\n  connectionString: string,\n  client?: string,\n): Knex.StaticConnectionConfig {\n  if (typeof client === 'undefined' || client === null) {\n    throw new InputError(\n      'Database connection string client type auto-detection is not yet supported.',\n    );\n  }\n\n  try {\n    return ConnectorMapping[client].parseConnectionString(connectionString);\n  } catch (e) {\n    throw new InputError(\n      `Unable to parse connection string for '${client}' connector`,\n    );\n  }\n}\n\n/**\n * Normalizes a connection config or string into an object which can be passed to Knex.\n */\nexport function normalizeConnection(\n  connection: Knex.StaticConnectionConfig | JsonObject | string | undefined,\n  client: string,\n): Partial<Knex.StaticConnectionConfig> {\n  if (typeof connection === 'undefined' || connection === null) {\n    return {};\n  }\n\n  return typeof connection === 'string' || connection instanceof String\n    ? parseConnectionString(connection as string, client)\n    : connection;\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Knex } from 'knex';\nimport { omit } from 'lodash';\nimport { Config, ConfigReader, JsonObject } from '@backstage/config';\nimport {\n  createDatabaseClient,\n  ensureDatabaseExists,\n  createNameOverride,\n  normalizeConnection,\n} from './connection';\nimport { PluginDatabaseManager } from './types';\n\n/**\n * Provides a config lookup path for a plugin's config block.\n */\nfunction pluginPath(pluginId: string): string {\n  return `plugin.${pluginId}`;\n}\n\nexport class DatabaseManager {\n  /**\n   * Creates a DatabaseManager from `backend.database` config.\n   *\n   * The database manager allows the user to set connection and client settings on a per pluginId\n   * basis by defining a database config block under `plugin.<pluginId>` in addition to top level\n   * defaults. Optionally, a user may set `prefix` which is used to prefix generated database\n   * names if config is not provided.\n   *\n   * @param config The loaded application configuration.\n   */\n  static fromConfig(config: Config): DatabaseManager {\n    const databaseConfig = config.getConfig('backend.database');\n\n    return new DatabaseManager(\n      databaseConfig,\n      databaseConfig.getOptionalString('prefix'),\n    );\n  }\n\n  private constructor(\n    private readonly config: Config,\n    private readonly prefix: string = 'backstage_plugin_',\n  ) {}\n\n  /**\n   * Generates a PluginDatabaseManager for consumption by plugins.\n   *\n   * @param pluginId The plugin that the database manager should be created for. Plugin names\n   * should be unique as they are used to look up database config overrides under\n   * `backend.database.plugin`.\n   */\n  forPlugin(pluginId: string): PluginDatabaseManager {\n    const _this = this;\n\n    return {\n      getClient(): Promise<Knex> {\n        return _this.getDatabase(pluginId);\n      },\n    };\n  }\n\n  /**\n   * Provides the canonical database name for a given plugin.\n   *\n   * This method provides the effective database name which is determined using global\n   * and plugin specific database config. If no explicit database name is configured,\n   * this method will provide a generated name which is the pluginId prefixed with\n   * 'backstage_plugin_'.\n   *\n   * @param pluginId Lookup the database name for given plugin\n   * @returns String representing the plugin's database name\n   */\n  private getDatabaseName(pluginId: string): string {\n    const connection = this.getConnectionConfig(pluginId);\n\n    if (this.getClientType(pluginId).client === 'sqlite3') {\n      // sqlite database name should fallback to ':memory:' as a special case\n      return (\n        (connection as Knex.Sqlite3ConnectionConfig)?.filename ?? ':memory:'\n      );\n    }\n    // all other supported databases should fallback to an auto-prefixed name\n    return (\n      (connection as Knex.ConnectionConfig)?.database ??\n      `${this.prefix}${pluginId}`\n    );\n  }\n\n  /**\n   * Provides the client type which should be used for a given plugin.\n   *\n   * The client type is determined by plugin specific config if present. Otherwise the base\n   * client is used as the fallback.\n   *\n   * @param pluginId Plugin to get the client type for\n   * @returns Object with client type returned as `client` and boolean representing whether\n   * or not the client was overridden as `overridden`\n   */\n  private getClientType(pluginId: string): {\n    client: string;\n    overridden: boolean;\n  } {\n    const pluginClient = this.config.getOptionalString(\n      `${pluginPath(pluginId)}.client`,\n    );\n\n    const baseClient = this.config.getString('client');\n    const client = pluginClient ?? baseClient;\n    return {\n      client,\n      overridden: client !== baseClient,\n    };\n  }\n\n  private getEnsureExistsConfig(pluginId: string): boolean {\n    const baseConfig = this.config.getOptionalBoolean('ensureExists') ?? true;\n    return (\n      this.config.getOptionalBoolean(`${pluginPath(pluginId)}.ensureExists`) ??\n      baseConfig\n    );\n  }\n\n  /**\n   * Provides a Knex connection plugin config by combining base and plugin config.\n   *\n   * This method provides a baseConfig for a plugin database connector. If the client type\n   * has not been overridden, the global connection config will be included with plugin\n   * specific config as the base. Values from the plugin connection take precedence over the\n   * base. Base database name is omitted for all supported databases excluding SQLite.\n   */\n  private getConnectionConfig(\n    pluginId: string,\n  ): Partial<Knex.StaticConnectionConfig> {\n    const { client, overridden } = this.getClientType(pluginId);\n\n    let baseConnection = normalizeConnection(\n      this.config.get('connection'),\n      this.config.getString('client'),\n    );\n    // As databases cannot be shared, the `database` property from the base connection\n    // is omitted. SQLite3's `filename` property is an exception as this is used as a\n    // directory elsewhere so we preserve `filename`.\n    baseConnection = omit(baseConnection, 'database');\n\n    // get and normalize optional plugin specific database connection\n    const connection = normalizeConnection(\n      this.config.getOptional(`${pluginPath(pluginId)}.connection`),\n      client,\n    );\n\n    return {\n      // include base connection if client type has not been overriden\n      ...(overridden ? {} : baseConnection),\n      ...connection,\n    };\n  }\n\n  /**\n   * Provides a Knex database config for a given plugin.\n   *\n   * This method provides a Knex configuration object along with the plugin's client type.\n   *\n   * @param pluginId The plugin that the database config should correspond with\n   */\n  private getConfigForPlugin(pluginId: string): Knex.Config {\n    const { client } = this.getClientType(pluginId);\n\n    return {\n      client,\n      connection: this.getConnectionConfig(pluginId),\n    };\n  }\n\n  /**\n   * Provides a partial Knex.Config database name override for a given plugin.\n   *\n   * @param pluginId Target plugin to get database name override\n   * @returns Partial Knex.Config with database name override\n   */\n  private getDatabaseOverrides(pluginId: string): Knex.Config {\n    return createNameOverride(\n      this.getClientType(pluginId).client,\n      this.getDatabaseName(pluginId),\n    );\n  }\n\n  /**\n   * Provides a scoped Knex client for a plugin as per application config.\n   *\n   *  @param pluginId Plugin to get a Knex client for\n   *  @returns Promise which resolves to a scoped Knex database client for a plugin\n   */\n  private async getDatabase(pluginId: string): Promise<Knex> {\n    const pluginConfig = new ConfigReader(\n      this.getConfigForPlugin(pluginId) as JsonObject,\n    );\n\n    if (this.getEnsureExistsConfig(pluginId)) {\n      const databaseName = this.getDatabaseName(pluginId);\n      try {\n        await ensureDatabaseExists(pluginConfig, databaseName);\n      } catch (error) {\n        throw new Error(\n          `Failed to connect to the database to make sure that '${databaseName}' exists, ${error}`,\n        );\n      }\n    }\n\n    return createDatabaseClient(\n      pluginConfig,\n      this.getDatabaseOverrides(pluginId),\n    );\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DatabaseManager } from './DatabaseManager';\n\n/**\n * Implements a Database Manager which will automatically create new databases\n * for plugins when requested. All requested databases are created with the\n * credentials provided; if the database already exists no attempt to create\n * the database will be made.\n *\n * @deprecated Use `DatabaseManager` from `@backend-common` instead.\n */\nexport const SingleConnectionDatabaseManager = DatabaseManager;\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport { CorsOptions } from 'cors';\n\nexport type BaseOptions = {\n  listenPort?: string | number;\n  listenHost?: string;\n};\n\nexport type HttpsSettings = {\n  certificate: CertificateGenerationOptions | CertificateReferenceOptions;\n};\n\nexport type CertificateReferenceOptions = {\n  key: string;\n  cert: string;\n};\n\nexport type CertificateGenerationOptions = {\n  hostname: string;\n};\n\nexport type CertificateAttributes = {\n  commonName: string;\n};\n\n/**\n * A map from CSP directive names to their values.\n *\n * Added here since helmet doesn't export this type publicly.\n */\nexport type CspOptions = Record<string, string[]>;\n\n/**\n * Reads some base options out of a config object.\n *\n * @param config The root of a backend config object\n * @returns A base options object\n *\n * @example\n * ```json\n * {\n *   baseUrl: \"http://localhost:7000\",\n *   listen: \"0.0.0.0:7000\"\n * }\n * ```\n */\nexport function readBaseOptions(config: Config): BaseOptions {\n  if (typeof config.get('listen') === 'string') {\n    // TODO(freben): Expand this to support more addresses and perhaps optional\n    const { host, port } = parseListenAddress(config.getString('listen'));\n\n    return removeUnknown({\n      listenPort: port,\n      listenHost: host,\n    });\n  }\n\n  const port = config.getOptional('listen.port');\n  if (\n    typeof port !== 'undefined' &&\n    typeof port !== 'number' &&\n    typeof port !== 'string'\n  ) {\n    throw new Error(\n      `Invalid type in config for key 'backend.listen.post', got ${typeof port}, wanted string or number`,\n    );\n  }\n\n  return removeUnknown({\n    listenPort: port,\n    listenHost: config.getOptionalString('listen.host'),\n    baseUrl: config.getOptionalString('baseUrl'),\n  });\n}\n\n/**\n * Attempts to read a CORS options object from the root of a config object.\n *\n * @param config The root of a backend config object\n * @returns A CORS options object, or undefined if not specified\n *\n * @example\n * ```json\n * {\n *   cors: {\n *    origin: \"http://localhost:3000\",\n *    credentials: true\n *   }\n * }\n * ```\n */\nexport function readCorsOptions(config: Config): CorsOptions | undefined {\n  const cc = config.getOptionalConfig('cors');\n  if (!cc) {\n    return undefined;\n  }\n\n  return removeUnknown({\n    origin: getOptionalStringOrStrings(cc, 'origin'),\n    methods: getOptionalStringOrStrings(cc, 'methods'),\n    allowedHeaders: getOptionalStringOrStrings(cc, 'allowedHeaders'),\n    exposedHeaders: getOptionalStringOrStrings(cc, 'exposedHeaders'),\n    credentials: cc.getOptionalBoolean('credentials'),\n    maxAge: cc.getOptionalNumber('maxAge'),\n    preflightContinue: cc.getOptionalBoolean('preflightContinue'),\n    optionsSuccessStatus: cc.getOptionalNumber('optionsSuccessStatus'),\n  });\n}\n\n/**\n * Attempts to read a CSP options object from the root of a config object.\n *\n * @param config The root of a backend config object\n * @returns A CSP options object, or undefined if not specified. Values can be\n *          false as well, which means to remove the default behavior for that\n *          key.\n *\n * @example\n * ```yaml\n * backend:\n *   csp:\n *     connect-src: [\"'self'\", 'http:', 'https:']\n *     upgrade-insecure-requests: false\n * ```\n */\nexport function readCspOptions(\n  config: Config,\n): Record<string, string[] | false> | undefined {\n  const cc = config.getOptionalConfig('csp');\n  if (!cc) {\n    return undefined;\n  }\n\n  const result: Record<string, string[] | false> = {};\n  for (const key of cc.keys()) {\n    if (cc.get(key) === false) {\n      result[key] = false;\n    } else {\n      result[key] = cc.getStringArray(key);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Attempts to read a https settings object from the root of a config object.\n *\n * @param config The root of a backend config object\n * @returns A https settings object, or undefined if not specified\n *\n * @example\n * ```json\n * {\n *   https: {\n *    certificate: ...\n *   }\n * }\n * ```\n */\nexport function readHttpsSettings(config: Config): HttpsSettings | undefined {\n  const https = config.getOptional('https');\n  if (https === true) {\n    const baseUrl = config.getString('baseUrl');\n    let hostname;\n    try {\n      hostname = new URL(baseUrl).hostname;\n    } catch (error) {\n      throw new Error(`Invalid backend.baseUrl \"${baseUrl}\"`);\n    }\n\n    return { certificate: { hostname } };\n  }\n\n  const cc = config.getOptionalConfig('https');\n  if (!cc) {\n    return undefined;\n  }\n\n  const certificateConfig = cc.get('certificate');\n\n  const cfg = {\n    certificate: certificateConfig,\n  };\n\n  return removeUnknown(cfg as HttpsSettings);\n}\n\nfunction getOptionalStringOrStrings(\n  config: Config,\n  key: string,\n): string | string[] | undefined {\n  const value = config.getOptional(key);\n  if (\n    value === undefined ||\n    typeof value === 'string' ||\n    isStringArray(value)\n  ) {\n    return value;\n  }\n  throw new Error(`Expected string or array of strings, got ${typeof value}`);\n}\n\nfunction isStringArray(value: any): value is string[] {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n  for (const v of value) {\n    if (typeof v !== 'string') {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction removeUnknown<T extends object>(obj: T): T {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([, v]) => v !== undefined),\n  ) as T;\n}\n\nfunction parseListenAddress(value: string): { host?: string; port?: number } {\n  const parts = value.split(':');\n  if (parts.length === 1) {\n    return { port: parseInt(parts[0], 10) };\n  }\n  if (parts.length === 2) {\n    return { host: parts[0], port: parseInt(parts[1], 10) };\n  }\n  throw new Error(\n    `Unable to parse listen address ${value}, expected <port> or <host>:<port>`,\n  );\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Find all active hot module APIs of all ancestors of a module, including the module itself\nfunction findAllAncestors(_module: NodeModule): NodeModule[] {\n  const ancestors = new Array<NodeModule>();\n  const parentIds = new Set<string | number>();\n\n  function add(id: string | number, m: NodeModule) {\n    if (parentIds.has(id)) {\n      return;\n    }\n    parentIds.add(id);\n    ancestors.push(m);\n\n    for (const parentId of (m as any).parents) {\n      const parent = require.cache[parentId];\n      if (parent) {\n        add(parentId, parent);\n      }\n    }\n  }\n\n  add(_module.id, _module);\n\n  return ancestors;\n}\n\n/**\n * useHotCleanup allows cleanup of ongoing effects when a module is\n * hot-reloaded during development. The cleanup function will be called\n * whenever the module itself or any of its parent modules is hot-reloaded.\n *\n * Useful for cleaning intervals, timers, requests etc\n *\n * @example\n * ```ts\n * const intervalId = setInterval(doStuff, 1000);\n * useHotCleanup(module, () => clearInterval(intervalId));\n * ```\n * @param _module Reference to the current module where you invoke the fn\n * @param cancelEffect Fn that cleans up the ongoing effects\n */\nexport function useHotCleanup(_module: NodeModule, cancelEffect: () => void) {\n  if (_module.hot) {\n    const ancestors = findAllAncestors(_module);\n    let cancelled = false;\n\n    const handler = () => {\n      if (!cancelled) {\n        cancelled = true;\n        cancelEffect();\n      }\n    };\n\n    for (const m of ancestors) {\n      m.hot?.addDisposeHandler(handler);\n    }\n  }\n}\n\nconst CURRENT_HOT_MEMOIZE_INDEX_KEY = 'backstage.io/hmr-memoize-key';\n\n/**\n * Memoizes a generated value across hot-module reloads. This is useful for\n * stateful parts of the backend, e.g. to retain a database.\n *\n * @example\n * ```ts\n * const db = useHotMemoize(module, () => createDB(dbParams));\n * ```\n *\n * @warning Don't use inside conditionals or loops,\n * same rules as for hooks apply (https://reactjs.org/docs/hooks-rules.html)\n *\n * @param _module Reference to the current module where you invoke the fn\n * @param valueFactory Fn that returns the value you want to memoize\n */\nexport function useHotMemoize<T>(\n  _module: NodeModule,\n  valueFactory: () => T,\n): T {\n  if (!_module.hot) {\n    return valueFactory();\n  }\n\n  // When starting blank, reset the counter\n  if (!_module.hot.data?.[CURRENT_HOT_MEMOIZE_INDEX_KEY]) {\n    for (const ancestor of findAllAncestors(_module)) {\n      ancestor.hot?.addDisposeHandler(data => {\n        data[CURRENT_HOT_MEMOIZE_INDEX_KEY] = 1;\n      });\n    }\n\n    _module.hot.data = {\n      ..._module.hot.data,\n      [CURRENT_HOT_MEMOIZE_INDEX_KEY]: 1,\n    };\n  }\n\n  // Store data per module, based on the order of the code invocation\n  const index = _module.hot.data[CURRENT_HOT_MEMOIZE_INDEX_KEY]++;\n  const value = _module.hot.data[index] ?? valueFactory();\n\n  // Always add a handler that, upon a HMR event, reinstates the value.\n  _module.hot.addDisposeHandler(data => {\n    data[index] = value;\n  });\n\n  return value;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AuthenticationError,\n  ConflictError,\n  ErrorResponse,\n  InputError,\n  NotAllowedError,\n  NotFoundError,\n  NotModifiedError,\n  serializeError,\n} from '@backstage/errors';\nimport { ErrorRequestHandler, NextFunction, Request, Response } from 'express';\nimport { Logger } from 'winston';\nimport { getRootLogger } from '../logging';\n\nexport type ErrorHandlerOptions = {\n  /**\n   * Whether error response bodies should show error stack traces or not.\n   *\n   * If not specified, by default shows stack traces only in development mode.\n   */\n  showStackTraces?: boolean;\n\n  /**\n   * Logger instance to log errors.\n   *\n   * If not specified, the root logger will be used.\n   */\n  logger?: Logger;\n\n  /**\n   * Whether any error < 4XX should be logged or not.\n   *\n   * If not specified, by default log any 5xx errors.\n   */\n  logClientErrors?: boolean;\n};\n\n/**\n * Express middleware to handle errors during request processing.\n *\n * This is commonly the very last middleware in the chain.\n *\n * Its primary purpose is not to do translation of business logic exceptions,\n * but rather to be a global catch-all for uncaught \"fatal\" errors that are\n * expected to result in a 500 error. However, it also does handle some common\n * error types (such as http-error exceptions) and returns the enclosed status\n * code accordingly.\n *\n * @returns An Express error request handler\n */\nexport function errorHandler(\n  options: ErrorHandlerOptions = {},\n): ErrorRequestHandler {\n  const showStackTraces =\n    options.showStackTraces ?? process.env.NODE_ENV === 'development';\n\n  const logger = (options.logger || getRootLogger()).child({\n    type: 'errorHandler',\n  });\n\n  return (error: Error, req: Request, res: Response, next: NextFunction) => {\n    const statusCode = getStatusCode(error);\n    if (options.logClientErrors || statusCode >= 500) {\n      logger.error(error);\n    }\n\n    if (res.headersSent) {\n      // If the headers have already been sent, do not send the response again\n      // as this will throw an error in the backend.\n      next(error);\n      return;\n    }\n\n    const body: ErrorResponse = {\n      error: serializeError(error, { includeStack: showStackTraces }),\n      request: { method: req.method, url: req.url },\n      response: { statusCode },\n    };\n\n    res.status(statusCode).json(body);\n  };\n}\n\nfunction getStatusCode(error: Error): number {\n  // Look for common http library status codes\n  const knownStatusCodeFields = ['statusCode', 'status'];\n  for (const field of knownStatusCodeFields) {\n    const statusCode = (error as any)[field];\n    if (\n      typeof statusCode === 'number' &&\n      (statusCode | 0) === statusCode && // is whole integer\n      statusCode >= 100 &&\n      statusCode <= 599\n    ) {\n      return statusCode;\n    }\n  }\n\n  // Handle well-known error types\n  switch (error.name) {\n    case NotModifiedError.name:\n      return 304;\n    case InputError.name:\n      return 400;\n    case AuthenticationError.name:\n      return 401;\n    case NotAllowedError.name:\n      return 403;\n    case NotFoundError.name:\n      return 404;\n    case ConflictError.name:\n      return 409;\n    default:\n      break;\n  }\n\n  // Fall back to internal server error\n  return 500;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NextFunction, Request, RequestHandler, Response } from 'express';\n\n/**\n * Express middleware to handle requests for missing routes.\n *\n * Should be used as the very last handler in the chain, as it unconditionally\n * returns a 404 status.\n *\n * @returns An Express request handler\n */\nexport function notFoundHandler(): RequestHandler {\n  /* eslint-disable @typescript-eslint/no-unused-vars */\n  return (_request: Request, response: Response, _next: NextFunction) => {\n    response.status(404).send();\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RequestHandler } from 'express';\nimport { Logger } from 'winston';\nimport morgan from 'morgan';\nimport { getRootLogger } from '../logging';\n\n/**\n * Logs incoming requests.\n *\n * @param logger An optional logger to use. If not specified, the root logger will be used.\n * @returns An Express request handler\n */\nexport function requestLoggingHandler(logger?: Logger): RequestHandler {\n  const actualLogger = (logger || getRootLogger()).child({\n    type: 'incomingRequest',\n  });\n\n  return morgan('combined', {\n    stream: {\n      write(message: String) {\n        actualLogger.info(message.trimRight());\n      },\n    },\n  });\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NextFunction, Request, Response, RequestHandler } from 'express';\n\nexport type StatusCheck = () => Promise<any>;\n\nexport interface StatusCheckHandlerOptions {\n  /**\n   * Optional status function which returns a message.\n   */\n  statusCheck?: StatusCheck;\n}\n\n/**\n * Express middleware for status checks.\n *\n * This is commonly used to implement healthcheck and readiness routes.\n *\n * @param options An optional configuration object.\n * @returns An Express error request handler\n */\nexport async function statusCheckHandler(\n  options: StatusCheckHandlerOptions = {},\n): Promise<RequestHandler> {\n  const statusCheck: StatusCheck = options.statusCheck\n    ? options.statusCheck\n    : () => Promise.resolve({ status: 'ok' });\n\n  return async (_request: Request, response: Response, next: NextFunction) => {\n    try {\n      const status = await statusCheck();\n      response.status(200).header('').send(status);\n    } catch (err) {\n      next(err);\n    }\n  };\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs-extra';\nimport { resolve as resolvePath, dirname } from 'path';\nimport express from 'express';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { Logger } from 'winston';\nimport { HttpsSettings } from './config';\n\nconst ALMOST_MONTH_IN_MS = 25 * 24 * 60 * 60 * 1000;\n\nconst IP_HOSTNAME_REGEX = /:|^\\d+\\.\\d+\\.\\d+\\.\\d+$/;\n\n/**\n * Creates a Http server instance based on an Express application.\n *\n * @param app The Express application object\n * @param logger Optional Winston logger object\n * @returns A Http server instance\n *\n */\nexport function createHttpServer(\n  app: express.Express,\n  logger?: Logger,\n): http.Server {\n  logger?.info('Initializing http server');\n\n  return http.createServer(app);\n}\n\n/**\n * Creates a Https server instance based on an Express application.\n *\n * @param app The Express application object\n * @param httpsSettings HttpsSettings for self-signed certificate generation\n * @param logger Optional Winston logger object\n * @returns A Https server instance\n *\n */\nexport async function createHttpsServer(\n  app: express.Express,\n  httpsSettings: HttpsSettings,\n  logger?: Logger,\n): Promise<http.Server> {\n  logger?.info('Initializing https server');\n\n  let credentials: { key: string | Buffer; cert: string | Buffer };\n\n  if ('hostname' in httpsSettings?.certificate) {\n    credentials = await getGeneratedCertificate(\n      httpsSettings.certificate.hostname,\n      logger,\n    );\n  } else {\n    logger?.info('Loading certificate from config');\n\n    credentials = {\n      key: httpsSettings?.certificate?.key,\n      cert: httpsSettings?.certificate?.cert,\n    };\n  }\n\n  if (!credentials.key || !credentials.cert) {\n    throw new Error('Invalid HTTPS credentials');\n  }\n\n  return https.createServer(credentials, app) as http.Server;\n}\n\nasync function getGeneratedCertificate(hostname: string, logger?: Logger) {\n  const hasModules = await fs.pathExists('node_modules');\n  let certPath;\n  if (hasModules) {\n    certPath = resolvePath(\n      'node_modules/.cache/backstage-backend/dev-cert.pem',\n    );\n    await fs.ensureDir(dirname(certPath));\n  } else {\n    certPath = resolvePath('.dev-cert.pem');\n  }\n\n  let cert = undefined;\n  if (await fs.pathExists(certPath)) {\n    const stat = await fs.stat(certPath);\n    const ageMs = Date.now() - stat.ctimeMs;\n    if (stat.isFile() && ageMs < ALMOST_MONTH_IN_MS) {\n      cert = await fs.readFile(certPath);\n    }\n  }\n\n  if (cert) {\n    logger?.info('Using existing self-signed certificate');\n    return {\n      key: cert,\n      cert: cert,\n    };\n  }\n\n  logger?.info('Generating new self-signed certificate');\n  const newCert = await createCertificate(hostname);\n  await fs.writeFile(certPath, newCert.cert + newCert.key, 'utf8');\n  return newCert;\n}\n\nasync function createCertificate(hostname: string) {\n  const attributes = [\n    {\n      name: 'commonName',\n      value: 'dev-cert',\n    },\n  ];\n\n  const sans = [\n    {\n      type: 2, // DNS\n      value: 'localhost',\n    },\n    {\n      type: 2,\n      value: 'localhost.localdomain',\n    },\n    {\n      type: 2,\n      value: '[::1]',\n    },\n    {\n      type: 7, // IP\n      ip: '127.0.0.1',\n    },\n    {\n      type: 7,\n      ip: 'fe80::1',\n    },\n  ];\n\n  // Add hostname from backend.baseUrl if it doesn't already exist in our list of SANs\n  if (!sans.find(({ value, ip }) => value === hostname || ip === hostname)) {\n    sans.push(\n      IP_HOSTNAME_REGEX.test(hostname)\n        ? {\n            type: 7,\n            ip: hostname,\n          }\n        : {\n            type: 2,\n            value: hostname,\n          },\n    );\n  }\n\n  const params = {\n    algorithm: 'sha256',\n    keySize: 2048,\n    days: 30,\n    extensions: [\n      {\n        name: 'keyUsage',\n        keyCertSign: true,\n        digitalSignature: true,\n        nonRepudiation: true,\n        keyEncipherment: true,\n        dataEncipherment: true,\n      },\n      {\n        name: 'extKeyUsage',\n        serverAuth: true,\n        clientAuth: true,\n        codeSigning: true,\n        timeStamping: true,\n      },\n      {\n        name: 'subjectAltName',\n        altNames: sans,\n      },\n    ],\n  };\n\n  return new Promise<{ key: string; cert: string }>((resolve, reject) =>\n    require('selfsigned').generate(\n      attributes,\n      params,\n      (err: Error, bundle: { private: string; cert: string }) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve({ key: bundle.private, cert: bundle.cert });\n        }\n      },\n    ),\n  );\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport compression from 'compression';\nimport cors from 'cors';\nimport express, { Router } from 'express';\nimport helmet from 'helmet';\nimport * as http from 'http';\nimport stoppable from 'stoppable';\nimport { Logger } from 'winston';\nimport { useHotCleanup } from '../../hot';\nimport { getRootLogger } from '../../logging';\nimport {\n  errorHandler,\n  notFoundHandler,\n  requestLoggingHandler as defaultRequestLoggingHandler,\n} from '../../middleware';\nimport { RequestLoggingHandlerFactory, ServiceBuilder } from '../types';\nimport {\n  CspOptions,\n  HttpsSettings,\n  readBaseOptions,\n  readCorsOptions,\n  readCspOptions,\n  readHttpsSettings,\n} from './config';\nimport { createHttpServer, createHttpsServer } from './hostFactory';\n\nexport const DEFAULT_PORT = 7000;\n// '' is express default, which listens to all interfaces\nconst DEFAULT_HOST = '';\n// taken from the helmet source code - don't seem to be exported\nconst DEFAULT_CSP = {\n  'default-src': [\"'self'\"],\n  'base-uri': [\"'self'\"],\n  'block-all-mixed-content': [],\n  'font-src': [\"'self'\", 'https:', 'data:'],\n  'frame-ancestors': [\"'self'\"],\n  'img-src': [\"'self'\", 'data:'],\n  'object-src': [\"'none'\"],\n  'script-src': [\"'self'\", \"'unsafe-eval'\"],\n  'script-src-attr': [\"'none'\"],\n  'style-src': [\"'self'\", 'https:', \"'unsafe-inline'\"],\n};\n\nexport class ServiceBuilderImpl implements ServiceBuilder {\n  private port: number | undefined;\n  private host: string | undefined;\n  private logger: Logger | undefined;\n  private corsOptions: cors.CorsOptions | undefined;\n  private cspOptions: Record<string, string[] | false> | undefined;\n  private httpsSettings: HttpsSettings | undefined;\n  private routers: [string, Router][];\n  private requestLoggingHandler: RequestLoggingHandlerFactory | undefined;\n  // Reference to the module where builder is created - needed for hot module\n  // reloading\n  private module: NodeModule;\n\n  constructor(moduleRef: NodeModule) {\n    this.routers = [];\n    this.module = moduleRef;\n  }\n\n  loadConfig(config: Config): ServiceBuilder {\n    const backendConfig = config.getOptionalConfig('backend');\n    if (!backendConfig) {\n      return this;\n    }\n\n    const baseOptions = readBaseOptions(backendConfig);\n    if (baseOptions.listenPort) {\n      this.port =\n        typeof baseOptions.listenPort === 'string'\n          ? parseInt(baseOptions.listenPort, 10)\n          : baseOptions.listenPort;\n    }\n    if (baseOptions.listenHost) {\n      this.host = baseOptions.listenHost;\n    }\n\n    const corsOptions = readCorsOptions(backendConfig);\n    if (corsOptions) {\n      this.corsOptions = corsOptions;\n    }\n\n    const cspOptions = readCspOptions(backendConfig);\n    if (cspOptions) {\n      this.cspOptions = cspOptions;\n    }\n\n    const httpsSettings = readHttpsSettings(backendConfig);\n    if (httpsSettings) {\n      this.httpsSettings = httpsSettings;\n    }\n\n    return this;\n  }\n\n  setPort(port: number): ServiceBuilder {\n    this.port = port;\n    return this;\n  }\n\n  setHost(host: string): ServiceBuilder {\n    this.host = host;\n    return this;\n  }\n\n  setLogger(logger: Logger): ServiceBuilder {\n    this.logger = logger;\n    return this;\n  }\n\n  setHttpsSettings(settings: HttpsSettings): ServiceBuilder {\n    this.httpsSettings = settings;\n    return this;\n  }\n\n  enableCors(options: cors.CorsOptions): ServiceBuilder {\n    this.corsOptions = options;\n    return this;\n  }\n\n  setCsp(options: CspOptions): ServiceBuilder {\n    this.cspOptions = options;\n    return this;\n  }\n\n  addRouter(root: string, router: Router): ServiceBuilder {\n    this.routers.push([root, router]);\n    return this;\n  }\n\n  setRequestLoggingHandler(\n    requestLoggingHandler: RequestLoggingHandlerFactory,\n  ) {\n    this.requestLoggingHandler = requestLoggingHandler;\n    return this;\n  }\n\n  async start(): Promise<http.Server> {\n    const app = express();\n    const { port, host, logger, corsOptions, httpsSettings, helmetOptions } =\n      this.getOptions();\n\n    app.use(helmet(helmetOptions));\n    if (corsOptions) {\n      app.use(cors(corsOptions));\n    }\n    app.use(compression());\n    app.use(\n      (this.requestLoggingHandler ?? defaultRequestLoggingHandler)(logger),\n    );\n    for (const [root, route] of this.routers) {\n      app.use(root, route);\n    }\n    app.use(notFoundHandler());\n    app.use(errorHandler());\n\n    const server: http.Server = httpsSettings\n      ? await createHttpsServer(app, httpsSettings, logger)\n      : createHttpServer(app, logger);\n\n    return new Promise((resolve, reject) => {\n      app.on('error', e => {\n        logger.error(`Failed to start up on port ${port}, ${e}`);\n        reject(e);\n      });\n\n      const stoppableServer = stoppable(\n        server.listen(port, host, () => {\n          logger.info(`Listening on ${host}:${port}`);\n        }),\n        0,\n      );\n\n      useHotCleanup(this.module, () =>\n        stoppableServer.stop((e: any) => {\n          if (e) console.error(e);\n        }),\n      );\n\n      resolve(stoppableServer);\n    });\n  }\n\n  private getOptions() {\n    return {\n      port: this.port ?? DEFAULT_PORT,\n      host: this.host ?? DEFAULT_HOST,\n      logger: this.logger ?? getRootLogger(),\n      corsOptions: this.corsOptions,\n      httpsSettings: this.httpsSettings,\n      helmetOptions: {\n        contentSecurityPolicy: {\n          directives: applyCspDirectives(this.cspOptions),\n        },\n      },\n    };\n  }\n}\n\nexport function applyCspDirectives(\n  directives: Record<string, string[] | false> | undefined,\n): CspOptions | undefined {\n  const result: CspOptions = { ...DEFAULT_CSP };\n\n  if (directives) {\n    for (const [key, value] of Object.entries(directives)) {\n      if (value === false) {\n        delete result[key];\n      } else {\n        result[key] = value;\n      }\n    }\n  }\n\n  return result;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport { PluginEndpointDiscovery } from './types';\nimport { readBaseOptions } from '../service/lib/config';\nimport { DEFAULT_PORT } from '../service/lib/ServiceBuilderImpl';\n\n/**\n * SingleHostDiscovery is a basic PluginEndpointDiscovery implementation\n * that assumes that all plugins are hosted in a single deployment.\n *\n * The deployment may be scaled horizontally, as long as the external URL\n * is the same for all instances. However, internal URLs will always be\n * resolved to the same host, so there won't be any balancing of internal traffic.\n */\nexport class SingleHostDiscovery implements PluginEndpointDiscovery {\n  /**\n   * Creates a new SingleHostDiscovery discovery instance by reading\n   * from the `backend` config section, specifically the `.baseUrl` for\n   * discovering the external URL, and the `.listen` and `.https` config\n   * for the internal one.\n   *\n   * The basePath defaults to `/api`, meaning the default full internal\n   * path for the `catalog` plugin will be `http://localhost:7000/api/catalog`.\n   */\n  static fromConfig(config: Config, options?: { basePath?: string }) {\n    const basePath = options?.basePath ?? '/api';\n    const externalBaseUrl = config.getString('backend.baseUrl');\n\n    const { listenHost = '::', listenPort = DEFAULT_PORT } = readBaseOptions(\n      config.getConfig('backend'),\n    );\n    const protocol = config.has('backend.https') ? 'https' : 'http';\n\n    // Translate bind-all to localhost, and support IPv6\n    let host = listenHost;\n    if (host === '::') {\n      // We use localhost instead of ::1, since IPv6-compatible systems should default\n      // to using IPv6 when they see localhost, but if the system doesn't support IPv6\n      // things will still work.\n      host = 'localhost';\n    } else if (host === '0.0.0.0') {\n      host = '127.0.0.1';\n    }\n    if (host.includes(':')) {\n      host = `[${host}]`;\n    }\n\n    const internalBaseUrl = `${protocol}://${host}:${listenPort}`;\n\n    return new SingleHostDiscovery(\n      internalBaseUrl + basePath,\n      externalBaseUrl + basePath,\n    );\n  }\n\n  private constructor(\n    private readonly internalBaseUrl: string,\n    private readonly externalBaseUrl: string,\n  ) {}\n\n  async getBaseUrl(pluginId: string): Promise<string> {\n    return `${this.internalBaseUrl}/${pluginId}`;\n  }\n\n  async getExternalBaseUrl(pluginId: string): Promise<string> {\n    return `${this.externalBaseUrl}/${pluginId}`;\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isChildPath } from '@backstage/cli-common';\nimport { NotAllowedError } from '@backstage/errors';\nimport { resolve as resolvePath } from 'path';\n\n/**\n * Resolve a path relative to the root of a package directory.\n * Additional path arguments are resolved relative to the package dir.\n *\n * This is particularly useful when you want to access assets shipped with\n * your backend plugin package. When doing so, do not forget to include the assets\n * in your published package by adding them to `files` in your `package.json`.\n */\nexport function resolvePackagePath(name: string, ...paths: string[]) {\n  const req =\n    typeof __non_webpack_require__ === 'undefined'\n      ? require\n      : __non_webpack_require__;\n\n  return resolvePath(req.resolve(`${name}/package.json`), '..', ...paths);\n}\n\n/**\n * Resolves a target path from a base path while guaranteeing that the result is\n * a path that point to or within the base path. This is useful for resolving\n * paths from user input, as it otherwise opens up for vulnerabilities.\n *\n * @param base The base directory to resolve the path from.\n * @param path The target path, relative or absolute\n * @returns A path that is guaranteed to point to or within the base path.\n */\nexport function resolveSafeChildPath(base: string, path: string): string {\n  const targetPath = resolvePath(base, path);\n\n  if (!isChildPath(base, targetPath)) {\n    throw new NotAllowedError(\n      'Relative path is not allowed to refer to a directory outside its parent',\n    );\n  }\n\n  return targetPath;\n}\n\n// Re-export isChildPath so that backend packages don't need to depend on cli-common\nexport { isChildPath };\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Matches a directory name + one `/` at the start of any string,\n// containing any character except `/` one or more times, and ending with a `/`\n// e.g. Will match `dirA/` in `dirA/dirB/file.ext`\nconst directoryNameRegex = /^[^\\/]+\\//;\n\n// Removes the first segment of a forward-slash-separated path\nexport function stripFirstDirectoryFromPath(path: string): string {\n  return path.replace(directoryNameRegex, '');\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AzureIntegration,\n  getAzureCommitsUrl,\n  getAzureDownloadUrl,\n  getAzureFileFetchUrl,\n  getAzureRequestOptions,\n  ScmIntegrations,\n} from '@backstage/integration';\nimport fetch from 'cross-fetch';\nimport parseGitUrl from 'git-url-parse';\nimport { Minimatch } from 'minimatch';\nimport { Readable } from 'stream';\nimport { NotFoundError, NotModifiedError } from '@backstage/errors';\nimport { stripFirstDirectoryFromPath } from './tree/util';\nimport {\n  ReadTreeResponseFactory,\n  ReaderFactory,\n  ReadTreeOptions,\n  ReadTreeResponse,\n  SearchOptions,\n  SearchResponse,\n  UrlReader,\n  ReadUrlOptions,\n  ReadUrlResponse,\n} from './types';\n\nexport class AzureUrlReader implements UrlReader {\n  static factory: ReaderFactory = ({ config, treeResponseFactory }) => {\n    const integrations = ScmIntegrations.fromConfig(config);\n    return integrations.azure.list().map(integration => {\n      const reader = new AzureUrlReader(integration, { treeResponseFactory });\n      const predicate = (url: URL) => url.host === integration.config.host;\n      return { reader, predicate };\n    });\n  };\n\n  constructor(\n    private readonly integration: AzureIntegration,\n    private readonly deps: { treeResponseFactory: ReadTreeResponseFactory },\n  ) {}\n\n  async read(url: string): Promise<Buffer> {\n    const builtUrl = getAzureFileFetchUrl(url);\n\n    let response: Response;\n    try {\n      response = await fetch(\n        builtUrl,\n        getAzureRequestOptions(this.integration.config),\n      );\n    } catch (e) {\n      throw new Error(`Unable to read ${url}, ${e}`);\n    }\n\n    // for private repos when PAT is not valid, Azure API returns a http status code 203 with sign in page html\n    if (response.ok && response.status !== 203) {\n      return Buffer.from(await response.arrayBuffer());\n    }\n\n    const message = `${url} could not be read as ${builtUrl}, ${response.status} ${response.statusText}`;\n    if (response.status === 404) {\n      throw new NotFoundError(message);\n    }\n    throw new Error(message);\n  }\n\n  async readUrl(\n    url: string,\n    _options?: ReadUrlOptions,\n  ): Promise<ReadUrlResponse> {\n    // TODO etag is not implemented yet.\n    const buffer = await this.read(url);\n    return { buffer: async () => buffer };\n  }\n\n  async readTree(\n    url: string,\n    options?: ReadTreeOptions,\n  ): Promise<ReadTreeResponse> {\n    // TODO: Support filepath based reading tree feature like other providers\n\n    // Get latest commit SHA\n\n    const commitsAzureResponse = await fetch(\n      getAzureCommitsUrl(url),\n      getAzureRequestOptions(this.integration.config),\n    );\n    if (!commitsAzureResponse.ok) {\n      const message = `Failed to read tree from ${url}, ${commitsAzureResponse.status} ${commitsAzureResponse.statusText}`;\n      if (commitsAzureResponse.status === 404) {\n        throw new NotFoundError(message);\n      }\n      throw new Error(message);\n    }\n\n    const commitSha = (await commitsAzureResponse.json()).value[0].commitId;\n    if (options?.etag && options.etag === commitSha) {\n      throw new NotModifiedError();\n    }\n\n    const archiveAzureResponse = await fetch(\n      getAzureDownloadUrl(url),\n      getAzureRequestOptions(this.integration.config, {\n        Accept: 'application/zip',\n      }),\n    );\n    if (!archiveAzureResponse.ok) {\n      const message = `Failed to read tree from ${url}, ${archiveAzureResponse.status} ${archiveAzureResponse.statusText}`;\n      if (archiveAzureResponse.status === 404) {\n        throw new NotFoundError(message);\n      }\n      throw new Error(message);\n    }\n\n    return await this.deps.treeResponseFactory.fromZipArchive({\n      stream: archiveAzureResponse.body as unknown as Readable,\n      etag: commitSha,\n      filter: options?.filter,\n    });\n  }\n\n  async search(url: string, options?: SearchOptions): Promise<SearchResponse> {\n    const { filepath } = parseGitUrl(url);\n    const matcher = new Minimatch(filepath);\n\n    // TODO(freben): For now, read the entire repo and filter through that. In\n    // a future improvement, we could be smart and try to deduce that non-glob\n    // prefixes (like for filepaths such as some-prefix/**/a.yaml) can be used\n    // to get just that part of the repo.\n    const treeUrl = new URL(url);\n    treeUrl.searchParams.delete('path');\n    treeUrl.pathname = treeUrl.pathname.replace(/\\/+$/, '');\n\n    const tree = await this.readTree(treeUrl.toString(), {\n      etag: options?.etag,\n      filter: path => matcher.match(stripFirstDirectoryFromPath(path)),\n    });\n    const files = await tree.files();\n\n    return {\n      etag: tree.etag,\n      files: files.map(file => ({\n        url: this.integration.resolveUrl({\n          url: `/${file.path}`,\n          base: url,\n        }),\n        content: file.content,\n      })),\n    };\n  }\n\n  toString() {\n    const { host, token } = this.integration.config;\n    return `azure{host=${host},authed=${Boolean(token)}}`;\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  BitbucketIntegration,\n  getBitbucketDefaultBranch,\n  getBitbucketDownloadUrl,\n  getBitbucketFileFetchUrl,\n  getBitbucketRequestOptions,\n  ScmIntegrations,\n} from '@backstage/integration';\nimport fetch from 'cross-fetch';\nimport parseGitUrl from 'git-url-parse';\nimport { Minimatch } from 'minimatch';\nimport { Readable } from 'stream';\nimport { NotFoundError, NotModifiedError } from '@backstage/errors';\nimport { stripFirstDirectoryFromPath } from './tree/util';\nimport {\n  ReadTreeResponseFactory,\n  ReaderFactory,\n  ReadTreeOptions,\n  ReadTreeResponse,\n  SearchOptions,\n  SearchResponse,\n  UrlReader,\n  ReadUrlResponse,\n  ReadUrlOptions,\n} from './types';\n\n/**\n * A processor that adds the ability to read files from Bitbucket v1 and v2 APIs, such as\n * the one exposed by Bitbucket Cloud itself.\n */\nexport class BitbucketUrlReader implements UrlReader {\n  static factory: ReaderFactory = ({ config, treeResponseFactory }) => {\n    const integrations = ScmIntegrations.fromConfig(config);\n    return integrations.bitbucket.list().map(integration => {\n      const reader = new BitbucketUrlReader(integration, {\n        treeResponseFactory,\n      });\n      const predicate = (url: URL) => url.host === integration.config.host;\n      return { reader, predicate };\n    });\n  };\n\n  constructor(\n    private readonly integration: BitbucketIntegration,\n    private readonly deps: { treeResponseFactory: ReadTreeResponseFactory },\n  ) {\n    const { host, apiBaseUrl, token, username, appPassword } =\n      integration.config;\n\n    if (!apiBaseUrl) {\n      throw new Error(\n        `Bitbucket integration for '${host}' must configure an explicit apiBaseUrl`,\n      );\n    } else if (!token && username && !appPassword) {\n      throw new Error(\n        `Bitbucket integration for '${host}' has configured a username but is missing a required appPassword.`,\n      );\n    }\n  }\n\n  async read(url: string): Promise<Buffer> {\n    const bitbucketUrl = getBitbucketFileFetchUrl(url, this.integration.config);\n    const options = getBitbucketRequestOptions(this.integration.config);\n\n    let response: Response;\n    try {\n      response = await fetch(bitbucketUrl.toString(), options);\n    } catch (e) {\n      throw new Error(`Unable to read ${url}, ${e}`);\n    }\n\n    if (response.ok) {\n      return Buffer.from(await response.arrayBuffer());\n    }\n\n    const message = `${url} could not be read as ${bitbucketUrl}, ${response.status} ${response.statusText}`;\n    if (response.status === 404) {\n      throw new NotFoundError(message);\n    }\n    throw new Error(message);\n  }\n\n  async readUrl(\n    url: string,\n    _options?: ReadUrlOptions,\n  ): Promise<ReadUrlResponse> {\n    // TODO etag is not implemented yet.\n    const buffer = await this.read(url);\n    return { buffer: async () => buffer };\n  }\n\n  async readTree(\n    url: string,\n    options?: ReadTreeOptions,\n  ): Promise<ReadTreeResponse> {\n    const { filepath } = parseGitUrl(url);\n\n    const lastCommitShortHash = await this.getLastCommitShortHash(url);\n    if (options?.etag && options.etag === lastCommitShortHash) {\n      throw new NotModifiedError();\n    }\n\n    const downloadUrl = await getBitbucketDownloadUrl(\n      url,\n      this.integration.config,\n    );\n    const archiveBitbucketResponse = await fetch(\n      downloadUrl,\n      getBitbucketRequestOptions(this.integration.config),\n    );\n    if (!archiveBitbucketResponse.ok) {\n      const message = `Failed to read tree from ${url}, ${archiveBitbucketResponse.status} ${archiveBitbucketResponse.statusText}`;\n      if (archiveBitbucketResponse.status === 404) {\n        throw new NotFoundError(message);\n      }\n      throw new Error(message);\n    }\n\n    return await this.deps.treeResponseFactory.fromTarArchive({\n      stream: archiveBitbucketResponse.body as unknown as Readable,\n      subpath: filepath,\n      etag: lastCommitShortHash,\n      filter: options?.filter,\n    });\n  }\n\n  async search(url: string, options?: SearchOptions): Promise<SearchResponse> {\n    const { filepath } = parseGitUrl(url);\n    const matcher = new Minimatch(filepath);\n\n    // TODO(freben): For now, read the entire repo and filter through that. In\n    // a future improvement, we could be smart and try to deduce that non-glob\n    // prefixes (like for filepaths such as some-prefix/**/a.yaml) can be used\n    // to get just that part of the repo.\n    const treeUrl = url.replace(filepath, '').replace(/\\/+$/, '');\n\n    const tree = await this.readTree(treeUrl, {\n      etag: options?.etag,\n      filter: path => matcher.match(stripFirstDirectoryFromPath(path)),\n    });\n    const files = await tree.files();\n\n    return {\n      etag: tree.etag,\n      files: files.map(file => ({\n        url: this.integration.resolveUrl({\n          url: `/${file.path}`,\n          base: url,\n        }),\n        content: file.content,\n      })),\n    };\n  }\n\n  toString() {\n    const { host, token, username, appPassword } = this.integration.config;\n    let authed = Boolean(token);\n    if (!authed) {\n      authed = Boolean(username && appPassword);\n    }\n    return `bitbucket{host=${host},authed=${authed}}`;\n  }\n\n  private async getLastCommitShortHash(url: string): Promise<string> {\n    const { resource, name: repoName, owner: project, ref } = parseGitUrl(url);\n\n    let branch = ref;\n    if (!branch) {\n      branch = await getBitbucketDefaultBranch(url, this.integration.config);\n    }\n\n    const isHosted = resource === 'bitbucket.org';\n    // Bitbucket Server https://docs.atlassian.com/bitbucket-server/rest/7.9.0/bitbucket-rest.html#idp222\n    const commitsApiUrl = isHosted\n      ? `${this.integration.config.apiBaseUrl}/repositories/${project}/${repoName}/commits/${branch}`\n      : `${this.integration.config.apiBaseUrl}/projects/${project}/repos/${repoName}/commits`;\n\n    const commitsResponse = await fetch(\n      commitsApiUrl,\n      getBitbucketRequestOptions(this.integration.config),\n    );\n    if (!commitsResponse.ok) {\n      const message = `Failed to retrieve commits from ${commitsApiUrl}, ${commitsResponse.status} ${commitsResponse.statusText}`;\n      if (commitsResponse.status === 404) {\n        throw new NotFoundError(message);\n      }\n      throw new Error(message);\n    }\n\n    const commits = await commitsResponse.json();\n    if (isHosted) {\n      if (\n        commits &&\n        commits.values &&\n        commits.values.length > 0 &&\n        commits.values[0].hash\n      ) {\n        return commits.values[0].hash.substring(0, 12);\n      }\n    } else {\n      if (\n        commits &&\n        commits.values &&\n        commits.values.length > 0 &&\n        commits.values[0].id\n      ) {\n        return commits.values[0].id.substring(0, 12);\n      }\n    }\n\n    throw new Error(`Failed to read response from ${commitsApiUrl}`);\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGitHubFileFetchUrl,\n  GithubCredentialsProvider,\n  GitHubIntegration,\n  ScmIntegrations,\n} from '@backstage/integration';\nimport { RestEndpointMethodTypes } from '@octokit/rest';\nimport fetch from 'cross-fetch';\nimport parseGitUrl from 'git-url-parse';\nimport { Minimatch } from 'minimatch';\nimport { Readable } from 'stream';\nimport { NotFoundError, NotModifiedError } from '@backstage/errors';\nimport {\n  ReadTreeResponseFactory,\n  ReaderFactory,\n  ReadTreeOptions,\n  ReadTreeResponse,\n  SearchOptions,\n  SearchResponse,\n  SearchResponseFile,\n  UrlReader,\n  ReadUrlOptions,\n  ReadUrlResponse,\n} from './types';\n\nexport type GhRepoResponse =\n  RestEndpointMethodTypes['repos']['get']['response']['data'];\nexport type GhBranchResponse =\n  RestEndpointMethodTypes['repos']['getBranch']['response']['data'];\nexport type GhTreeResponse =\n  RestEndpointMethodTypes['git']['getTree']['response']['data'];\nexport type GhBlobResponse =\n  RestEndpointMethodTypes['git']['getBlob']['response']['data'];\n\n/**\n * A processor that adds the ability to read files from GitHub v3 APIs, such as\n * the one exposed by GitHub itself.\n */\nexport class GithubUrlReader implements UrlReader {\n  static factory: ReaderFactory = ({ config, treeResponseFactory }) => {\n    const integrations = ScmIntegrations.fromConfig(config);\n    return integrations.github.list().map(integration => {\n      const credentialsProvider = GithubCredentialsProvider.create(\n        integration.config,\n      );\n      const reader = new GithubUrlReader(integration, {\n        treeResponseFactory,\n        credentialsProvider,\n      });\n      const predicate = (url: URL) => url.host === integration.config.host;\n      return { reader, predicate };\n    });\n  };\n\n  constructor(\n    private readonly integration: GitHubIntegration,\n    private readonly deps: {\n      treeResponseFactory: ReadTreeResponseFactory;\n      credentialsProvider: GithubCredentialsProvider;\n    },\n  ) {\n    if (!integration.config.apiBaseUrl && !integration.config.rawBaseUrl) {\n      throw new Error(\n        `GitHub integration '${integration.title}' must configure an explicit apiBaseUrl or rawBaseUrl`,\n      );\n    }\n  }\n\n  async read(url: string): Promise<Buffer> {\n    const response = await this.readUrl(url);\n    return response.buffer();\n  }\n\n  async readUrl(\n    url: string,\n    options?: ReadUrlOptions,\n  ): Promise<ReadUrlResponse> {\n    const credentials = await this.deps.credentialsProvider.getCredentials({\n      url,\n    });\n    const ghUrl = getGitHubFileFetchUrl(\n      url,\n      this.integration.config,\n      credentials,\n    );\n\n    let response: Response;\n    try {\n      response = await fetch(ghUrl, {\n        headers: {\n          ...credentials?.headers,\n          ...(options?.etag && { 'If-None-Match': options.etag }),\n          Accept: 'application/vnd.github.v3.raw',\n        },\n      });\n    } catch (e) {\n      throw new Error(`Unable to read ${url}, ${e}`);\n    }\n\n    if (response.status === 304) {\n      throw new NotModifiedError();\n    }\n\n    if (response.ok) {\n      return {\n        buffer: async () => Buffer.from(await response.arrayBuffer()),\n        etag: response.headers.get('ETag') ?? undefined,\n      };\n    }\n\n    const message = `${url} could not be read as ${ghUrl}, ${response.status} ${response.statusText}`;\n    if (response.status === 404) {\n      throw new NotFoundError(message);\n    }\n    throw new Error(message);\n  }\n\n  async readTree(\n    url: string,\n    options?: ReadTreeOptions,\n  ): Promise<ReadTreeResponse> {\n    const repoDetails = await this.getRepoDetails(url);\n    const commitSha = repoDetails.branch.commit.sha!;\n\n    if (options?.etag && options.etag === commitSha) {\n      throw new NotModifiedError();\n    }\n\n    const { filepath } = parseGitUrl(url);\n    const { headers } = await this.deps.credentialsProvider.getCredentials({\n      url,\n    });\n\n    return this.doReadTree(\n      repoDetails.repo.archive_url,\n      commitSha,\n      filepath,\n      { headers },\n      options,\n    );\n  }\n\n  async search(url: string, options?: SearchOptions): Promise<SearchResponse> {\n    const repoDetails = await this.getRepoDetails(url);\n    const commitSha = repoDetails.branch.commit.sha!;\n\n    if (options?.etag && options.etag === commitSha) {\n      throw new NotModifiedError();\n    }\n\n    const { filepath } = parseGitUrl(url);\n    const { headers } = await this.deps.credentialsProvider.getCredentials({\n      url,\n    });\n\n    const files = await this.doSearch(\n      url,\n      repoDetails.repo.trees_url,\n      repoDetails.repo.archive_url,\n      commitSha,\n      filepath,\n      { headers },\n    );\n\n    return { files, etag: commitSha };\n  }\n\n  toString() {\n    const { host, token } = this.integration.config;\n    return `github{host=${host},authed=${Boolean(token)}}`;\n  }\n\n  private async doReadTree(\n    archiveUrl: string,\n    sha: string,\n    subpath: string,\n    init: RequestInit,\n    options?: ReadTreeOptions,\n  ): Promise<ReadTreeResponse> {\n    // archive_url looks like \"https://api.github.com/repos/owner/repo/{archive_format}{/ref}\"\n    const archive = await this.fetchResponse(\n      archiveUrl\n        .replace('{archive_format}', 'tarball')\n        .replace('{/ref}', `/${sha}`),\n      init,\n    );\n\n    return await this.deps.treeResponseFactory.fromTarArchive({\n      // TODO(Rugvip): Underlying implementation of fetch will be node-fetch, we probably want\n      //               to stick to using that in exclusively backend code.\n      stream: archive.body as unknown as Readable,\n      subpath,\n      etag: sha,\n      filter: options?.filter,\n    });\n  }\n\n  private async doSearch(\n    url: string,\n    treesUrl: string,\n    archiveUrl: string,\n    sha: string,\n    query: string,\n    init: RequestInit,\n  ): Promise<SearchResponseFile[]> {\n    function pathToUrl(path: string): string {\n      // TODO(freben): Use the integration package facility for this instead\n      // pathname starts as /backstage/backstage/blob/master/<path>\n      const updated = new URL(url);\n      const base = updated.pathname.split('/').slice(1, 5).join('/');\n      updated.pathname = `${base}/${path}`;\n      return updated.toString();\n    }\n\n    const matcher = new Minimatch(query.replace(/^\\/+/, ''));\n\n    // trees_url looks like \"https://api.github.com/repos/octocat/Hello-World/git/trees{/sha}\"\n    const recursiveTree: GhTreeResponse = await this.fetchJson(\n      treesUrl.replace('{/sha}', `/${sha}?recursive=true`),\n      init,\n    );\n\n    // The simple case is that we got the entire tree in a single operation.\n    if (!recursiveTree.truncated) {\n      const matching = recursiveTree.tree.filter(\n        item =>\n          item.type === 'blob' &&\n          item.path &&\n          item.url &&\n          matcher.match(item.path),\n      );\n\n      return matching.map(item => ({\n        url: pathToUrl(item.path!),\n        content: async () => {\n          const blob: GhBlobResponse = await this.fetchJson(item.url!, init);\n          return Buffer.from(blob.content, 'base64');\n        },\n      }));\n    }\n\n    // For larger repos, we leverage readTree and filter through that instead\n    const tree = await this.doReadTree(archiveUrl, sha, '', init, {\n      filter: path => matcher.match(path),\n    });\n    const files = await tree.files();\n\n    return files.map(file => ({\n      url: pathToUrl(file.path),\n      content: file.content,\n    }));\n  }\n\n  private async getRepoDetails(url: string): Promise<{\n    repo: GhRepoResponse;\n    branch: GhBranchResponse;\n  }> {\n    const parsed = parseGitUrl(url);\n    const { ref, full_name } = parsed;\n\n    // Caveat: The ref will totally be incorrect if the branch name includes a\n    // slash. Thus, some operations can not work on URLs containing branch\n    // names that have a slash in them.\n\n    const { headers } = await this.deps.credentialsProvider.getCredentials({\n      url,\n    });\n\n    const repo: GhRepoResponse = await this.fetchJson(\n      `${this.integration.config.apiBaseUrl}/repos/${full_name}`,\n      { headers },\n    );\n\n    // branches_url looks like \"https://api.github.com/repos/owner/repo/branches{/branch}\"\n    const branch: GhBranchResponse = await this.fetchJson(\n      repo.branches_url.replace('{/branch}', `/${ref || repo.default_branch}`),\n      { headers },\n    );\n\n    return { repo, branch };\n  }\n\n  private async fetchResponse(\n    url: string | URL,\n    init: RequestInit,\n  ): Promise<Response> {\n    const urlAsString = url.toString();\n\n    const response = await fetch(urlAsString, init);\n\n    if (!response.ok) {\n      const message = `Request failed for ${urlAsString}, ${response.status} ${response.statusText}`;\n      if (response.status === 404) {\n        throw new NotFoundError(message);\n      }\n      throw new Error(message);\n    }\n\n    return response;\n  }\n\n  private async fetchJson(url: string | URL, init: RequestInit): Promise<any> {\n    const response = await this.fetchResponse(url, init);\n    return await response.json();\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGitLabFileFetchUrl,\n  getGitLabRequestOptions,\n  GitLabIntegration,\n  ScmIntegrations,\n} from '@backstage/integration';\nimport fetch from 'cross-fetch';\nimport parseGitUrl from 'git-url-parse';\nimport { Minimatch } from 'minimatch';\nimport { Readable } from 'stream';\nimport { NotFoundError, NotModifiedError } from '@backstage/errors';\nimport { stripFirstDirectoryFromPath } from './tree/util';\nimport {\n  ReadTreeResponseFactory,\n  ReaderFactory,\n  ReadTreeOptions,\n  ReadTreeResponse,\n  SearchOptions,\n  SearchResponse,\n  UrlReader,\n  ReadUrlResponse,\n  ReadUrlOptions,\n} from './types';\n\nexport class GitlabUrlReader implements UrlReader {\n  static factory: ReaderFactory = ({ config, treeResponseFactory }) => {\n    const integrations = ScmIntegrations.fromConfig(config);\n    return integrations.gitlab.list().map(integration => {\n      const reader = new GitlabUrlReader(integration, {\n        treeResponseFactory,\n      });\n      const predicate = (url: URL) => url.host === integration.config.host;\n      return { reader, predicate };\n    });\n  };\n\n  constructor(\n    private readonly integration: GitLabIntegration,\n    private readonly deps: { treeResponseFactory: ReadTreeResponseFactory },\n  ) {}\n\n  async read(url: string): Promise<Buffer> {\n    const response = await this.readUrl(url);\n    return response.buffer();\n  }\n\n  async readUrl(\n    url: string,\n    options?: ReadUrlOptions,\n  ): Promise<ReadUrlResponse> {\n    const builtUrl = await getGitLabFileFetchUrl(url, this.integration.config);\n\n    let response: Response;\n    try {\n      response = await fetch(builtUrl, {\n        headers: {\n          ...getGitLabRequestOptions(this.integration.config).headers,\n          ...(options?.etag && { 'If-None-Match': options.etag }),\n        },\n      });\n    } catch (e) {\n      throw new Error(`Unable to read ${url}, ${e}`);\n    }\n\n    if (response.status === 304) {\n      throw new NotModifiedError();\n    }\n\n    if (response.ok) {\n      return {\n        buffer: async () => Buffer.from(await response.arrayBuffer()),\n        etag: response.headers.get('ETag') ?? undefined,\n      };\n    }\n\n    const message = `${url} could not be read as ${builtUrl}, ${response.status} ${response.statusText}`;\n    if (response.status === 404) {\n      throw new NotFoundError(message);\n    }\n    throw new Error(message);\n  }\n\n  async readTree(\n    url: string,\n    options?: ReadTreeOptions,\n  ): Promise<ReadTreeResponse> {\n    const { ref, full_name, filepath } = parseGitUrl(url);\n\n    // Use GitLab API to get the default branch\n    // encodeURIComponent is required for GitLab API\n    // https://docs.gitlab.com/ee/api/README.html#namespaced-path-encoding\n    const projectGitlabResponse = await fetch(\n      new URL(\n        `${this.integration.config.apiBaseUrl}/projects/${encodeURIComponent(\n          full_name,\n        )}`,\n      ).toString(),\n      getGitLabRequestOptions(this.integration.config),\n    );\n    if (!projectGitlabResponse.ok) {\n      const msg = `Failed to read tree from ${url}, ${projectGitlabResponse.status} ${projectGitlabResponse.statusText}`;\n      if (projectGitlabResponse.status === 404) {\n        throw new NotFoundError(msg);\n      }\n      throw new Error(msg);\n    }\n    const projectGitlabResponseJson = await projectGitlabResponse.json();\n\n    // ref is an empty string if no branch is set in provided url to readTree.\n    const branch = ref || projectGitlabResponseJson.default_branch;\n\n    // Fetch the latest commit that modifies the the filepath in the provided or default branch\n    // to compare against the provided sha.\n    const commitsReqParams = new URLSearchParams();\n    commitsReqParams.set('ref_name', branch);\n    if (!!filepath) {\n      commitsReqParams.set('path', filepath);\n    }\n    const commitsGitlabResponse = await fetch(\n      new URL(\n        `${this.integration.config.apiBaseUrl}/projects/${encodeURIComponent(\n          full_name,\n        )}/repository/commits?${commitsReqParams.toString()}`,\n      ).toString(),\n      getGitLabRequestOptions(this.integration.config),\n    );\n    if (!commitsGitlabResponse.ok) {\n      const message = `Failed to read tree (branch) from ${url}, ${commitsGitlabResponse.status} ${commitsGitlabResponse.statusText}`;\n      if (commitsGitlabResponse.status === 404) {\n        throw new NotFoundError(message);\n      }\n      throw new Error(message);\n    }\n\n    const commitSha = (await commitsGitlabResponse.json())[0].id;\n\n    if (options?.etag && options.etag === commitSha) {\n      throw new NotModifiedError();\n    }\n\n    // https://docs.gitlab.com/ee/api/repositories.html#get-file-archive\n    const archiveGitLabResponse = await fetch(\n      `${this.integration.config.apiBaseUrl}/projects/${encodeURIComponent(\n        full_name,\n      )}/repository/archive?sha=${branch}`,\n      getGitLabRequestOptions(this.integration.config),\n    );\n    if (!archiveGitLabResponse.ok) {\n      const message = `Failed to read tree (archive) from ${url}, ${archiveGitLabResponse.status} ${archiveGitLabResponse.statusText}`;\n      if (archiveGitLabResponse.status === 404) {\n        throw new NotFoundError(message);\n      }\n      throw new Error(message);\n    }\n\n    return await this.deps.treeResponseFactory.fromTarArchive({\n      stream: archiveGitLabResponse.body as unknown as Readable,\n      subpath: filepath,\n      etag: commitSha,\n      filter: options?.filter,\n    });\n  }\n\n  async search(url: string, options?: SearchOptions): Promise<SearchResponse> {\n    const { filepath } = parseGitUrl(url);\n    const matcher = new Minimatch(filepath);\n\n    // TODO(freben): For now, read the entire repo and filter through that. In\n    // a future improvement, we could be smart and try to deduce that non-glob\n    // prefixes (like for filepaths such as some-prefix/**/a.yaml) can be used\n    // to get just that part of the repo.\n    const treeUrl = url.replace(filepath, '').replace(/\\/+$/, '');\n\n    const tree = await this.readTree(treeUrl, {\n      etag: options?.etag,\n      filter: path => matcher.match(stripFirstDirectoryFromPath(path)),\n    });\n    const files = await tree.files();\n\n    return {\n      etag: tree.etag,\n      files: files.map(file => ({\n        url: this.integration.resolveUrl({ url: `/${file.path}`, base: url }),\n        content: file.content,\n      })),\n    };\n  }\n\n  toString() {\n    const { host, token } = this.integration.config;\n    return `gitlab{host=${host},authed=${Boolean(token)}}`;\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NotAllowedError } from '@backstage/errors';\nimport { Logger } from 'winston';\nimport {\n  ReadTreeOptions,\n  ReadTreeResponse,\n  ReadUrlOptions,\n  ReadUrlResponse,\n  SearchOptions,\n  SearchResponse,\n  UrlReader,\n  UrlReaderPredicateTuple,\n} from './types';\n\nconst MIN_WARNING_INTERVAL_MS = 1000 * 60 * 15;\n\n/**\n * A UrlReader implementation that selects from a set of UrlReaders\n * based on a predicate tied to each reader.\n */\nexport class UrlReaderPredicateMux implements UrlReader {\n  private readonly readers: UrlReaderPredicateTuple[] = [];\n  private readonly readerWarnings: Map<UrlReader, number> = new Map();\n\n  constructor(private readonly logger: Logger) {}\n\n  register(tuple: UrlReaderPredicateTuple): void {\n    this.readers.push(tuple);\n  }\n\n  async read(url: string): Promise<Buffer> {\n    const parsed = new URL(url);\n\n    for (const { predicate, reader } of this.readers) {\n      if (predicate(parsed)) {\n        return reader.read(url);\n      }\n    }\n\n    throw new NotAllowedError(\n      `Reading from '${url}' is not allowed. ` +\n        `You may need to configure an integration for the target host, or add it ` +\n        `to the configured list of allowed hosts at 'backend.reading.allow'`,\n    );\n  }\n\n  async readUrl(\n    url: string,\n    options?: ReadUrlOptions,\n  ): Promise<ReadUrlResponse> {\n    const parsed = new URL(url);\n\n    for (const { predicate, reader } of this.readers) {\n      if (predicate(parsed)) {\n        if (reader.readUrl) {\n          return reader.readUrl(url, options);\n        }\n        const now = Date.now();\n        const lastWarned = this.readerWarnings.get(reader) ?? 0;\n        if (now > lastWarned + MIN_WARNING_INTERVAL_MS) {\n          this.readerWarnings.set(reader, now);\n          this.logger.warn(\n            `No implementation of readUrl found for ${reader}, this method will be required in the ` +\n              `future and will replace the 'read' method. See the changelog for more details here: ` +\n              'https://github.com/backstage/backstage/blob/master/packages/backend-common/CHANGELOG.md#085',\n          );\n        }\n        const buffer = await reader.read(url);\n        return {\n          buffer: async () => buffer,\n        };\n      }\n    }\n\n    throw new NotAllowedError(`Reading from '${url}' is not allowed`);\n  }\n\n  async readTree(\n    url: string,\n    options?: ReadTreeOptions,\n  ): Promise<ReadTreeResponse> {\n    const parsed = new URL(url);\n\n    for (const { predicate, reader } of this.readers) {\n      if (predicate(parsed)) {\n        return await reader.readTree(url, options);\n      }\n    }\n\n    throw new NotAllowedError(`Reading from '${url}' is not allowed`);\n  }\n\n  async search(url: string, options?: SearchOptions): Promise<SearchResponse> {\n    const parsed = new URL(url);\n\n    for (const { predicate, reader } of this.readers) {\n      if (predicate(parsed)) {\n        return await reader.search(url, options);\n      }\n    }\n\n    throw new NotAllowedError(`Reading from '${url}' is not allowed`);\n  }\n\n  toString() {\n    return `predicateMux{readers=${this.readers.map(t => t.reader).join(',')}`;\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport concatStream from 'concat-stream';\nimport fs from 'fs-extra';\nimport platformPath from 'path';\nimport { pipeline as pipelineCb, Readable } from 'stream';\nimport tar, { Parse, ParseStream, ReadEntry } from 'tar';\nimport { promisify } from 'util';\nimport {\n  ReadTreeResponse,\n  ReadTreeResponseDirOptions,\n  ReadTreeResponseFile,\n} from '../types';\nimport { stripFirstDirectoryFromPath } from './util';\n\n// Tar types for `Parse` is not a proper constructor, but it should be\nconst TarParseStream = Parse as unknown as { new (): ParseStream };\n\nconst pipeline = promisify(pipelineCb);\n\n/**\n * Wraps a tar archive stream into a tree response reader.\n */\nexport class TarArchiveResponse implements ReadTreeResponse {\n  private read = false;\n\n  constructor(\n    private readonly stream: Readable,\n    private readonly subPath: string,\n    private readonly workDir: string,\n    public readonly etag: string,\n    private readonly filter?: (path: string, info: { size: number }) => boolean,\n  ) {\n    if (subPath) {\n      if (!subPath.endsWith('/')) {\n        this.subPath += '/';\n      }\n      if (subPath.startsWith('/')) {\n        throw new TypeError(\n          `TarArchiveResponse subPath must not start with a /, got '${subPath}'`,\n        );\n      }\n    }\n\n    this.etag = etag;\n  }\n\n  // Make sure the input stream is only read once\n  private onlyOnce() {\n    if (this.read) {\n      throw new Error('Response has already been read');\n    }\n    this.read = true;\n  }\n\n  async files(): Promise<ReadTreeResponseFile[]> {\n    this.onlyOnce();\n\n    const files = Array<ReadTreeResponseFile>();\n    const parser = new TarParseStream();\n\n    parser.on('entry', (entry: ReadEntry & Readable) => {\n      if (entry.type === 'Directory') {\n        entry.resume();\n        return;\n      }\n\n      // File path relative to the root extracted directory. Will remove the\n      // top level dir name from the path since its name is hard to predetermine.\n      const relativePath = stripFirstDirectoryFromPath(entry.path);\n\n      if (this.subPath) {\n        if (!relativePath.startsWith(this.subPath)) {\n          entry.resume();\n          return;\n        }\n      }\n\n      const path = relativePath.slice(this.subPath.length);\n      if (this.filter) {\n        if (!this.filter(path, { size: entry.remain })) {\n          entry.resume();\n          return;\n        }\n      }\n\n      const content = new Promise<Buffer>(async resolve => {\n        await pipeline(entry, concatStream(resolve));\n      });\n\n      files.push({\n        path,\n        content: () => content,\n      });\n\n      entry.resume();\n    });\n\n    await pipeline(this.stream, parser);\n\n    return files;\n  }\n\n  async archive(): Promise<Readable> {\n    if (!this.subPath) {\n      this.onlyOnce();\n\n      return this.stream;\n    }\n\n    // TODO(Rugvip): method for repacking a tar with a subpath is to simply extract into a\n    //               tmp dir and recreate the archive. Would be nicer to stream things instead.\n    const tmpDir = await this.dir();\n\n    try {\n      const data = await new Promise<Buffer>(async resolve => {\n        await pipeline(\n          tar.create({ cwd: tmpDir }, ['']),\n          concatStream(resolve),\n        );\n      });\n      return Readable.from(data);\n    } finally {\n      await fs.remove(tmpDir);\n    }\n  }\n\n  async dir(options?: ReadTreeResponseDirOptions): Promise<string> {\n    this.onlyOnce();\n\n    const dir =\n      options?.targetDir ??\n      (await fs.mkdtemp(platformPath.join(this.workDir, 'backstage-')));\n\n    // Equivalent of tar --strip-components=N\n    // When no subPath is given, remove just 1 top level directory\n    const strip = this.subPath ? this.subPath.split('/').length : 1;\n\n    await pipeline(\n      this.stream,\n      tar.extract({\n        strip,\n        cwd: dir,\n        filter: (path, stat) => {\n          // File path relative to the root extracted directory. Will remove the\n          // top level dir name from the path since its name is hard to predetermine.\n          const relativePath = stripFirstDirectoryFromPath(path);\n          if (this.subPath && !relativePath.startsWith(this.subPath)) {\n            return false;\n          }\n          if (this.filter) {\n            const innerPath = path.split('/').slice(strip).join('/');\n            return this.filter(innerPath, { size: stat.size });\n          }\n          return true;\n        },\n      }),\n    );\n\n    return dir;\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport archiver from 'archiver';\nimport fs from 'fs-extra';\nimport platformPath from 'path';\nimport { Readable } from 'stream';\nimport unzipper, { Entry } from 'unzipper';\nimport {\n  ReadTreeResponse,\n  ReadTreeResponseDirOptions,\n  ReadTreeResponseFile,\n} from '../types';\nimport { stripFirstDirectoryFromPath } from './util';\n\n/**\n * Wraps a zip archive stream into a tree response reader.\n */\nexport class ZipArchiveResponse implements ReadTreeResponse {\n  private read = false;\n\n  constructor(\n    private readonly stream: Readable,\n    private readonly subPath: string,\n    private readonly workDir: string,\n    public readonly etag: string,\n    private readonly filter?: (path: string, info: { size: number }) => boolean,\n  ) {\n    if (subPath) {\n      if (!subPath.endsWith('/')) {\n        this.subPath += '/';\n      }\n      if (subPath.startsWith('/')) {\n        throw new TypeError(\n          `ZipArchiveResponse subPath must not start with a /, got '${subPath}'`,\n        );\n      }\n    }\n\n    this.etag = etag;\n  }\n\n  // Make sure the input stream is only read once\n  private onlyOnce() {\n    if (this.read) {\n      throw new Error('Response has already been read');\n    }\n    this.read = true;\n  }\n\n  // File path relative to the root extracted directory or a sub directory if subpath is set.\n  private getInnerPath(path: string): string {\n    return path.slice(this.subPath.length);\n  }\n\n  private shouldBeIncluded(entry: Entry): boolean {\n    const strippedPath = stripFirstDirectoryFromPath(entry.path);\n\n    if (this.subPath) {\n      if (!strippedPath.startsWith(this.subPath)) {\n        return false;\n      }\n    }\n    if (this.filter) {\n      return this.filter(this.getInnerPath(entry.path), {\n        size:\n          (entry.vars as { uncompressedSize?: number }).uncompressedSize ??\n          entry.vars.compressedSize,\n      });\n    }\n    return true;\n  }\n\n  async files(): Promise<ReadTreeResponseFile[]> {\n    this.onlyOnce();\n\n    const files = Array<ReadTreeResponseFile>();\n\n    await this.stream\n      .pipe(unzipper.Parse())\n      .on('entry', (entry: Entry) => {\n        if (entry.type === 'Directory') {\n          entry.resume();\n          return;\n        }\n\n        if (this.shouldBeIncluded(entry)) {\n          files.push({\n            path: this.getInnerPath(stripFirstDirectoryFromPath(entry.path)),\n            content: () => entry.buffer(),\n          });\n        } else {\n          entry.autodrain();\n        }\n      })\n      .promise();\n\n    return files;\n  }\n\n  async archive(): Promise<Readable> {\n    this.onlyOnce();\n\n    if (!this.subPath) {\n      return this.stream;\n    }\n\n    const archive = archiver('zip');\n    await this.stream\n      .pipe(unzipper.Parse())\n      .on('entry', (entry: Entry) => {\n        if (entry.type === 'File' && this.shouldBeIncluded(entry)) {\n          archive.append(entry, { name: this.getInnerPath(entry.path) });\n        } else {\n          entry.autodrain();\n        }\n      })\n      .promise();\n    archive.finalize();\n\n    return archive;\n  }\n\n  async dir(options?: ReadTreeResponseDirOptions): Promise<string> {\n    this.onlyOnce();\n\n    const dir =\n      options?.targetDir ??\n      (await fs.mkdtemp(platformPath.join(this.workDir, 'backstage-')));\n\n    await this.stream\n      .pipe(unzipper.Parse())\n      .on('entry', async (entry: Entry) => {\n        // Ignore directory entries since we handle that with the file entries\n        // as a zip can have files with directories without directory entries\n        if (entry.type === 'File' && this.shouldBeIncluded(entry)) {\n          const entryPath = this.getInnerPath(\n            stripFirstDirectoryFromPath(entry.path),\n          );\n          const dirname = platformPath.dirname(entryPath);\n          if (dirname) {\n            await fs.mkdirp(platformPath.join(dir, dirname));\n          }\n          entry.pipe(fs.createWriteStream(platformPath.join(dir, entryPath)));\n        } else {\n          entry.autodrain();\n        }\n      })\n      .promise();\n\n    return dir;\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport os from 'os';\nimport { Config } from '@backstage/config';\nimport {\n  ReadTreeResponse,\n  FromArchiveOptions,\n  ReadTreeResponseFactory,\n} from '../types';\nimport { TarArchiveResponse } from './TarArchiveResponse';\nimport { ZipArchiveResponse } from './ZipArchiveResponse';\n\nexport class DefaultReadTreeResponseFactory implements ReadTreeResponseFactory {\n  static create(options: { config: Config }): DefaultReadTreeResponseFactory {\n    return new DefaultReadTreeResponseFactory(\n      options.config.getOptionalString('backend.workingDirectory') ??\n        os.tmpdir(),\n    );\n  }\n\n  constructor(private readonly workDir: string) {}\n\n  async fromTarArchive(options: FromArchiveOptions): Promise<ReadTreeResponse> {\n    return new TarArchiveResponse(\n      options.stream,\n      options.subpath ?? '',\n      this.workDir,\n      options.etag,\n      options.filter,\n    );\n  }\n\n  async fromZipArchive(options: FromArchiveOptions): Promise<ReadTreeResponse> {\n    return new ZipArchiveResponse(\n      options.stream,\n      options.subpath ?? '',\n      this.workDir,\n      options.etag,\n      options.filter,\n    );\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NotFoundError, NotModifiedError } from '@backstage/errors';\nimport fetch from 'cross-fetch';\nimport {\n  ReaderFactory,\n  ReadTreeResponse,\n  ReadUrlOptions,\n  ReadUrlResponse,\n  SearchResponse,\n  UrlReader,\n} from './types';\n\n/**\n * A UrlReader that does a plain fetch of the URL.\n */\nexport class FetchUrlReader implements UrlReader {\n  /**\n   * The factory creates a single reader that will be used for reading any URL that's listed\n   * in configuration at `backend.reading.allow`. The allow list contains a list of objects describing\n   * targets to allow, containing the following fields:\n   *\n   * `host`:\n   *   Either full hostnames to match, or subdomain wildcard matchers with a leading `*`.\n   *   For example `example.com` and `*.example.com` are valid values, `prod.*.example.com` is not.\n   */\n  static factory: ReaderFactory = ({ config }) => {\n    const predicates =\n      config\n        .getOptionalConfigArray('backend.reading.allow')\n        ?.map(allowConfig => {\n          const host = allowConfig.getString('host');\n          if (host.startsWith('*.')) {\n            const suffix = host.slice(1);\n            return (url: URL) => url.host.endsWith(suffix);\n          }\n          return (url: URL) => url.host === host;\n        }) ?? [];\n\n    const reader = new FetchUrlReader();\n    const predicate = (url: URL) => predicates.some(p => p(url));\n    return [{ reader, predicate }];\n  };\n\n  async read(url: string): Promise<Buffer> {\n    const response = await this.readUrl(url);\n    return response.buffer();\n  }\n\n  async readUrl(\n    url: string,\n    options?: ReadUrlOptions,\n  ): Promise<ReadUrlResponse> {\n    let response: Response;\n    try {\n      response = await fetch(url, {\n        headers: {\n          ...(options?.etag && { 'If-None-Match': options.etag }),\n        },\n      });\n    } catch (e) {\n      throw new Error(`Unable to read ${url}, ${e}`);\n    }\n\n    if (response.status === 304) {\n      throw new NotModifiedError();\n    }\n\n    if (response.ok) {\n      return {\n        buffer: async () => Buffer.from(await response.arrayBuffer()),\n        etag: response.headers.get('ETag') ?? undefined,\n      };\n    }\n\n    const message = `could not read ${url}, ${response.status} ${response.statusText}`;\n    if (response.status === 404) {\n      throw new NotFoundError(message);\n    }\n    throw new Error(message);\n  }\n\n  async readTree(): Promise<ReadTreeResponse> {\n    throw new Error('FetchUrlReader does not implement readTree');\n  }\n\n  async search(): Promise<SearchResponse> {\n    throw new Error('FetchUrlReader does not implement search');\n  }\n\n  toString() {\n    return 'fetch{}';\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Storage } from '@google-cloud/storage';\nimport {\n  ReaderFactory,\n  ReadTreeResponse,\n  ReadUrlOptions,\n  ReadUrlResponse,\n  SearchResponse,\n  UrlReader,\n} from './types';\nimport getRawBody from 'raw-body';\nimport {\n  GoogleGcsIntegrationConfig,\n  readGoogleGcsIntegrationConfig,\n} from '@backstage/integration';\n\nconst GOOGLE_GCS_HOST = 'storage.cloud.google.com';\n\nconst parseURL = (\n  url: string,\n): { host: string; bucket: string; key: string } => {\n  const { host, pathname } = new URL(url);\n\n  if (host !== GOOGLE_GCS_HOST) {\n    throw new Error(`not a valid GCS URL: ${url}`);\n  }\n\n  const [, bucket, ...key] = pathname.split('/');\n  return {\n    host: host,\n    bucket,\n    key: key.join('/'),\n  };\n};\n\nexport class GoogleGcsUrlReader implements UrlReader {\n  static factory: ReaderFactory = ({ config, logger }) => {\n    if (!config.has('integrations.googleGcs')) {\n      return [];\n    }\n    const gcsConfig = readGoogleGcsIntegrationConfig(\n      config.getConfig('integrations.googleGcs'),\n    );\n    let storage: Storage;\n    if (!gcsConfig.clientEmail || !gcsConfig.privateKey) {\n      logger.info(\n        'googleGcs credentials not found in config. Using default credentials provider.',\n      );\n      storage = new Storage();\n    } else {\n      storage = new Storage({\n        credentials: {\n          client_email: gcsConfig.clientEmail || undefined,\n          private_key: gcsConfig.privateKey || undefined,\n        },\n      });\n    }\n    const reader = new GoogleGcsUrlReader(gcsConfig, storage);\n    const predicate = (url: URL) => url.host === GOOGLE_GCS_HOST;\n    return [{ reader, predicate }];\n  };\n\n  constructor(\n    private readonly integration: GoogleGcsIntegrationConfig,\n    private readonly storage: Storage,\n  ) {}\n\n  async read(url: string): Promise<Buffer> {\n    try {\n      const { bucket, key } = parseURL(url);\n\n      return await getRawBody(\n        this.storage.bucket(bucket).file(key).createReadStream(),\n      );\n    } catch (error) {\n      throw new Error(`unable to read gcs file from ${url}, ${error}`);\n    }\n  }\n\n  async readUrl(\n    url: string,\n    _options?: ReadUrlOptions,\n  ): Promise<ReadUrlResponse> {\n    // TODO etag is not implemented yet.\n    const buffer = await this.read(url);\n    return { buffer: async () => buffer };\n  }\n\n  async readTree(): Promise<ReadTreeResponse> {\n    throw new Error('GcsUrlReader does not implement readTree');\n  }\n\n  async search(): Promise<SearchResponse> {\n    throw new Error('GcsUrlReader does not implement search');\n  }\n\n  toString() {\n    const key = this.integration.privateKey;\n    return `googleGcs{host=${GOOGLE_GCS_HOST},authed=${Boolean(key)}}`;\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport aws, { Credentials, S3 } from 'aws-sdk';\nimport { CredentialsOptions } from 'aws-sdk/lib/credentials';\nimport {\n  ReaderFactory,\n  ReadTreeResponse,\n  ReadUrlOptions,\n  ReadUrlResponse,\n  SearchResponse,\n  UrlReader,\n} from './types';\nimport getRawBody from 'raw-body';\nimport { AwsS3Integration, ScmIntegrations } from '@backstage/integration';\n\nconst parseURL = (\n  url: string,\n): { path: string; bucket: string; region: string } => {\n  let { host, pathname } = new URL(url);\n\n  /**\n   * Removes the leading '/' from the pathname to be processed\n   * as a parameter by AWS S3 SDK getObject method.\n   */\n  pathname = pathname.substr(1);\n\n  /**\n   * Checks that the given URL is a valid S3 object url.\n   * Format of a Valid S3 URL: https://bucket-name.s3.Region.amazonaws.com/keyname\n   */\n  const validHost = new RegExp(\n    /^[a-z\\d][a-z\\d\\.-]{1,61}[a-z\\d]\\.s3\\.[a-z\\d-]+\\.amazonaws.com$/,\n  );\n  if (!validHost.test(host)) {\n    throw new Error(`not a valid AWS S3 URL: ${url}`);\n  }\n\n  const [bucket] = host.split(/\\.s3\\.[a-z\\d-]+\\.amazonaws.com/);\n  host = host.substring(bucket.length);\n  const [, , region, ,] = host.split('.');\n\n  return {\n    path: pathname,\n    bucket: bucket,\n    region: region,\n  };\n};\n\nexport class AwsS3UrlReader implements UrlReader {\n  static factory: ReaderFactory = ({ config }) => {\n    const integrations = ScmIntegrations.fromConfig(config);\n\n    return integrations.awsS3.list().map(integration => {\n      const creds = AwsS3UrlReader.buildCredentials(integration);\n      const s3 = new S3({\n        apiVersion: '2006-03-01',\n        credentials: creds,\n      });\n      const reader = new AwsS3UrlReader(integration, s3);\n      const predicate = (url: URL) =>\n        url.host.endsWith(integration.config.host);\n      return { reader, predicate };\n    });\n  };\n\n  constructor(\n    private readonly integration: AwsS3Integration,\n    private readonly s3: S3,\n  ) {}\n\n  /**\n   * If accesKeyId and secretAccessKey are missing, the standard credentials provider chain will be used:\n   * https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/auth/DefaultAWSCredentialsProviderChain.html\n   */\n  private static buildCredentials(\n    integration?: AwsS3Integration,\n  ): Credentials | CredentialsOptions | undefined {\n    if (!integration) {\n      return undefined;\n    }\n\n    const accessKeyId = integration.config.accessKeyId;\n    const secretAccessKey = integration.config.secretAccessKey;\n    let explicitCredentials: Credentials | undefined;\n\n    if (accessKeyId && secretAccessKey) {\n      explicitCredentials = new Credentials({\n        accessKeyId,\n        secretAccessKey,\n      });\n    }\n\n    const roleArn = integration.config.roleArn;\n    if (roleArn) {\n      return new aws.ChainableTemporaryCredentials({\n        masterCredentials: explicitCredentials,\n        params: {\n          RoleSessionName: 'backstage-aws-s3-url-reader',\n          RoleArn: roleArn,\n        },\n      });\n    }\n\n    return explicitCredentials;\n  }\n\n  async read(url: string): Promise<Buffer> {\n    const response = await this.readUrl(url);\n    return response.buffer();\n  }\n\n  async readUrl(\n    url: string,\n    options?: ReadUrlOptions,\n  ): Promise<ReadUrlResponse> {\n    try {\n      const { path, bucket, region } = parseURL(url);\n      aws.config.update({ region: region });\n\n      let params;\n      if (options?.etag) {\n        params = {\n          Bucket: bucket,\n          Key: path,\n          IfNoneMatch: options.etag,\n        };\n      } else {\n        params = {\n          Bucket: bucket,\n          Key: path,\n        };\n      }\n\n      const response = this.s3.getObject(params);\n      const buffer = await getRawBody(response.createReadStream());\n      const etag = (await response.promise()).ETag;\n\n      return {\n        buffer: async () => buffer,\n        etag: etag,\n      };\n    } catch (e) {\n      throw new Error(`Could not retrieve file from S3: ${e.message}`);\n    }\n  }\n\n  async readTree(): Promise<ReadTreeResponse> {\n    throw new Error('AwsS3Reader does not implement readTree');\n  }\n\n  async search(): Promise<SearchResponse> {\n    throw new Error('AwsS3Reader does not implement search');\n  }\n\n  toString() {\n    const secretAccessKey = this.integration.config.secretAccessKey;\n    return `awsS3{host=${this.integration.config.host},authed=${Boolean(\n      secretAccessKey,\n    )}}`;\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from 'winston';\nimport { Config } from '@backstage/config';\nimport { ReaderFactory, UrlReader } from './types';\nimport { UrlReaderPredicateMux } from './UrlReaderPredicateMux';\nimport { AzureUrlReader } from './AzureUrlReader';\nimport { BitbucketUrlReader } from './BitbucketUrlReader';\nimport { GithubUrlReader } from './GithubUrlReader';\nimport { GitlabUrlReader } from './GitlabUrlReader';\nimport { DefaultReadTreeResponseFactory } from './tree';\nimport { FetchUrlReader } from './FetchUrlReader';\nimport { GoogleGcsUrlReader } from './GoogleGcsUrlReader';\nimport { AwsS3UrlReader } from './AwsS3UrlReader';\n\ntype CreateOptions = {\n  /** Root config object */\n  config: Config;\n  /** Logger used by all the readers */\n  logger: Logger;\n  /** A list of factories used to construct individual readers that match on URLs */\n  factories?: ReaderFactory[];\n};\n\n/**\n * UrlReaders provide various utilities related to the UrlReader interface.\n */\nexport class UrlReaders {\n  /**\n   * Creates a UrlReader without any known types.\n   */\n  static create({ logger, config, factories }: CreateOptions): UrlReader {\n    const mux = new UrlReaderPredicateMux(logger);\n    const treeResponseFactory = DefaultReadTreeResponseFactory.create({\n      config,\n    });\n\n    for (const factory of factories ?? []) {\n      const tuples = factory({ config, logger: logger, treeResponseFactory });\n\n      for (const tuple of tuples) {\n        mux.register(tuple);\n      }\n    }\n\n    return mux;\n  }\n\n  /**\n   * Creates a UrlReader that includes all the default factories from this package.\n   *\n   * Any additional factories passed will be loaded before the default ones.\n   */\n  static default({ logger, config, factories = [] }: CreateOptions) {\n    return UrlReaders.create({\n      logger,\n      config,\n      factories: factories.concat([\n        AzureUrlReader.factory,\n        BitbucketUrlReader.factory,\n        GithubUrlReader.factory,\n        GitlabUrlReader.factory,\n        GoogleGcsUrlReader.factory,\n        AwsS3UrlReader.factory,\n        FetchUrlReader.factory,\n      ]),\n    });\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport git, {\n  ProgressCallback,\n  MergeResult,\n  ReadCommitResult,\n} from 'isomorphic-git';\nimport http from 'isomorphic-git/http/node';\nimport fs from 'fs-extra';\nimport { Logger } from 'winston';\n\n/*\nprovider    username         password\nGitHub      'x-access-token' token\nBitBucket   'x-token-auth'   token\nGitLab      'oauth2'         token\nFrom : https://isomorphic-git.org/docs/en/onAuth with fix for GitHub\n\nAzure       'notempty'      token\n*/\nexport class Git {\n  private constructor(\n    private readonly config: {\n      username?: string;\n      password?: string;\n      logger?: Logger;\n    },\n  ) {}\n\n  async add({\n    dir,\n    filepath,\n  }: {\n    dir: string;\n    filepath: string;\n  }): Promise<void> {\n    this.config.logger?.info(`Adding file {dir=${dir},filepath=${filepath}}`);\n\n    return git.add({ fs, dir, filepath });\n  }\n\n  async addRemote({\n    dir,\n    url,\n    remote,\n  }: {\n    dir: string;\n    remote: string;\n    url: string;\n  }): Promise<void> {\n    this.config.logger?.info(\n      `Creating new remote {dir=${dir},remote=${remote},url=${url}}`,\n    );\n    return git.addRemote({ fs, dir, remote, url });\n  }\n\n  async commit({\n    dir,\n    message,\n    author,\n    committer,\n  }: {\n    dir: string;\n    message: string;\n    author: { name: string; email: string };\n    committer: { name: string; email: string };\n  }): Promise<string> {\n    this.config.logger?.info(\n      `Committing file to repo {dir=${dir},message=${message}}`,\n    );\n\n    return git.commit({ fs, dir, message, author, committer });\n  }\n\n  async clone({\n    url,\n    dir,\n    ref,\n  }: {\n    url: string;\n    dir: string;\n    ref?: string;\n  }): Promise<void> {\n    this.config.logger?.info(`Cloning repo {dir=${dir},url=${url}}`);\n    return git.clone({\n      fs,\n      http,\n      url,\n      dir,\n      ref,\n      singleBranch: true,\n      depth: 1,\n      onProgress: this.onProgressHandler(),\n      headers: {\n        'user-agent': 'git/@isomorphic-git',\n      },\n      onAuth: this.onAuth,\n    });\n  }\n\n  // https://isomorphic-git.org/docs/en/currentBranch\n  async currentBranch({\n    dir,\n    fullName,\n  }: {\n    dir: string;\n    fullName?: boolean;\n  }): Promise<string | undefined> {\n    const fullname = fullName ?? false;\n    return git.currentBranch({ fs, dir, fullname }) as Promise<\n      string | undefined\n    >;\n  }\n\n  // https://isomorphic-git.org/docs/en/fetch\n  async fetch({\n    dir,\n    remote,\n  }: {\n    dir: string;\n    remote?: string;\n  }): Promise<void> {\n    const remoteValue = remote ?? 'origin';\n    this.config.logger?.info(\n      `Fetching remote=${remoteValue} for repository {dir=${dir}}`,\n    );\n    await git.fetch({\n      fs,\n      http,\n      dir,\n      remote: remoteValue,\n      onProgress: this.onProgressHandler(),\n      headers: {\n        'user-agent': 'git/@isomorphic-git',\n      },\n      onAuth: this.onAuth,\n    });\n  }\n\n  async init({\n    dir,\n    defaultBranch = 'master',\n  }: {\n    dir: string;\n    defaultBranch?: string;\n  }): Promise<void> {\n    this.config.logger?.info(`Init git repository {dir=${dir}}`);\n\n    return git.init({\n      fs,\n      dir,\n      defaultBranch,\n    });\n  }\n\n  // https://isomorphic-git.org/docs/en/merge\n  async merge({\n    dir,\n    theirs,\n    ours,\n    author,\n    committer,\n  }: {\n    dir: string;\n    theirs: string;\n    ours?: string;\n    author: { name: string; email: string };\n    committer: { name: string; email: string };\n  }): Promise<MergeResult> {\n    this.config.logger?.info(\n      `Merging branch '${theirs}' into '${ours}' for repository {dir=${dir}}`,\n    );\n\n    // If ours is undefined, current branch is used.\n    return git.merge({\n      fs,\n      dir,\n      ours,\n      theirs,\n      author,\n      committer,\n    });\n  }\n\n  async push({ dir, remote }: { dir: string; remote: string }) {\n    this.config.logger?.info(\n      `Pushing directory to remote {dir=${dir},remote=${remote}}`,\n    );\n    return git.push({\n      fs,\n      dir,\n      http,\n      onProgress: this.onProgressHandler(),\n      headers: {\n        'user-agent': 'git/@isomorphic-git',\n      },\n      remote: remote,\n      onAuth: this.onAuth,\n    });\n  }\n\n  // https://isomorphic-git.org/docs/en/readCommit\n  async readCommit({\n    dir,\n    sha,\n  }: {\n    dir: string;\n    sha: string;\n  }): Promise<ReadCommitResult> {\n    return git.readCommit({ fs, dir, oid: sha });\n  }\n\n  // https://isomorphic-git.org/docs/en/resolveRef\n  async resolveRef({\n    dir,\n    ref,\n  }: {\n    dir: string;\n    ref: string;\n  }): Promise<string> {\n    return git.resolveRef({ fs, dir, ref });\n  }\n\n  private onAuth = () => ({\n    username: this.config.username,\n    password: this.config.password,\n  });\n\n  private onProgressHandler = (): ProgressCallback => {\n    let currentPhase = '';\n\n    return event => {\n      if (currentPhase !== event.phase) {\n        currentPhase = event.phase;\n        this.config.logger?.info(event.phase);\n      }\n      const total = event.total\n        ? `${Math.round((event.loaded / event.total) * 100)}%`\n        : event.loaded;\n      this.config.logger?.debug(`status={${event.phase},total={${total}}}`);\n    };\n  };\n\n  static fromAuth = ({\n    username,\n    password,\n    logger,\n  }: {\n    username?: string;\n    password?: string;\n    logger?: Logger;\n  }) => new Git({ username, password, logger });\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ServiceBuilderImpl } from './lib/ServiceBuilderImpl';\n\n/**\n * Creates a new service builder.\n */\nexport function createServiceBuilder(_module: NodeModule) {\n  return new ServiceBuilderImpl(_module);\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from 'winston';\nimport Router from 'express-promise-router';\nimport express from 'express';\nimport { errorHandler, statusCheckHandler, StatusCheck } from '../middleware';\n\nexport interface StatusCheckRouterOptions {\n  logger: Logger;\n  path?: string;\n  /**\n   * If not implemented, the default express middleware always returns 200.\n   * Override this to implement your own logic for a health check.\n   */\n  statusCheck?: StatusCheck;\n}\n\nexport async function createStatusCheckRouter(\n  options: StatusCheckRouterOptions,\n): Promise<express.Router> {\n  const router = Router();\n  const { path = '/healthcheck', statusCheck } = options;\n\n  router.use(path, await statusCheckHandler({ statusCheck }));\n  router.use(errorHandler());\n\n  return router;\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Docker from 'dockerode';\nimport fs from 'fs-extra';\nimport { PassThrough } from 'stream';\nimport { ContainerRunner, RunContainerOptions } from './ContainerRunner';\n\nexport type UserOptions = {\n  User?: string;\n};\n\nexport class DockerContainerRunner implements ContainerRunner {\n  private readonly dockerClient: Docker;\n\n  constructor({ dockerClient }: { dockerClient: Docker }) {\n    this.dockerClient = dockerClient;\n  }\n\n  async runContainer({\n    imageName,\n    command,\n    args,\n    logStream = new PassThrough(),\n    mountDirs = {},\n    workingDir,\n    envVars = {},\n    pullImage = true,\n  }: RunContainerOptions) {\n    // Show a better error message when Docker is unavailable.\n    try {\n      await this.dockerClient.ping();\n    } catch (e) {\n      throw new Error(\n        `This operation requires Docker. Docker does not appear to be available. Docker.ping() failed with: ${e.message}`,\n      );\n    }\n\n    if (pullImage) {\n      await new Promise<void>((resolve, reject) => {\n        this.dockerClient.pull(imageName, {}, (err, stream) => {\n          if (err) return reject(err);\n          stream.pipe(logStream, { end: false });\n          stream.on('end', () => resolve());\n          stream.on('error', (error: Error) => reject(error));\n          return undefined;\n        });\n      });\n    }\n\n    const userOptions: UserOptions = {};\n    if (process.getuid && process.getgid) {\n      // Files that are created inside the Docker container will be owned by\n      // root on the host system on non Mac systems, because of reasons. Mainly the fact that\n      // volume sharing is done using NFS on Mac and actual mounts in Linux world.\n      // So we set the user in the container as the same user and group id as the host.\n      // On Windows we don't have process.getuid nor process.getgid\n      userOptions.User = `${process.getuid()}:${process.getgid()}`;\n    }\n\n    // Initialize volumes to mount based on mountDirs map\n    const Volumes: { [T: string]: object } = {};\n    for (const containerDir of Object.values(mountDirs)) {\n      Volumes[containerDir] = {};\n    }\n\n    // Create bind volumes\n    const Binds: string[] = [];\n    for (const [hostDir, containerDir] of Object.entries(mountDirs)) {\n      // Need to use realpath here as Docker mounting does not like\n      // symlinks for binding volumes\n      const realHostDir = await fs.realpath(hostDir);\n      Binds.push(`${realHostDir}:${containerDir}`);\n    }\n\n    // Create docker environment variables array\n    const Env = [];\n    for (const [key, value] of Object.entries(envVars)) {\n      Env.push(`${key}=${value}`);\n    }\n\n    const [{ Error: error, StatusCode: statusCode }] =\n      await this.dockerClient.run(imageName, args, logStream, {\n        Volumes,\n        HostConfig: {\n          Binds,\n        },\n        ...(workingDir ? { WorkingDir: workingDir } : {}),\n        Entrypoint: command,\n        Env,\n        ...userOptions,\n      } as Docker.ContainerCreateOptions);\n\n    if (error) {\n      throw new Error(\n        `Docker failed to run with the following error message: ${error}`,\n      );\n    }\n\n    if (statusCode !== 0) {\n      throw new Error(\n        `Docker container returned a non-zero exit code (${statusCode})`,\n      );\n    }\n  }\n}\n"],"names":["winston","merge","PassThrough","createHash","Keyv","KeyvMemcache","ConfigReader","parseArgs","config","findPaths","loadConfig","resolvePath","knexFactory","yn","InputError","path","omit","serializeError","NotModifiedError","AuthenticationError","NotAllowedError","NotFoundError","ConflictError","morgan","http","https","fs","dirname","express","helmet","cors","compression","defaultRequestLoggingHandler","stoppable","isChildPath","getAzureFileFetchUrl","fetch","getAzureRequestOptions","getAzureCommitsUrl","getAzureDownloadUrl","parseGitUrl","Minimatch","ScmIntegrations","getBitbucketFileFetchUrl","getBitbucketRequestOptions","getBitbucketDownloadUrl","getBitbucketDefaultBranch","getGitHubFileFetchUrl","GithubCredentialsProvider","integration","getGitLabFileFetchUrl","getGitLabRequestOptions","Parse","promisify","pipelineCb","concatStream","tar","Readable","platformPath","unzipper","archiver","os","parseURL","getRawBody","readGoogleGcsIntegrationConfig","storage","Storage","Credentials","aws","S3","git","Router"],"mappings":"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"}